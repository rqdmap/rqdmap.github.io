<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"rqdmap.github.io","root":"/","scheme":"Gemini","version":"8.0.0-rc.3","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="[toc]">
<meta property="og:type" content="article">
<meta property="og:title" content="template">
<meta property="og:url" content="http://rqdmap.github.io/2020/06/17/template/index.html">
<meta property="og:site_name" content="rqdmap">
<meta property="og:description" content="[toc]">
<meta property="article:published_time" content="2020-06-17T08:34:39.000Z">
<meta property="article:modified_time" content="2021-03-31T13:24:26.463Z">
<meta property="article:author" content="rqdmap">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://rqdmap.github.io/2020/06/17/template/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-Hans'
  };
</script>

  <title>template | rqdmap</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
        <span class="toggle-line toggle-line-first"></span>
        <span class="toggle-line toggle-line-middle"></span>
        <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">rqdmap</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">莫被环境同化了野心。</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>Schedule</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://rqdmap.github.io/2020/06/17/template/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/huiye.png">
      <meta itemprop="name" content="rqdmap">
      <meta itemprop="description" content="rqdmap's personal blogs.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rqdmap">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          template
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-06-17 16:34:39" itemprop="dateCreated datePublished" datetime="2020-06-17T16:34:39+08:00">2020-06-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-03-31 21:24:26" itemprop="dateModified" datetime="2021-03-31T21:24:26+08:00">2021-03-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%A8%A1%E7%89%88/" itemprop="url" rel="index"><span itemprop="name">模版</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>[toc]</p>
<a id="more"></a>
<div STYLE="page-break-after: always;"></div>

<div STYLE="page-break-after: always;"></div>

<h2 id="1-字符串"><a href="#1-字符串" class="headerlink" title="1 字符串"></a>1 字符串</h2><h3 id="trie树"><a href="#trie树" class="headerlink" title="trie树"></a>trie树</h3><p>实现一：数组实现的按键查找</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxsize = <span class="number">26</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TRIE</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> ch[maxn][maxsize];</span><br><span class="line">    <span class="keyword">int</span> flag[maxn];</span><br><span class="line">    <span class="keyword">int</span> top = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//按照实际条件进行修改</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getid</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;<span class="keyword">return</span> c - <span class="string">'a'</span>;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//插入长度为n的字符串s[0,..n - 1]</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span> s[maxn], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> u = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> id = getid(s[i]);</span><br><span class="line">            <span class="keyword">if</span>(!ch[u][id]) ch[u][id] = top++;</span><br><span class="line">            u = ch[u][id];</span><br><span class="line">        &#125;</span><br><span class="line">        flag[u] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">query</span><span class="params">(<span class="keyword">char</span> s[maxn], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> u = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> id = getid(s[i]);</span><br><span class="line">            <span class="keyword">if</span>(!ch[u][id]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            u = ch[u][id];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag[u]) <span class="keyword">return</span> <span class="literal">true</span>; <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>实现二：数组实现的按边查找（左儿子右兄弟优化）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxsize = <span class="number">26</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxnode = maxn * maxsize;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TRIE</span>&#123;</span></span><br><span class="line"><span class="comment">//    vector&lt;int&gt; head, next;</span></span><br><span class="line"><span class="comment">//    vector&lt;char&gt; ch;</span></span><br><span class="line">    <span class="keyword">int</span> head[maxnode], next[maxnode];</span><br><span class="line">    <span class="keyword">char</span> ch[maxnode];</span><br><span class="line">    <span class="keyword">bool</span> flag[maxnode];</span><br><span class="line">    <span class="keyword">int</span> top = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span> s[maxn], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> u = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> find = <span class="number">0</span>, v;</span><br><span class="line">            <span class="keyword">for</span>(v = head[u]; v; v = next[v]) <span class="keyword">if</span>(ch[v] == s[i])&#123;</span><br><span class="line">                find = <span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!find)&#123;</span><br><span class="line">                v = top++;</span><br><span class="line">                ch[v] = s[i];</span><br><span class="line">                next[v] = head[u];</span><br><span class="line">                head[u] = v;</span><br><span class="line">            &#125;</span><br><span class="line">            u = v;</span><br><span class="line">        &#125;</span><br><span class="line">        flag[u] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">query</span><span class="params">(<span class="keyword">char</span> s[maxn], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> u = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> find = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> v = head[u]; v; v = next[v]) <span class="keyword">if</span>(ch[v] == s[i])&#123;</span><br><span class="line">                find = <span class="number">1</span>; u = v; <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!find) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag[u]) <span class="keyword">return</span> <span class="literal">true</span>; <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>实现二倒是第一次见，与实现一的区别大概就是邻接表与邻接矩阵的区别。</p>
<p>在对于空间要求更加特殊的环境中可以用<code>实现二</code>优化空间<del>然而总感觉不用vector的话空间消耗比实现一更大？</del>，具体的情况等以后遇到了再修改板子。</p>
<h3 id="Manacher"><a href="#Manacher" class="headerlink" title="Manacher"></a>Manacher</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> Manacher算法</span></span><br><span class="line"><span class="comment"> 读入一个字符串temp及其长度n;</span></span><br><span class="line"><span class="comment"> 该算法构造出s并赋予截断标志, 自动初始化、获得数组p[i];</span></span><br><span class="line"><span class="comment"> 对于某个位置i∈[0, 2 * n], 以i为中心的回文串的参数如下:</span></span><br><span class="line"><span class="comment">    int start = (i / 2) - (p[i] / 2) + (i &amp; 1), d = p[i] - 1;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">char</span> temp[maxn], s[maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> p[maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">manacher</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//scanf("%s", temp);</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        s[i &lt;&lt; <span class="number">1</span>] = <span class="string">'#'</span>; s[i &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] = temp[i];</span><br><span class="line">    &#125;</span><br><span class="line">    s[n &lt;&lt; <span class="number">1</span>] = <span class="string">'#'</span>; s[n &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> id = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n &lt;&lt; <span class="number">1</span>; i++) p[i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n &lt;&lt; <span class="number">1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt;= right) p[i] = min(right - i + <span class="number">1</span>, p[<span class="number">2</span> * id - i]);</span><br><span class="line">        <span class="keyword">while</span>(i + p[i] &lt;= <span class="number">2</span> * n &amp;&amp; i - p[i] &gt;= <span class="number">0</span> &amp;&amp; s[i + p[i]] == s[i - p[i]])</span><br><span class="line">            p[i]++;</span><br><span class="line">        <span class="keyword">if</span>(right &lt; i + p[i] - <span class="number">1</span>)&#123;</span><br><span class="line">            id = i; right = i + p[i] - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意，从1开始编号！</span></span><br><span class="line"><span class="keyword">int</span> nxt[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kmp</span><span class="params">(<span class="keyword">char</span> s[maxn], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(nxt, <span class="number">0</span>, <span class="keyword">sizeof</span> nxt); </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> p = nxt[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span>(p &gt; <span class="number">0</span> &amp;&amp; s[p + <span class="number">1</span>] != s[i]) p = nxt[p];</span><br><span class="line">        <span class="keyword">if</span>(s[p + <span class="number">1</span>] == s[i]) p++;</span><br><span class="line">        nxt[i] = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="AC自动机"><a href="#AC自动机" class="headerlink" title="AC自动机"></a>AC自动机</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[maxn * <span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> ch[maxn][N], top = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> fail[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> pos[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span> *s, <span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; s[i]; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!ch[p][s[i] - <span class="string">'a'</span>]) ch[p][s[i] - <span class="string">'a'</span>] = top++;</span><br><span class="line">        p = ch[p][s[i] - <span class="string">'a'</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    pos[id] = p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getfail</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) <span class="keyword">if</span>(ch[<span class="number">0</span>][i])&#123;</span><br><span class="line">        fail[ch[<span class="number">0</span>][i]] = <span class="number">0</span>;</span><br><span class="line">        q.push(ch[<span class="number">0</span>][i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> now = q.front(); q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ch[now][i])&#123;</span><br><span class="line">                fail[ch[now][i]] = ch[fail[now]][i];</span><br><span class="line">                q.push(ch[now][i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> ch[now][i] = ch[fail[now]][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">star</span>&#123;</span><span class="keyword">int</span> to, next;&#125;edge[maxn];</span><br><span class="line"><span class="keyword">int</span> head[maxn], _top = <span class="number">0</span>, sze[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    edge[_top].to = v;</span><br><span class="line">    edge[_top].next = head[u];</span><br><span class="line">    head[u] = _top++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> now)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[now]; ~i; i = edge[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> to = edge[i].to; dfs(to);</span><br><span class="line">        sze[now] += sze[to];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//    Fastin;</span></span><br><span class="line">    clr(head, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s); insert(s, i);</span><br><span class="line">    &#125;</span><br><span class="line">    getfail();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, p = <span class="number">0</span>; s[i]; i++)&#123;</span><br><span class="line">        p = ch[p][s[i] - <span class="string">'a'</span>];</span><br><span class="line">        sze[p]++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; top; i++) add(fail[i], i); dfs(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, sze[pos[i]]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查询在主串中所有模式串出现的次数。</p>
<p>不能暴力跳fail进行匹配，对于主串的每一个位置有可能fail遍历所有深度（如aaaaaaa)，因而建fail树记录并每一个节点被直接访问的次数，最后dfs求得节点所在的子树总共的访问次数即可。</p>
<h3 id="回文树"><a href="#回文树" class="headerlink" title="回文树"></a>回文树</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">3e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">26</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">char</span> s[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> len[maxn], fail[maxn];</span><br><span class="line"><span class="keyword">int</span> ch[maxn][N], top;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ini</span><span class="params">()</span></span>&#123;fail[<span class="number">1</span>] = fail[<span class="number">0</span>] = <span class="number">1</span>; len[<span class="number">1</span>] = <span class="number">-1</span>; top = <span class="number">2</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入字符s[n]</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getfail</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(s[n - <span class="number">1</span> - len[x]] != s[n]) x = fail[x];</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//下标从1开始</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">char</span> s[maxn])</span></span>&#123;</span><br><span class="line">    ini();</span><br><span class="line">    <span class="comment">//选取一个保证不会出现的字符。</span></span><br><span class="line">    s[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//last维护了以s[n - 1]结尾的最长回文子串的节点标号。</span></span><br><span class="line">    <span class="keyword">int</span> last = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; s[i]; i++)&#123;</span><br><span class="line">        s[i] -= <span class="string">'a'</span>;</span><br><span class="line">        <span class="keyword">int</span> p = getfail(last, i);</span><br><span class="line">        <span class="keyword">if</span>(!ch[p][s[i]])&#123;</span><br><span class="line">            len[top] = len[p] + <span class="number">2</span>;</span><br><span class="line">            fail[top] = ch[getfail(fail[p], i)][s[i]];</span><br><span class="line">            ch[p][s[i]] = top;</span><br><span class="line">            top++;</span><br><span class="line">        &#125;</span><br><span class="line">        last = ch[p][s[i]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-计算几何"><a href="#2-计算几何" class="headerlink" title="2 计算几何"></a>2 计算几何</h2><h3 id="已知平面圆上三点求圆心及其半径"><a href="#已知平面圆上三点求圆心及其半径" class="headerlink" title="已知平面圆上三点求圆心及其半径"></a>已知平面圆上三点求圆心及其半径</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cal</span><span class="params">(<span class="keyword">double</span> x1, <span class="keyword">double</span> y1, <span class="keyword">double</span> x2, <span class="keyword">double</span> y2, <span class="keyword">double</span> x3, <span class="keyword">double</span> y3)</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> a, b, c, d, e, f;</span><br><span class="line">    a = <span class="number">2</span> * (x2 - x1);</span><br><span class="line">    b = <span class="number">2</span> * (y2 - y1);</span><br><span class="line">    c = x2 * x2 + y2 * y2 - x1 * x1 - y1 * y1;</span><br><span class="line">    d = <span class="number">2</span> * (x3 - x2);</span><br><span class="line">    e = <span class="number">2</span> * (y3 - y2);</span><br><span class="line">    f = x3 * x3 + y3 * y3 - x2 * x2 - y2 * y2;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">double</span> x, y, r;</span><br><span class="line">    x = (b * f - e * c)/(b * d - e * a);</span><br><span class="line">    y = (d * c - a * f)/(b * d - e * a);</span><br><span class="line">    r = <span class="built_in">sqrt</span>((x - x1) * (x - x1) + (y - y1) * (y - y1));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>证明方法是做差解二元一次方程的行列式表达。</p>
<p>根据实际需要将函数中的<code>x, y, r</code>的值进行转移(<del>要是再加入3个替身变量就好长的列表</del>)。</p>
<h3 id="平面上圆的k次交"><a href="#平面上圆的k次交" class="headerlink" title="平面上圆的k次交"></a>平面上圆的k次交</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> manx = <span class="number">1e2</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-8</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">sgn</span><span class="params">(<span class="keyword">double</span> x)</span></span>&#123;<span class="keyword">return</span> x &lt; -eps? <span class="number">-1</span>: x &gt; eps? <span class="number">1</span>: <span class="number">0</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">sqr</span><span class="params">(<span class="keyword">double</span> x)</span></span>&#123;<span class="keyword">return</span> x * x;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CIRCLE</span>&#123;</span></span><br><span class="line">    <span class="keyword">double</span> x, y, r, angle;</span><br><span class="line">    <span class="keyword">int</span> d;</span><br><span class="line">    CIRCLE()&#123;d = <span class="number">1</span>; angle = <span class="number">0</span>;&#125;</span><br><span class="line">    CIRCLE(<span class="keyword">double</span> _x, <span class="keyword">double</span> _y, <span class="keyword">double</span> _angle = <span class="number">0</span>, <span class="keyword">int</span> _d = <span class="number">0</span>)&#123;</span><br><span class="line">        x = _x; y = _y; angle = _angle; d = _d; r = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> CIRCLE &amp;b)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sgn(r - b.r) == <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">dis</span><span class="params">(CIRCLE a, CIRCLE b)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">sqrt</span>(sqr(a.x - b.x) + sqr(a.y - b.y));&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">cross</span><span class="params">(CIRCLE a, CIRCLE b, CIRCLE c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//有两个交点返回true，以及两个交点的坐标和方位角，p1按照顺时针，p2按照逆时针</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cir_inter_cir</span><span class="params">(CIRCLE a, CIRCLE b, CIRCLE &amp;p1, CIRCLE &amp;p2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> d = dis(a, b);</span><br><span class="line">    <span class="keyword">if</span>(sgn(d - a.r - b.r) &gt;= <span class="number">0</span> || sgn(<span class="built_in">abs</span>(b.r - a.r) - d) &gt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">double</span> cosa = (sqr(a.r) + sqr(d) - sqr(b.r)) / (<span class="number">2</span> * a.r * d);</span><br><span class="line">    <span class="keyword">double</span> sina = <span class="built_in">sqrt</span>(max(<span class="number">0.</span>, <span class="number">1.</span> - sqr(cosa)));</span><br><span class="line">    <span class="comment">//旋转矩阵 [cosa, -sina; sina, cosa]</span></span><br><span class="line">    p1 = p2 = a;</span><br><span class="line">    p1.x += a.r / d * ((b.x - a.x) * cosa + (b.y - a.y) * -sina);</span><br><span class="line">    p1.y += a.r / d * ((b.x - a.x) * sina + (b.y - a.y) * cosa);</span><br><span class="line">    p2.x += a.r / d * ((b.x - a.x) * cosa + (b.y - a.y) * sina);</span><br><span class="line">    p2.y += a.r / d * ((b.x - a.x) * -sina + (b.y - a.y) * cosa);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> CIRCLE &amp;a, <span class="keyword">const</span> CIRCLE &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(sgn(a.angle - b.angle)) <span class="keyword">return</span> sgn(a.angle - b.angle) == <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> a.d &gt; b.d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">cal</span><span class="params">(CIRCLE a, CIRCLE p1, CIRCLE p2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> ans = sqr(a.r) * (p2.angle - p1.angle) - cross(a, p1, p2) + cross(CIRCLE(<span class="number">0</span>, <span class="number">0</span>), p1, p2);</span><br><span class="line">    <span class="keyword">return</span> ans / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CIRCLE dot[maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">double</span> area[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cirunion</span><span class="params">(CIRCLE cir[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    sort(cir, cir + n);</span><br><span class="line">    <span class="comment">//记录每个圆被完全覆盖的次数，初始值显然为1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">        <span class="keyword">if</span>(sgn(dis(cir[i], cir[j]) + cir[i].r - cir[j].r) &lt;= <span class="number">0</span>) cir[i].d++;</span><br><span class="line">    CIRCLE p1, p2;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="comment">//针对每一个圆考虑它与所有其他圆的交</span></span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>, top = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == j) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(!cir_inter_cir(cir[i], cir[j], p1, p2)) <span class="keyword">continue</span>;</span><br><span class="line">            p1.angle = <span class="built_in">atan2</span>(p1.y - cir[i].y, p1.x - cir[i].x);</span><br><span class="line">            p2.angle = <span class="built_in">atan2</span>(p2.y - cir[i].y, p2.x - cir[i].x);</span><br><span class="line">            p1.d = <span class="number">-1</span>; p2.d = <span class="number">1</span>;</span><br><span class="line">            dot[top++] = p1; dot[top++] = p2;</span><br><span class="line">            <span class="keyword">if</span>(sgn(p2.angle - p1.angle) == <span class="number">1</span>) cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//加入起点终点位置</span></span><br><span class="line">        dot[top++] = CIRCLE(cir[i].x - cir[i].r, cir[i].y, -pi, <span class="number">-2</span>);</span><br><span class="line">        dot[top++] = CIRCLE(cir[i].x - cir[i].r, cir[i].y, pi, <span class="number">2</span>);</span><br><span class="line">        sort(dot, dot + top, cmp);</span><br><span class="line">        <span class="keyword">int</span> now = cir[i].d + cnt;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; top; j++)&#123;</span><br><span class="line">            area[now] += cal(cir[i], dot[j - <span class="number">1</span>], dot[j]);</span><br><span class="line">            now += dot[j].d;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CIRCLE cir[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//    Fastin;</span></span><br><span class="line">    <span class="keyword">int</span> t; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t); <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        clr(area, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">"%lf %lf %lf"</span>, &amp;cir[i].x, &amp;cir[i].y, &amp;cir[i].r);</span><br><span class="line">        cirunion(cir, n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">printf</span>(<span class="string">"%.5f\n"</span>, area[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="凸包周长"><a href="#凸包周长" class="headerlink" title="凸包周长"></a>凸包周长</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e2</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-9</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">POINT</span>&#123;</span></span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line">    POINT <span class="keyword">operator</span> - (<span class="keyword">const</span> POINT &amp;b)&#123;</span><br><span class="line">        POINT temp;</span><br><span class="line">        temp.x = x - b.x;</span><br><span class="line">        temp.y = y - b.y;</span><br><span class="line">        <span class="keyword">return</span> tmep;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;p[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">cross</span><span class="params">(POINT a, POINT b)</span></span>&#123; <span class="keyword">return</span> a.x * b.y - a.y * b.x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dis</span><span class="params">(POINT a)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">sqrt</span>(a.x * a.x + a.y * a.y);&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sgn</span><span class="params">(<span class="keyword">double</span> x)</span></span>&#123;<span class="keyword">return</span> x &lt; -eps? <span class="number">-1</span>: x &gt; eps? <span class="number">1</span>: <span class="number">0</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(POINT a, POINT b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> flag = sgn(cross(a, b));</span><br><span class="line">    <span class="keyword">if</span>(flag == <span class="number">0</span>) <span class="keyword">return</span> dis(a) &lt; dis(b);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> flag == <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sta[maxn], top = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;sta[top++] = x;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// Fastin;</span></span><br><span class="line">    <span class="keyword">int</span> n; <span class="keyword">while</span>(~scnaf(<span class="string">"%d"</span>, &amp;n) &amp;&amp; n)&#123;</span><br><span class="line">        top = <span class="number">0</span>; <span class="keyword">int</span> id = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n ; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> x, y; scnaf(<span class="string">"%d %d"</span>, &amp;x, &amp;y);</span><br><span class="line">            p[i].x = x; p[i].y = y;</span><br><span class="line">            <span class="keyword">if</span>(id == <span class="number">-1</span> || (p[id].x &gt; p[i].x) || (p[id].x == p[i].x &amp;&amp; p[id].y &gt; p[i].y)) id = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//不特判计算几何的都是xx!</span></span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;<span class="built_in">puts</span>(<span class="string">"0.00"</span>); <span class="keyword">continue</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">2</span>)&#123;<span class="built_in">printf</span>(<span class="string">"%.2f\n"</span>, dis(p[<span class="number">1</span>] - p[<span class="number">2</span>])); <span class="keyword">continue</span>;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">if</span>(i != id) p[i] = p[i] - p[id];</span><br><span class="line">        p[id].x = p[id].y = <span class="number">0</span>;</span><br><span class="line">        sort(p + <span class="number">1</span>, p + <span class="number">1</span> + n, cmp);</span><br><span class="line"></span><br><span class="line">        push(<span class="number">1</span>); push(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(sgn(cross(p[i] - p[sta[top - <span class="number">2</span>]], p[i] - p[sta[top - <span class="number">1</span>]])) &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                    push(i); <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> top--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">double</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; top; i++) ans += dis(p[sta[i]] - p[sta[i - <span class="number">1</span>]]);</span><br><span class="line">        ans += dis(p[sta[<span class="number">0</span>]] - p[sta[top - <span class="number">1</span>]]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%.2f\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复杂度$O(nlogn)$</p>
<p>求周长需要循环地求一遍栈中相邻两个元素的距离！不要漏求sta[0]与sta[top - 1]！</p>
<h2 id="3-图论"><a href="#3-图论" class="headerlink" title="3 图论"></a>3 图论</h2><h3 id="最短路"><a href="#最短路" class="headerlink" title="最短路"></a>最短路</h3><h4 id="01bfs"><a href="#01bfs" class="headerlink" title="01bfs"></a>01bfs</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(双端队列非空)&#123;</span><br><span class="line">  取出队首元素now</span><br><span class="line">  <span class="keyword">for</span>(now的相邻节点)&#123;</span><br><span class="line">    更新距离</span><br><span class="line">    <span class="keyword">if</span>(边权为<span class="number">0</span>) 添加到队首</span><br><span class="line">    <span class="keyword">else</span> 添加到队尾</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当图中边权仅为0或1时，可以使用01bfs解决单源最短路问题。</p>
<p>时间复杂度$O(V+E)$</p>
<h3 id="异或MST-（Boruvka算法）"><a href="#异或MST-（Boruvka算法）" class="headerlink" title="异或MST （Boruvka算法）"></a>异或MST （Boruvka算法）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = ~<span class="number">0u</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, w[maxn], c[maxn];;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ch[maxn * N][<span class="number">2</span>], sze = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = N - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="keyword">int</span> id = (x &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(ch[p][id] == <span class="number">0</span>) ch[p][id] = sze++;</span><br><span class="line">        p = ch[p][id];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = N - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="keyword">int</span> id = (x &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(ch[p][id] &gt; <span class="number">0</span>) p = ch[p][id];</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            ans |= <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">            p = ch[p][id ^ <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll ans = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sove</span><span class="params">(<span class="keyword">int</span> d, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &lt; <span class="number">1</span> || r &gt; n || l &gt; r || d &lt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> L = l - <span class="number">1</span>, R = r + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = l; i &lt;= r; i++)</span><br><span class="line">        <span class="keyword">if</span>(w[i] &amp; <span class="number">1</span> &lt;&lt; d) c[--R] = w[i];</span><br><span class="line">        <span class="keyword">else</span> c[++L] = w[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = l; i &lt;= r; i++) w[i] = c[i];</span><br><span class="line">    </span><br><span class="line">    sove(d - <span class="number">1</span>, l, L);</span><br><span class="line">    sove(d - <span class="number">1</span>, R, r);</span><br><span class="line">    <span class="keyword">if</span>(L &lt; l || R &gt; r) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = l; i &lt;= L; i++) insert(w[i]);</span><br><span class="line">    <span class="keyword">int</span> m = inf;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = R; i &lt;= r; i++) m = min(m, query(w[i]));</span><br><span class="line">    ans += m;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sze; i++) ch[i][<span class="number">0</span>] = ch[i][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    sze = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//    Fastin;</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n); <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, w + i);</span><br><span class="line">    sove(N - <span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>模板规定节点从1开始标号，点权$w_i&lt;2^{30}$，具体题目应该结合范围进行具体分析。</p>
<h3 id="图的匹配"><a href="#图的匹配" class="headerlink" title="图的匹配"></a>图的匹配</h3><h4 id="二分图最大匹配"><a href="#二分图最大匹配" class="headerlink" title="二分图最大匹配"></a>二分图最大匹配</h4><h5 id="匈牙利算法"><a href="#匈牙利算法" class="headerlink" title="匈牙利算法"></a>匈牙利算法</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> manx = <span class="number">510</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, n1, n2, m;</span><br><span class="line"><span class="keyword">int</span> head[maxn &lt;&lt; <span class="number">1</span>], top = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">star</span>&#123;</span><span class="keyword">int</span> to, next;&#125;;</span><br><span class="line">star edge[maxn * maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    edge[top].to = v;</span><br><span class="line">    edge[top].next = head[u];</span><br><span class="line">    head[u] = top++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> vis[maxn &lt;&lt; <span class="number">1</span>], match[maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; ~i; i = edge[i].next) <span class="keyword">if</span>(!vis[edge[i].to])&#123;</span><br><span class="line">        <span class="keyword">int</span> to = edge[i].to; vis[to] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(!match[to] || find(match[to]))&#123;</span><br><span class="line">            match[to] = u;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hungary</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        clr(vis, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(find(i)) ans++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//    Fastin;</span></span><br><span class="line">    clr(head, <span class="number">-1</span>);</span><br><span class="line"> 		<span class="comment">//读入n1, n2, m, 表示两边点集的数量和边数，取n = max(n1, n2)作为序号的偏移量。</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;n1, &amp;n2, &amp;m); n = max(n1, n2);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> u, v; <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;u, &amp;v);</span><br><span class="line">        add(u, v + n);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, hungary());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n2; i++) ans[match[i + n]] = i;</span><br><span class="line">    prt(ans + <span class="number">1</span>, n1);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>匈牙利算法，两边点集大小均为maxn，因而有关数组需要开至2倍甚至更多。</p>
<p>复杂度$O(nm)$</p>
<p><strong>每次为ai分配路径的时候都要对vis数组初始化，多组数据的时候复杂度会变成O(Tmaxn), 记得改掉memset！</strong></p>
<h5 id="最大流-Dinic实现"><a href="#最大流-Dinic实现" class="headerlink" title="最大流(Dinic实现)"></a>最大流(Dinic实现)</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> itn maxn = <span class="number">1200</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxe = <span class="number">120000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> ll inf = <span class="number">1l</span>l &lt;&lt; <span class="number">60</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">star</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next, w;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> head[maxn], top = <span class="number">0</span>;</span><br><span class="line">star edge[maxe &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    edge[top].to = v;</span><br><span class="line">    edge[top].next = head[u];</span><br><span class="line">    edge[top].w = w;</span><br><span class="line">    head[u] = top++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> d[maxn], cur[maxn];</span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t, ll flow)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (flow == <span class="number">0</span> || s == t)</span><br><span class="line">        <span class="keyword">return</span> flow;</span><br><span class="line"></span><br><span class="line">    ll res = <span class="number">0</span>, f;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = cur[s]; ~i; i = edge[i].next) &#123;</span><br><span class="line">        cur[s] = i;</span><br><span class="line">        <span class="keyword">if</span> (d[edge[i].to] == d[s] + <span class="number">1</span>) &#123;</span><br><span class="line">            f = dfs(edge[i].to, t, min(flow, (ll)edge[i].w));</span><br><span class="line">            edge[i].w -= f;</span><br><span class="line">            edge[i ^ <span class="number">1</span>].w += f;</span><br><span class="line">            res += f;</span><br><span class="line">            flow -= f;</span><br><span class="line">            <span class="keyword">if</span> (flow == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q, q0;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    clr(d, <span class="number">0</span>);</span><br><span class="line">    q = q0;</span><br><span class="line">    q.push(s);</span><br><span class="line">    cur[s] = head[s];</span><br><span class="line">    d[s] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> now = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[now]; ~i; i = edge[i].next)</span><br><span class="line">            <span class="keyword">if</span> (!d[edge[i].to] &amp;&amp; edge[i].w &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                cur[edge[i].to] = head[edge[i].to];</span><br><span class="line">                d[edge[i].to] = d[now] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (edge[i].to == t)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                q.push(edge[i].to);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">dinic</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (bfs(s, t)) ans += dfs(s, t, inf);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//    Fastin;</span></span><br><span class="line">    clr(head, <span class="number">-1</span>);</span><br><span class="line">     <span class="comment">//读入n1, n2, m, 表示两边点集的数量和边数，取n = max(n1, n2)作为序号的偏移量。</span></span><br><span class="line">    <span class="keyword">int</span> n1, n2, m, n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;n1, &amp;n2, &amp;m); n = max(n1, n2);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> u, v; <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;u, &amp;v);</span><br><span class="line">        add(u, v + n, <span class="number">1</span>);</span><br><span class="line">        add(v + n, u, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n1; i++)&#123;add(<span class="number">0</span>, i, <span class="number">1</span>); add(i, <span class="number">0</span>, <span class="number">0</span>);&#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n2; i++)&#123;add(i + n, <span class="number">2</span> * n + <span class="number">1</span>, <span class="number">1</span>); add(<span class="number">2</span> * n + <span class="number">1</span>, i + n, <span class="number">0</span>);&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, dinic(<span class="number">0</span>, <span class="number">2</span> * n + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以证明，Dinic实现二分图的最大流复杂度$O(\sqrt n m)$，比朴素的匈牙利算法要快上一些。</p>
<p>不过如果使用了网络流算法可能就不能找出匹配方案了。</p>
<h4 id="二分图最大权匹配"><a href="#二分图最大权匹配" class="headerlink" title="二分图最大权匹配"></a>二分图最大权匹配</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">410</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> match[maxn];</span><br><span class="line"><span class="keyword">int</span> ex[<span class="number">2</span>][maxn], vis[<span class="number">2</span>][maxn];;</span><br><span class="line"><span class="keyword">int</span> slack[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> now)</span></span>&#123;</span><br><span class="line">    vis[<span class="number">0</span>][now] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="keyword">if</span>(!vis[<span class="number">1</span>][i])&#123;</span><br><span class="line">        <span class="keyword">int</span> gap = ex[<span class="number">0</span>][now] + ex[<span class="number">1</span>][i] - a[now][i];</span><br><span class="line">        <span class="keyword">if</span>(gap == <span class="number">0</span>)&#123;</span><br><span class="line">            vis[<span class="number">1</span>][i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(match[i] == <span class="number">-1</span> || dfs(match[i]))&#123; match[i] = now; <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> slack[i] = min(slack[i], gap);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">km</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;match[i] = <span class="number">-1</span>; ex[<span class="number">0</span>][i] = ex[<span class="number">1</span>][i] = <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) ex[<span class="number">0</span>][i] = max(ex[<span class="number">0</span>][i], a[i][j]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) slack[i] = inf;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) vis[<span class="number">0</span>][i] = vis[<span class="number">1</span>][i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(dfs(i)) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> d = inf; <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="keyword">if</span>(!vis[<span class="number">1</span>][i]) d = min(d, slack[i]);</span><br><span class="line">            <span class="keyword">int</span> pos = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(vis[<span class="number">0</span>][i]) ex[<span class="number">0</span>][i] -= d;</span><br><span class="line">                <span class="keyword">if</span>(vis[<span class="number">1</span>][i]) ex[<span class="number">1</span>][i] += d;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    slack[i] -= d;</span><br><span class="line">                    <span class="keyword">if</span>(slack[i] == <span class="number">0</span>) pos = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            assert(pos != <span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">if</span>(match[pos] == <span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">int</span> u = match[pos];</span><br><span class="line">            vis[<span class="number">0</span>][u] = vis[<span class="number">1</span>][pos] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="keyword">if</span>(!vis[<span class="number">1</span>][i]) slack[i] = min(slack[i], ex[<span class="number">0</span>][u] + ex[<span class="number">1</span>][i] - a[u][i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) vis[<span class="number">0</span>][i] = vis[<span class="number">1</span>][i] = <span class="number">0</span>;</span><br><span class="line">        dfs(i);</span><br><span class="line">    &#125;</span><br><span class="line">    ll res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) res += a[match[i]][i];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//    Fastin;</span></span><br><span class="line">    <span class="keyword">int</span> n1, n2, m; <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;n1, &amp;n2, &amp;m);</span><br><span class="line">    n = max(n1, n2);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> u, v, w; <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line">        u--; v--; a[u][v] = w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, km());</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n2; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(match[i] == <span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[match[i]][i] == <span class="number">0</span>) ans[match[i]] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> ans[match[i]] = i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n1; i++) <span class="built_in">printf</span>(<span class="string">"%d "</span>, ans[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>读入左右点数和边数，接下来跟m行有向边及其边权。</p>
<p>点数范围400，边权1e9。</p>
<p><strong>找增广路径的dfs不能放在while循环中，不然成为假算法$O(n^4)$。</strong></p>
<p>为了修改标记使一条可行增广路存在只需要修改slack tag即可，因为只需要在while循环中更新slack即可。</p>
<h3 id="流算法"><a href="#流算法" class="headerlink" title="流算法"></a>流算法</h3><h4 id="最大流"><a href="#最大流" class="headerlink" title="最大流"></a>最大流</h4><h5 id="dinic-当前弧优化"><a href="#dinic-当前弧优化" class="headerlink" title="dinic (当前弧优化)"></a>dinic (当前弧优化)</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> itn maxn = <span class="number">1200</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxe = <span class="number">120000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> ll inf = <span class="number">1l</span>l &lt;&lt; <span class="number">60</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">star</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next, w;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> head[maxn], top = <span class="number">0</span>;</span><br><span class="line">star edge[maxe &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    edge[top].to = v;</span><br><span class="line">    edge[top].next = head[u];</span><br><span class="line">    edge[top].w = w;</span><br><span class="line">    head[u] = top++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> d[maxn], cur[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t, ll flow)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (flow == <span class="number">0</span> || s == t)</span><br><span class="line">        <span class="keyword">return</span> flow;</span><br><span class="line"></span><br><span class="line">    ll res = <span class="number">0</span>, f;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = cur[s]; ~i; i = edge[i].next) &#123;</span><br><span class="line">        cur[s] = i;</span><br><span class="line">        <span class="keyword">if</span> (d[edge[i].to] == d[s] + <span class="number">1</span>) &#123;</span><br><span class="line">            f = dfs(edge[i].to, t, min(flow, (ll)edge[i].w));</span><br><span class="line">            edge[i].w -= f;</span><br><span class="line">            edge[i ^ <span class="number">1</span>].w += f;</span><br><span class="line">            res += f;</span><br><span class="line">            flow -= f;</span><br><span class="line">            <span class="keyword">if</span> (flow == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q, q0;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    clr(d, <span class="number">0</span>);</span><br><span class="line">    q = q0;</span><br><span class="line">    q.push(s);</span><br><span class="line">    cur[s] = head[s];</span><br><span class="line">    d[s] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> now = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[now]; ~i; i = edge[i].next)</span><br><span class="line">            <span class="keyword">if</span> (!d[edge[i].to] &amp;&amp; edge[i].w &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                cur[edge[i].to] = head[edge[i].to];</span><br><span class="line">                d[edge[i].to] = d[now] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (edge[i].to == t)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                q.push(edge[i].to);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">dinic</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (bfs(s, t)) ans += dfs(s, t, inf);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//    Fastin;</span></span><br><span class="line">    clr(head, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">int</span> n, m, s, t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d %d %d"</span>, &amp;n, &amp;m, &amp;s, &amp;t);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, u, v, w; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line">        add(u, v, w);</span><br><span class="line">        add(v, u, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, dinic(s, t));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>$O(n^2  m)$</p>
<h5 id="isap-gap优化"><a href="#isap-gap优化" class="headerlink" title="isap (gap优化)"></a>isap (gap优化)</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> itn maxn = <span class="number">1200</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxe = <span class="number">120000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> ll inf = <span class="number">1l</span>l &lt;&lt; <span class="number">60</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">star</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next, w;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> n, m, s, t;</span><br><span class="line"><span class="keyword">int</span> head[maxn], top = <span class="number">0</span>;</span><br><span class="line">star edge[maxe &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    edge[top].to = v;</span><br><span class="line">    edge[top].next = head[u];</span><br><span class="line">    edge[top].w = w;</span><br><span class="line">    head[u] = top++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> d[maxn], cur[maxn], gap[maxn];</span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    q.push(t);</span><br><span class="line">    gap[d[t] = <span class="number">1</span>]++;</span><br><span class="line">    cur[t] = head[t];</span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> now = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[now]; ~i; i = edge[i].next)</span><br><span class="line">            <span class="keyword">if</span> (!d[edge[i].to]) &#123;</span><br><span class="line">                gap[d[edge[i].to] = d[now] + <span class="number">1</span>]++;</span><br><span class="line">                cur[edge[i].to] = head[edge[i].to];</span><br><span class="line">                q.push(edge[i].to);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> s, <span class="keyword">int</span> t, ll flow)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == t)</span><br><span class="line">        <span class="keyword">return</span> flow;</span><br><span class="line"></span><br><span class="line">    ll res = <span class="number">0</span>, f;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = cur[x]; ~i; i = edge[i].next) &#123;</span><br><span class="line">        cur[x] = i;</span><br><span class="line">        <span class="keyword">if</span> (d[x] == d[edge[i].to] + <span class="number">1</span>) &#123;</span><br><span class="line">            f = dfs(edge[i].to, s, t, min(flow, (ll)edge[i].w));</span><br><span class="line">            edge[i].w -= f;</span><br><span class="line">            edge[i ^ <span class="number">1</span>].w += f;</span><br><span class="line">            flow -= f;</span><br><span class="line">            res += f;</span><br><span class="line">            <span class="keyword">if</span> (flow == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!(gap[d[x]]--))</span><br><span class="line">        d[s] = n + <span class="number">1</span>;</span><br><span class="line">    gap[++d[x]]++;</span><br><span class="line">    cur[x] = head[x];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">isap</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    bfs(s, t);</span><br><span class="line">    ll ans = dfs(s, s, t, inf);</span><br><span class="line">    <span class="keyword">while</span> (d[s] &lt;= n) ans += dfs(s, s, t, inf);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//    Fastin;</span></span><br><span class="line">    clr(head, <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d %d %d"</span>, &amp;n, &amp;m, &amp;s, &amp;t);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, u, v, w; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line">        add(u, v, w);</span><br><span class="line">        add(v, u, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, isap(s, t));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>$O(n^2  m)$</p>
<h5 id="最高标号预流推进HLPP"><a href="#最高标号预流推进HLPP" class="headerlink" title="最高标号预流推进HLPP"></a>最高标号预流推进HLPP</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = INT_MAX;</span><br><span class="line"><span class="keyword">const</span> ll INF = (<span class="number">0x3f3f3f3f3f3f3f3f</span>ll);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1.2e3</span> + <span class="number">5</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HLPP</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> v, rev;</span><br><span class="line">        ll cap;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">int</span> n, sp, tp, lim, ht, lcnt;</span><br><span class="line">    ll exf[maxn];</span><br><span class="line">    <span class="built_in">vector</span>&lt;Edge&gt; G[maxn];</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; hq[maxn], gap[maxn], h, sum;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> nn, <span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        sp = s, tp = t, n = nn, lim = n + <span class="number">1</span>, ht = lcnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) G[i].clear(), exf[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, ll cap)</span> </span>&#123;</span><br><span class="line">        G[u].push_back(&#123; v, <span class="keyword">int</span>(G[v].size()), cap &#125;);</span><br><span class="line">        G[v].push_back(&#123; u, <span class="keyword">int</span>(G[u].size()) - <span class="number">1</span>, <span class="number">0</span> &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> nh)</span> </span>&#123;</span><br><span class="line">        ++lcnt;</span><br><span class="line">        <span class="keyword">if</span> (h[u] != lim)</span><br><span class="line">            --sum[h[u]];</span><br><span class="line">        h[u] = nh;</span><br><span class="line">        <span class="keyword">if</span> (nh == lim)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        ++sum[ht = nh];</span><br><span class="line">        gap[nh].push_back(u);</span><br><span class="line">        <span class="keyword">if</span> (exf[u] &gt; <span class="number">0</span>)</span><br><span class="line">            hq[nh].push_back(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">relabel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= lim; ++i) hq[i].clear(), gap[i].clear();</span><br><span class="line">        h.assign(lim, lim), sum.assign(lim, <span class="number">0</span>), q.push(tp);</span><br><span class="line">        lcnt = ht = h[tp] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> u = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">for</span> (Edge &amp;e : G[u])</span><br><span class="line">                <span class="keyword">if</span> (h[e.v] == lim &amp;&amp; G[e.v][e.rev].cap)</span><br><span class="line">                    update(e.v, h[u] + <span class="number">1</span>), q.push(e.v);</span><br><span class="line">            ht = h[u];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> u, Edge &amp;e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!exf[e.v])</span><br><span class="line">            hq[h[e.v]].push_back(e.v);</span><br><span class="line">        ll df = min(exf[u], e.cap);</span><br><span class="line">        e.cap -= df, G[e.v][e.rev].cap += df;</span><br><span class="line">        exf[u] -= df, exf[e.v] += df;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">discharge</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> nh = lim;</span><br><span class="line">        <span class="keyword">if</span> (h[u] == lim)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span> (Edge &amp;e : G[u]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!e.cap)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (h[u] == h[e.v] + <span class="number">1</span>) &#123;</span><br><span class="line">                push(u, e);</span><br><span class="line">                <span class="keyword">if</span> (exf[u] &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nh &gt; h[e.v] + <span class="number">1</span>)</span><br><span class="line">                nh = h[e.v] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sum[h[u]] &gt; <span class="number">1</span>)</span><br><span class="line">            update(u, nh);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (; ht &gt;= h[u]; gap[ht--].clear())</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> &amp;i : gap[ht]) update(i, lim);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ll <span class="title">hlpp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        exf[sp] = INF, exf[tp] = -INF, relabel();</span><br><span class="line">        <span class="keyword">for</span> (Edge &amp;e : G[sp]) push(sp, e);</span><br><span class="line">        <span class="keyword">for</span> (; ~ht; --ht) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!hq[ht].empty()) &#123;</span><br><span class="line">                <span class="keyword">int</span> u = hq[ht].back();</span><br><span class="line">                hq[ht].pop_back();</span><br><span class="line">                discharge(u);</span><br><span class="line">                <span class="keyword">if</span> (lcnt &gt; (n &lt;&lt; <span class="number">2</span>))</span><br><span class="line">                    relabel();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> exf[tp] + INF;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; hp;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>), <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> n, m, s, t, u, v, w;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; s &gt;&gt; t;</span><br><span class="line">    hp.init(n, s, t);</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        hp.add_edge(u, v, w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; hp.hlpp() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>loj127 </p>
<p>偷其板，不知其所以然。</p>
<p><del>甚至不知其然qaq</del></p>
<p>$O(n^2 \sqrt m)$</p>
<h4 id="费用流-dijstra"><a href="#费用流-dijstra" class="headerlink" title="费用流 (dijstra)"></a>费用流 (dijstra)</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ll inf = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">410</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxe = <span class="number">2e4</span> + <span class="number">10</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">star</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> from, to, next; ll c, w;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> head[maxn], top = <span class="number">0</span>;</span><br><span class="line">star edge[maxe &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c, <span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    edge[top].from = u;</span><br><span class="line">    edge[top].to = v;</span><br><span class="line">    edge[top].c = c;</span><br><span class="line">    edge[top].w = w;</span><br><span class="line">    edge[top].next = head[u];</span><br><span class="line">    head[u] = top++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll dis[maxn], h[maxn];</span><br><span class="line"><span class="keyword">int</span> pre[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NODE</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u; ll d;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> NODE &amp;b)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> d &gt; b.d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;NODE&gt; pq, pq0;</span><br><span class="line"><span class="function">ll <span class="title">mcmf</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t, ll f, ll &amp;flow)</span></span>&#123;</span><br><span class="line">    ll res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(f)&#123;</span><br><span class="line">        clr(dis, <span class="number">0x3f</span>); dis[s] = <span class="number">0</span>;</span><br><span class="line">        pq = pq0; pq.push(&#123;s, dis[s]&#125;);</span><br><span class="line">        <span class="keyword">while</span>(!pq.empty())&#123;</span><br><span class="line">            NODE temp = pq.top(); pq.pop();</span><br><span class="line">            <span class="keyword">int</span> u = temp.u; ll d = temp.d;</span><br><span class="line">            <span class="keyword">if</span>(dis[u] &lt; d) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; ~i; i = edge[i].next)&#123;</span><br><span class="line">                <span class="keyword">int</span> to = edge[i].to;</span><br><span class="line">                <span class="keyword">if</span>(edge[i].c &gt; <span class="number">0</span> &amp;&amp; dis[to] &gt; dis[u] + edge[i].w + h[u] - h[to])&#123;</span><br><span class="line">                    dis[to] = dis[u] + edge[i].w + h[u] - h[to];</span><br><span class="line">                    pre[to] = i;</span><br><span class="line">                    pq.push(&#123;to, dis[to]&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dis[t] == inf) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) h[i] += dis[i];</span><br><span class="line">        </span><br><span class="line">        ll d = f;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> now = t; now != s; now = edge[pre[now]].from) d = min(d, edge[pre[now]].c);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> now = t; now != s; now = edge[pre[now]].from)&#123;</span><br><span class="line">            edge[pre[now]].c -= d;</span><br><span class="line">            edge[pre[now] ^ <span class="number">1</span>].c += d;</span><br><span class="line">        &#125;</span><br><span class="line">        f -= d; flow += d; res += d * h[t];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//    Fastin;</span></span><br><span class="line">    clr(head, <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> u, v, c, w; <span class="built_in">scanf</span>(<span class="string">"%d %d %d %d"</span>, &amp;u, &amp;v, &amp;c, &amp;w);</span><br><span class="line">        add(u, v, c, w); add(v, u, <span class="number">0</span>, -w);</span><br><span class="line">    &#125;</span><br><span class="line">    ll flow = <span class="number">0</span>;</span><br><span class="line">    ll res = mcmf(<span class="number">1</span>, n, inf, flow);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld %lld\n"</span>, flow, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>loj102 单组数据最慢700ms左右</p>
<p>$V&lt;=400, E&lt;=15000$</p>
<p>时间复杂度$O(FElogV)$</p>
<h3 id="线段树优化建图"><a href="#线段树优化建图" class="headerlink" title="线段树优化建图"></a>线段树优化建图</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mid ((l + r) &gt;&gt; 1)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">5e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxe = <span class="number">4e7</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> M;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, p;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span><span class="keyword">int</span> to, next, w;&#125;edge[maxe];</span><br><span class="line"><span class="keyword">int</span> head[maxe], top = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    edge[top].to = v;</span><br><span class="line">    edge[top].w = w;</span><br><span class="line">    edge[top].next = head[u];</span><br><span class="line">    head[u] = top++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>, pos[maxn], ls[maxn &lt;&lt; <span class="number">3</span>], rs[maxn &lt;&lt; <span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> now = cnt++;</span><br><span class="line">    <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">        add(now, now + M, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> pos[l] = now;</span><br><span class="line">    &#125;</span><br><span class="line">    ls[now] = build(l, mid);</span><br><span class="line">    add(now, ls[now], <span class="number">0</span>); add(ls[now] + M, now + M, <span class="number">0</span>);</span><br><span class="line">    rs[now] = build(mid + <span class="number">1</span>, r);</span><br><span class="line">    add(now, rs[now], <span class="number">0</span>); add(rs[now] + M, now + M, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> now;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> u, <span class="keyword">int</span> type)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R)&#123;</span><br><span class="line">        <span class="keyword">if</span>(type) add(p + M, u, <span class="number">1</span>); <span class="keyword">else</span> add(u, p, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= mid) update(ls[p], l, mid, L, R, u, type);</span><br><span class="line">    <span class="keyword">if</span>(R &gt; mid) update(rs[p], mid + <span class="number">1</span>, r, L, R, u, type);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dis[<span class="number">5000000</span>];</span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    clr(dis, <span class="number">0x3f</span>);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty()) q.pop_back();</span><br><span class="line">    </span><br><span class="line">    dis[pos[p]] = <span class="number">0</span>; q.push_back(pos[p]);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> now = q.front(); q.pop_front();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = head[now]; ~i; i = edge[i].next)&#123;</span><br><span class="line">            <span class="keyword">int</span> to = edge[i].to; <span class="keyword">if</span>(dis[to] != <span class="number">0x3f3f3f3f</span>) <span class="keyword">continue</span>;</span><br><span class="line">            dis[to] = dis[now] + edge[i].w;</span><br><span class="line">            <span class="keyword">if</span>(edge[i].w) q.push_back(to);</span><br><span class="line">            <span class="keyword">else</span> q.push_front(to);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//    Fastin;</span></span><br><span class="line">    clr(head, <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;n, &amp;m, &amp;p);</span><br><span class="line">    M = n &lt;&lt; <span class="number">2</span>; build(<span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> a, b, c, d; <span class="built_in">scanf</span>(<span class="string">"%d %d %d %d"</span>, &amp;a, &amp;b, &amp;c, &amp;d);</span><br><span class="line">        <span class="comment">//加入虚点i + 2M与i + 1 + 2M;</span></span><br><span class="line">        update(<span class="number">0</span>, <span class="number">1</span>, n, a, b, <span class="number">2</span> * i + <span class="number">2</span> * M, <span class="number">1</span>); update(<span class="number">0</span>, <span class="number">1</span>, n, c, d, <span class="number">2</span> * i + <span class="number">2</span> * M, <span class="number">0</span>);</span><br><span class="line">        update(<span class="number">0</span>, <span class="number">1</span>, n, c, d, <span class="number">2</span> * i + <span class="number">2</span> * M + <span class="number">1</span>, <span class="number">1</span>); update(<span class="number">0</span>, <span class="number">1</span>, n, a, b, <span class="number">2</span> * i + <span class="number">2</span> * M + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    bfs();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dis[pos[i]]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>给出n个节点、m种边。</p>
<p>对于某一种边而言，有4个参数：a, b, c, d，表示对于所有的$a \leq x \leq b, c \leq y \leq d$都有一条无向边$<x, y>$相连。</p>
<p>询问对于某个指定点p而言，到其他所有点的最短距离</p>
<p>数据范围 $n \leq 5e5, m \leq 1e5$</p>
<h2 id="4-可持久化"><a href="#4-可持久化" class="headerlink" title="4 可持久化"></a>4 可持久化</h2><h3 id="可持久化01-Trie"><a href="#可持久化01-Trie" class="headerlink" title="可持久化01-Trie"></a>可持久化01-Trie</h3><p>最基本的版本如下，根据不同的题目可以添加不同的辅助数组。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">const</span> itn maxn = <span class="number">1e5</span> * N  +<span class="number">10</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TRIE</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> version = <span class="number">0</span>, top = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ch[maxn][<span class="number">2</span>], root[maxn];;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rot = root[version];</span><br><span class="line">        root[++version] = ++top;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = N - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">int</span> id = (x &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line">            ch[top][id] = top + <span class="number">1</span>; <span class="comment">//新建</span></span><br><span class="line">            ch[top][!id] = ch[rot][!id]; <span class="comment">//继承</span></span><br><span class="line">            top++; rot = ch[rot][id];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>多维护一个size数组记录当前节点下有多少个串，可用于在任意区间中查找区间中某个数异或上某个给定x的最大值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">24</span>;</span><br><span class="line"><span class="keyword">const</span> itn maxn = <span class="number">1e5</span>  +<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TRIE</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> version = <span class="number">0</span>, top = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ch[maxn][<span class="number">2</span>], root[maxn];;</span><br><span class="line">    <span class="keyword">int</span> size[maxn];</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rot = root[version];</span><br><span class="line">        root[++version] = ++top;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = N - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">int</span> id = (x &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line">            ch[top][id] = top + <span class="number">1</span>;</span><br><span class="line">            ch[top][!id] = ch[rot][!id];</span><br><span class="line">            size[top] = size[rot] + <span class="number">1</span>;</span><br><span class="line">            top++; rot = ch[rot][id];</span><br><span class="line">        &#125;</span><br><span class="line">        size[top] = size[rot] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  	<span class="comment">//查找[L + 1, R]的结果</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R, itn x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = root[L], r = root[R];</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = N - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">int</span> id = (x &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(size[ch[r][!id]] - size[ch[l][!id]] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                ans |= <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">                r = ch[r][!id]; l = ch[l][!id];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                r = ch[r][id];</span><br><span class="line">                l = ch[l][id];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="可持久化权值线段树-静态区间第k大查询"><a href="#可持久化权值线段树-静态区间第k大查询" class="headerlink" title="可持久化权值线段树 静态区间第k大查询"></a>可持久化权值线段树 静态区间第k大查询</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mid ((l + r) &gt;&gt; 1)</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn], c[maxn];</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line"><span class="keyword">int</span> ls[maxn &lt;&lt; N], rs[maxn &lt;&lt; N], root[maxn], num[maxn &lt;&lt; N], top = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = top++;</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span> p;</span><br><span class="line">    ls[p] = build(l, mid);</span><br><span class="line">    rs[p] = build(mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> now = top++;</span><br><span class="line">    ls[now] = ls[p]; rs[now] = rs[p]; num[now] = num[p] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span> now;</span><br><span class="line">    <span class="keyword">if</span>(k &lt;= mid) ls[now] = update(ls[p], l, mid, k);</span><br><span class="line">    <span class="keyword">else</span> rs[now] = update(rs[p], mid + <span class="number">1</span>, r, k);</span><br><span class="line">    <span class="keyword">return</span> now;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> r1, <span class="keyword">int</span> r2, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="comment">//[L + 1, R]</span></span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span> l;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> x = num[ls[r2]] - num[ls[r1]];</span><br><span class="line">    <span class="keyword">if</span>(k &lt;= x) <span class="keyword">return</span> query(ls[r1], ls[r2], l, mid, k);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> query(rs[r1], rs[r2], mid + <span class="number">1</span>, r, k - x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//    Fastin;</span></span><br><span class="line">    <span class="keyword">int</span> n, m; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, a + i);</span><br><span class="line">        c[i] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    sort(c + <span class="number">1</span>, c + <span class="number">1</span> + n);</span><br><span class="line">    <span class="keyword">int</span> N = (<span class="keyword">int</span>)(unique(c + <span class="number">1</span>, c + <span class="number">1</span> + n) - (c + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++) mp[c[i]] = i;</span><br><span class="line">    </span><br><span class="line">    root[<span class="number">0</span>] = build(<span class="number">1</span>, N);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        root[i] = update(root[i - <span class="number">1</span>], <span class="number">1</span>, N, mp[a[i]]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> l, r, k; <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;l, &amp;r, &amp;k);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, c[query(root[l - <span class="number">1</span>], root[r], <span class="number">1</span>, N, k)]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="BIT套权值线段树-带单点修改的区间第k大查询"><a href="#BIT套权值线段树-带单点修改的区间第k大查询" class="headerlink" title="BIT套权值线段树 带单点修改的区间第k大查询"></a>BIT套权值线段树 带单点修改的区间第k大查询</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">6e4</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, N;</span><br><span class="line"><span class="keyword">int</span> a[maxn], b[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NODE</span>&#123;</span><span class="keyword">int</span> type, x, y, z;&#125;;</span><br><span class="line">NODE node[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hsh</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> (<span class="keyword">int</span>)(lower_bound(b + <span class="number">1</span>, b + N, x) - b);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> s[maxn], rt[maxn], ls[maxn &lt;&lt; <span class="number">5</span>], rs[maxn &lt;&lt; <span class="number">5</span>], st[maxn &lt;&lt; <span class="number">5</span>], top = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> now = top++, mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span> now;</span><br><span class="line">    ls[now] = build(l, mid);</span><br><span class="line">    rs[now] = build(mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="keyword">return</span> now;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//旧版本的节点标号为p，拥有区间[l, r]；现要在k位置加入x，返回新节点的标号</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> now = top++;</span><br><span class="line">    ls[now] = ls[p]; rs[now] = rs[p]; st[now] = st[p] + x;</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span> now;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(k &lt;= mid) ls[now] = update(ls[p], l, mid, k, x);</span><br><span class="line">    <span class="keyword">else</span> rs[now] = update(rs[p], mid + <span class="number">1</span>, r, k, x);</span><br><span class="line">    <span class="keyword">return</span> now;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> use[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)&#123;</span><br><span class="line">        res += st[ls[use[x]]];</span><br><span class="line">        x -= lowbit(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当前在线段树的[l, r]位置上，左、右根节点分别为r1、r2，查询下标在(L, R]第k小的数字</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> r1, <span class="keyword">int</span> r2, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span> l;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> res = sum(R) - sum(L) + st[ls[r2]] - st[ls[r1]];</span><br><span class="line">    <span class="keyword">if</span>(k &lt;= res)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = L; i; i -= lowbit(i)) use[i] = ls[use[i]];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = R; i; i -= lowbit(i)) use[i] = ls[use[i]];</span><br><span class="line">        <span class="keyword">return</span> query(l, mid, ls[r1], ls[r2], L, R, k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = L; i; i -= lowbit(i)) use[i] = rs[use[i]];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = R; i; i -= lowbit(i)) use[i] = rs[use[i]];</span><br><span class="line">        <span class="keyword">return</span> query(mid + <span class="number">1</span>, r, rs[r1], rs[r2], L, R, k - res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> k, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= N)&#123;</span><br><span class="line">        s[i] = update(s[i], <span class="number">1</span>, N, k, x);</span><br><span class="line">        i += lowbit(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//    Fastin;</span></span><br><span class="line">    TTT&#123;</span><br><span class="line">        top = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;m);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, a + i);</span><br><span class="line">            b[i] = a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        N = n + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> op[<span class="number">2</span>]; <span class="built_in">scanf</span>(<span class="string">"%s"</span>, op);</span><br><span class="line">            <span class="keyword">int</span> x, y, z;</span><br><span class="line">            <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">'Q'</span>)&#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;x, &amp;y, &amp;z);</span><br><span class="line">                node[i] = &#123;<span class="number">0</span>, x, y, z&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;x, &amp;y);</span><br><span class="line">                node[i] = &#123;<span class="number">1</span>, x, y&#125;;</span><br><span class="line">                b[N++] = y;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(b + <span class="number">1</span>, b + N);</span><br><span class="line">        N = (<span class="keyword">int</span>)(unique(b + <span class="number">1</span>, b + N) - (b + <span class="number">1</span>));</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        rt[<span class="number">0</span>] = build(<span class="number">1</span>, N);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            rt[i] = update(rt[i - <span class="number">1</span>], <span class="number">1</span>, N, hsh(a[i]), <span class="number">1</span>);</span><br><span class="line">            s[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="comment">//修改node[i].x位置的值为node[i].y;</span></span><br><span class="line">            <span class="keyword">if</span>(node[i].type)&#123;</span><br><span class="line">                update(node[i].x, hsh(a[node[i].x]), <span class="number">-1</span>);</span><br><span class="line">                update(node[i].x, hsh(node[i].y), <span class="number">1</span>);</span><br><span class="line">                a[node[i].x] = node[i].y;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//查询[node[i].x, node[i].y]中第k小的值</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> l = node[i].x - <span class="number">1</span>, r = node[i].y;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = l; i; i -= lowbit(i)) use[i] = s[i];</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = r; i; i -= lowbit(i)) use[i] = s[i];</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, b[query(<span class="number">1</span>, N, rt[l], rt[r], l, r, node[i].z)]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://zoj.pintia.cn/problem-sets/91827364500/problems/91827365611" target="_blank" rel="noopener">ZOJ 2112</a></p>
<p>在rt[0]构建一个空线段树，构建两串权值线段树，L96-99构建原始版本的静态的、前缀的权值线段树；另一串构建$Δ$线段树，利用bit进行维护这一串线段树。更新时对log个线段树进行单点更新，总花费$O(log^2n)$；查询时一层一层进行查询：查询bit上log个线段树节点所有的左儿子，如果这一层差值的和与静态值之和小于等于k，就将bit上log个子树的节点标号向左儿子移动，递归地类似于普通第k大查询进行处理即可。</p>
<p><strong>实际使用时注意仔细研究一下数据范围！</strong></p>
<h2 id="5-树"><a href="#5-树" class="headerlink" title="5 树"></a>5 树</h2><h3 id="树链剖分"><a href="#树链剖分" class="headerlink" title="树链剖分"></a>树链剖分</h3><h4 id="求lca"><a href="#求lca" class="headerlink" title="求lca"></a>求lca</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">5e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, q, rot;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">star</span>&#123;</span><span class="keyword">int</span> from, to, next;&#125;;</span><br><span class="line"><span class="keyword">int</span> head[manx];</span><br><span class="line">star edge[maxn &lt;&lt; <span class="number">1</span>]; <span class="keyword">int</span> top = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(itn u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    edge[top].from = u;</span><br><span class="line">    edge[top].to = v;</span><br><span class="line">    edge[top].next = head[u];</span><br><span class="line">    head[u] = top++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//默认标号从1开始，给重儿子打上标记。</span></span><br><span class="line"><span class="keyword">int</span> son[maxn], par[maxn], sze[maxn], dep[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tag</span><span class="params">(<span class="keyword">int</span> now)</span></span>&#123;</span><br><span class="line">    sze[now] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[now]; ~i; i = edge[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> to = edge[i].to; <span class="keyword">if</span>(to == par[now]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        par[to] = now; dep[to] = dep[now] + <span class="number">1</span>;</span><br><span class="line">        tag(to); </span><br><span class="line">        sze[now] += sze[to];</span><br><span class="line">        <span class="keyword">if</span>(sze[to] &gt; sze[son[now]]) son[now] = to;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将该重链的起点作为dsu中一个联通块的根节点</span></span><br><span class="line"><span class="keyword">int</span> tp[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="comment">//存在儿子，即非叶子</span></span><br><span class="line">    tp[now] = t;</span><br><span class="line">    <span class="keyword">if</span>(son[now]) build(son[now], t);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[now]; ~i; i = edge[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> to = edge[i].to; <span class="keyword">if</span>(to == par[now] || to == son[now]) <span class="keyword">continue</span>;</span><br><span class="line">        build(to, to);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(tp[u] != tp[v])&#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[tp[u]] &gt; dep[tp[v]]) u = par[tp[u]];</span><br><span class="line">        <span class="keyword">else</span> v = par[tp[v]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dep[u] &lt; dep[v]? u: v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// Fastin;</span></span><br><span class="line"></span><br><span class="line">    clr(head, <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;n, &amp;q, &amp;rot);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> u, v; <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;u, &amp;v);</span><br><span class="line">        add(u, v); add(v, u);</span><br><span class="line">    &#125;</span><br><span class="line">    tag(rot); build(rot, rot);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; q; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> u, v; <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;u, &amp;v);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, lca(u, v));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>速度很快，应该是吊打st和倍增。</p>
<h4 id="支持路径修改-查询、子树修改查询"><a href="#支持路径修改-查询、子树修改查询" class="headerlink" title="支持路径修改/查询、子树修改查询"></a>支持路径修改/查询、子树修改查询</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, q, rot, M;</span><br><span class="line"><span class="keyword">int</span> w[maxn];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">star</span>&#123;</span><span class="keyword">int</span> from, to, next;&#125;;</span><br><span class="line"><span class="keyword">int</span> head[maxn];</span><br><span class="line">star edge[maxn &lt;&lt; <span class="number">1</span>]; <span class="keyword">int</span> top = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(itn u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    edge[top].from = u;</span><br><span class="line">    edge[top].to = v;</span><br><span class="line">    edge[top].next = head[u];</span><br><span class="line">    head[u] = top++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> son[maxn], par[maxn], sze[maxn], dep[maxn];</span><br><span class="line"><span class="comment">//默认标号从1开始，给重儿子打上标记。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getson</span><span class="params">(<span class="keyword">int</span> now)</span></span>&#123;</span><br><span class="line">    sze[now] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[now]; ~i; i = edge[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> to = edge[i].to; <span class="keyword">if</span>(to == par[now]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        par[to] = now; dep[to] = dep[now] + <span class="number">1</span>;</span><br><span class="line">        getson(to); </span><br><span class="line">        sze[now] += sze[to];</span><br><span class="line">        <span class="keyword">if</span>(sze[to] &gt; sze[son[now]]) son[now] = to;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> tp[maxn];</span><br><span class="line"><span class="comment">//将该重链的起点作为dsu中一个联通块的根节点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getlink</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="comment">//存在儿子，即非叶子</span></span><br><span class="line">    tp[now] = t;</span><br><span class="line">    <span class="keyword">if</span>(son[now]) getlink(son[now], t);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[now]; ~i; i = edge[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> to = edge[i].to; <span class="keyword">if</span>(to == par[now] || to == son[now]) <span class="keyword">continue</span>;</span><br><span class="line">        getlink(to, to);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//dfn为dfn序，pos为某个节点在dfn中的位置;</span></span><br><span class="line"><span class="keyword">int</span> r[maxn], pos[maxn], cnt = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> now)</span></span>&#123;</span><br><span class="line">    pos[now] = cnt; cnt++;</span><br><span class="line">    <span class="keyword">if</span>(son[now]) dfs(son[now]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[now]; ~i; i = edge[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> to = edge[i].to; <span class="keyword">if</span>(to == par[now] || to == son[now]) <span class="keyword">continue</span>;</span><br><span class="line">        dfs(to);</span><br><span class="line">    &#125;</span><br><span class="line">    r[now] = cnt - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls (p &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs ((p &lt;&lt; 1) | 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mid ((l + r) &gt;&gt; 1)</span></span><br><span class="line"><span class="comment">//在dfn上的修改&amp;查询,利用pos映射</span></span><br><span class="line">ll st[maxn &lt;&lt; <span class="number">2</span>], tag[maxn &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;st[p] = st[ls] + st[rs]; st[p] %= M;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tag[p])&#123;</span><br><span class="line">        tag[p] %= M;</span><br><span class="line">        tag[ls] += tag[p]; tag[rs] += tag[p];</span><br><span class="line">        tag[ls] %= M; tag[rs] %= M;</span><br><span class="line">        st[ls] += (mid - l + <span class="number">1</span>) * tag[p] % M; st[ls] %= M;</span><br><span class="line">        st[rs] += (r - mid) * tag[p]; st[rs] %= M;</span><br><span class="line">        tag[p] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    assert(L &lt;= R);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R)&#123;</span><br><span class="line">        st[p] += (r - l + <span class="number">1</span>) * x; st[p] %= M;</span><br><span class="line">        tag[p] += x; tag[p] %= M;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    down(p, l, r);</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= mid) update(ls, l, mid, L, R, x);</span><br><span class="line">    <span class="keyword">if</span>(R &gt; mid) update(rs, mid + <span class="number">1</span>, r, L, R, x);</span><br><span class="line">    up(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R) <span class="keyword">return</span> st[p];</span><br><span class="line">    down(p, l, r);</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= mid) ans += query(ls, l, mid, L, R); ans %= M;</span><br><span class="line">    <span class="keyword">if</span>(R &gt; mid) ans += query(rs, mid + <span class="number">1</span>, r, L, R);</span><br><span class="line">    <span class="keyword">return</span> ans % M;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updatepath</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(tp[u] != tp[v])&#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[tp[u]] &gt; dep[tp[v]])&#123;</span><br><span class="line">            <span class="comment">//u所在的重链更深</span></span><br><span class="line">            update(<span class="number">1</span>, <span class="number">0</span>, cnt - <span class="number">1</span>, pos[tp[u]], pos[u], x);</span><br><span class="line">            u = par[tp[u]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            update(<span class="number">1</span>, <span class="number">0</span>, cnt - <span class="number">1</span>, pos[tp[v]], pos[v], x);</span><br><span class="line">            v = par[tp[v]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dep[u] &gt; dep[v]) swap(u, v);</span><br><span class="line">    udpate(<span class="number">1</span>, <span class="number">0</span>, cnt - <span class="number">1</span>, pos[u], pos[v], x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">pathquery</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(tp[u] != tp[v])&#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[tp[u]] &gt; dep[tp[v]])&#123;</span><br><span class="line">            ans += query(<span class="number">1</span>, <span class="number">0</span>, cnt - <span class="number">1</span>, pos[tp[u]], pos[u]);</span><br><span class="line">            ans %= M;</span><br><span class="line">            u = par[tp[u]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            ans += query(<span class="number">1</span>, <span class="number">0</span>, cnt - <span class="number">1</span>, pos[tp[v]], pos[v]);</span><br><span class="line">            ans %= M;</span><br><span class="line">            v = par[tp[v]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dep[u] &gt; dep[v]) swap(u, v);</span><br><span class="line">    ans += query(<span class="number">1</span>, <span class="number">0</span>, cnt - <span class="number">1</span>, pos[u], pos[v]);</span><br><span class="line">    ans %= M;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// Fastin;</span></span><br><span class="line">    clr(head, <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d %d %d"</span>, &amp;n, &amp;q, &amp;rot, &amp;M);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, w + i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> u, v; scnaf(<span class="string">"%d %d"</span>, &amp;u, &amp;v);</span><br><span class="line">        add(u, v); add(v, u);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    getson(rot); getlink(rot, rot); dfs(rot); </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) update(<span class="number">1</span>, <span class="number">0</span>, cnt - <span class="number">1</span>, pos[i], pos[i], w[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; q; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> op; scnaf(<span class="string">"%d"</span>, &amp;op);</span><br><span class="line">        <span class="keyword">int</span> x, y, z; </span><br><span class="line">        <span class="keyword">if</span>(op == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;x, &amp;y, &amp;z);</span><br><span class="line">            updatepath(x, y, z);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;x, &amp;y); <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, pathquery(x, y) % M);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="number">3</span>)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;x, &amp;y); udpate(<span class="number">1</span>, <span class="number">0</span>, cnt - <span class="number">1</span>, pos[x], r[x], y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x); <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, query(<span class="number">1</span>, <span class="number">0</span>, cnt - <span class="number">1</span>, pos[x], r[x]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了充分利用重链和dfn序，在dfs时优先遍历重链，这样即可保证重链上的节点在dfn序列上连续。</p>
<p>修改路径时只需要参考前述求lca的跳点规则，一段段地在线段树上进行区间修改可。</p>
<p>而修改路径更为简单，只需要记录一下子树在dfn序列上的辖域即可。</p>
<h3 id="点分治"><a href="#点分治" class="headerlink" title="点分治"></a>点分治</h3><h4 id="计数树上两点之间路径长度为k的对数（开桶加速-多组查询）"><a href="#计数树上两点之间路径长度为k的对数（开桶加速-多组查询）" class="headerlink" title="计数树上两点之间路径长度为k的对数（开桶加速 多组查询）"></a>计数树上两点之间路径长度为k的对数（开桶加速 多组查询）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e4</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">star</span>&#123;</span><span class="keyword">int</span> to, next, w;&#125;;</span><br><span class="line"><span class="keyword">int</span> head[maxn], top = <span class="number">0</span>;</span><br><span class="line">star edge[maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    edge[top].to = v;</span><br><span class="line">    edge[top].next = head[u];</span><br><span class="line">    edge[top].w = w;</span><br><span class="line">    head[u] = top++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用getroot前应该初始化S！！！</span></span><br><span class="line"><span class="keyword">int</span> root = <span class="number">0</span>, S;</span><br><span class="line"><span class="keyword">int</span> vis[maxn], sze[maxn], mx[maxn];;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getroot</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> par)</span></span>&#123;</span><br><span class="line">    sze[u] = <span class="number">1</span>; mx[u] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = haed[u]; ~i; i = edge[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> to = edge[i].to; <span class="keyword">if</span>(vis[to] || to == par) <span class="keyword">continue</span>;</span><br><span class="line">        getroot(to, u);</span><br><span class="line">        sze[u] += sze[to];</span><br><span class="line">        mx[u] = max(mx[u], sze[to]);</span><br><span class="line">    &#125;</span><br><span class="line">    mx[u] = max(mx[u], S - sze[u]);</span><br><span class="line">    <span class="keyword">if</span>(mx[u] &lt; mx[root]) root = u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dis;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> par, <span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(d &gt; <span class="number">10000000</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; ~i; i = edge[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> to = edge[i].to; <span class="keyword">if</span>(vis[to] || to == par) <span class="keyword">continue</span>;</span><br><span class="line">        dis.push_back(d + edge[i].w);</span><br><span class="line">        dfs(to, u, d + edge[i].w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> tong[<span class="number">10000010</span>];</span><br><span class="line"><span class="keyword">int</span> k[maxn], ans[maxn];</span><br><span class="line"><span class="comment">//获取经过u的答案，路径长度有基础偏移值d</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> d, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    dis.clear(); dis.push_back(d); dfs(u, <span class="number">0</span>, d);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>)dis.size(); i++) <span class="keyword">if</span>(dis[i] &lt;= <span class="number">10000000</span>) tong[dis[i]]++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>)dis.size(); i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dis[i] + dis[i] &lt; k[j]) ans[j] += (tong[k[j] - dis[i]]) * x;</span><br><span class="line">            <span class="keyword">if</span>(dis[i] + dis[i] == k[j]) ans[j] += (tong[dis[i]] - <span class="number">1</span>) * x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>)dis.size(); i++) <span class="keyword">if</span>(dis[i] &lt;= <span class="number">10000000</span>) tong[dis[i]]--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//u是重心，考察以经过u的路径长度</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sove</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="comment">//封锁u节点，分治地寻找子树.</span></span><br><span class="line">    vis[u] = <span class="number">1</span>; fun(u, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; ~i; i = edge[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> to = edge[i].to; <span class="keyword">if</span>(vis[to]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">//删去那些根本不经过u的点对</span></span><br><span class="line">        fun(to, edge[i].w, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        S = sze[to]; root = <span class="number">0</span>;</span><br><span class="line">        getroot(to, u);</span><br><span class="line">        sove(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//    Fastin;</span></span><br><span class="line">    clr(head, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> u, v, w; <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line">        add(u, v, w); add(v, u, w);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, k + i);</span><br><span class="line"></span><br><span class="line">    mx[<span class="number">0</span>] = n; root = <span class="number">0</span>;</span><br><span class="line">    S = n; clr(vis, <span class="number">0</span>);</span><br><span class="line">    getroot(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    sove(root);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) <span class="built_in">puts</span>(ans[i]? <span class="string">"AYE"</span>: <span class="string">"NAY"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度$O(nlogn)$</p>
<ul>
<li>实际使用桶加速时需要根据题意修改桶的大小。</li>
<li>main函数中对于mx[0]的初始化必不可少</li>
<li>每次调用getroot前都应对S(当前子树总大小)进行初始化。</li>
<li>如果<strong>权值过大不能开桶</strong>，可以通过二分查找等方式多一个$log$地进行查询计数</li>
<li>找重心时S的更新应该这样才对？（不懂.gif</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(sze[to] &lt; sze[u]) S = sze[to];</span><br><span class="line"><span class="keyword">else</span> S = sze[to] - sze[u];</span><br></pre></td></tr></table></figure>
<h3 id="点分树"><a href="#点分树" class="headerlink" title="点分树"></a>点分树</h3><h4 id="多组查询与某点距离小于等于k的所有点权和-并支持单点修改"><a href="#多组查询与某点距离小于等于k的所有点权和-并支持单点修改" class="headerlink" title="多组查询与某点距离小于等于k的所有点权和 并支持单点修改"></a>多组查询与某点距离小于等于k的所有点权和 并支持单点修改</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mid ((l + r) &gt;&gt; 1)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> manx = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="comment">//根据dfn数组的长度决定N(即N = log2(cnt), cnt = maxn &lt;&lt; 1)</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, q;</span><br><span class="line"><span class="keyword">int</span> w[manx];</span><br><span class="line"><span class="comment">//动态开点的单点修改、区间求和线段树</span></span><br><span class="line"><span class="comment">//维护两个st，一个是u子树对u的贡献，另一个是u子树对par[u]的贡献（如果有的话）</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = maxn * N * <span class="number">4</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SEG</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> root[maxn];</span><br><span class="line">    <span class="keyword">int</span> st[M], ls[M], rs[M], top = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> now = top++;</span><br><span class="line">        <span class="keyword">if</span>(l == r) <span class="keyword">return</span> now;</span><br><span class="line">        ls[now] = build(l, mid);</span><br><span class="line">        rs[now] = build(mid + <span class="number">1</span>, r);</span><br><span class="line">        <span class="keyword">return</span> now;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;st[p] = st[ls[p]] + st[rs[p]];&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        assert(k &gt;= l &amp;&amp; k &lt;= r);</span><br><span class="line">        <span class="keyword">if</span>(l == r &amp;&amp; l == k)&#123;</span><br><span class="line">            st[p] += x;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(k &lt;= mid) add(ls[p], l, mid, k, x);</span><br><span class="line">        <span class="keyword">else</span> add(rs[p], mid + <span class="number">1</span>, r, k, x);</span><br><span class="line">        up(p);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(R &lt; L) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R) <span class="keyword">return</span> st[p];</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(L &lt;= mid) ans += query(ls[p], l, mid, L, R);</span><br><span class="line">        <span class="keyword">if</span>(R &gt; mid) ans += query(rs[p], mid + <span class="number">1</span>, r, L, R);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;seg[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; E;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TREE</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> head[maxn], par[manx], top = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">star</span>&#123;</span><span class="keyword">int</span> to, next;&#125;;</span><br><span class="line">    star edge[maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    TREE()&#123;clr(head, <span class="number">-1</span>); top = <span class="number">0</span>;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">        edge[top].to = v;</span><br><span class="line">        edge[top].next = head[u];</span><br><span class="line">        head[u] = top++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; &amp;E)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> e: E)&#123;</span><br><span class="line">            add(e.first, e.second);</span><br><span class="line">            par[e.second] = e.first;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mx[maxn], sze[maxn], vis[maxn], root = <span class="number">0</span>, S;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getroot</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> par)</span></span>&#123;</span><br><span class="line">        sze[now] = <span class="number">1</span>; mx[now] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = head[now]; ~i; i = edge[i].next)&#123;</span><br><span class="line">            <span class="keyword">int</span> to = edge[i].to; <span class="keyword">if</span>(to == par || vis[to]) <span class="keyword">continue</span>;</span><br><span class="line">            getroot(to, now);</span><br><span class="line">            sze[now] += sze[to];</span><br><span class="line">            mx[now] = max(mx[now], sze[to]);</span><br><span class="line">        &#125;</span><br><span class="line">        mx[now] = max(mx[now], S - sze[now]);</span><br><span class="line">        <span class="keyword">if</span>(mx[root] &gt; mx[now]) root = now;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当前分治中心为now，封锁住通往par的路径，函数返回重心</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> par)</span></span>&#123;</span><br><span class="line">        root = <span class="number">0</span>; getroot(now, par);</span><br><span class="line">        <span class="keyword">int</span> rt = root; vis[rt] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = head[rt]; ~i; i = edge[i].next)&#123;</span><br><span class="line">            <span class="keyword">int</span> to = edge[i].to; <span class="keyword">if</span>(to == par || vis[to]) <span class="keyword">continue</span>;</span><br><span class="line">            S = sze[to];</span><br><span class="line">            E.push_back(&#123;rt, divide(to, rt)&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将树重构为点分树，点分数的边存放在E中，供tree[1].add调用；返回重构树的根</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rebuild</span><span class="params">()</span></span>&#123;</span><br><span class="line">        S = mx[<span class="number">0</span>] = n;</span><br><span class="line">        <span class="keyword">return</span> divide(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//初始化dfn、pos数组，得到每个节点的深度dep</span></span><br><span class="line">    <span class="keyword">int</span> dfn[maxn &lt;&lt; <span class="number">1</span>], pos[manx], cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> dep[maxn];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> par)</span></span>&#123;</span><br><span class="line">        dfn[cnt] = now; pos[now] = cnt; cnt++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = head[now]; ~i; i = edge[i].next)&#123;</span><br><span class="line">            <span class="keyword">int</span> to = edge[i].to; <span class="keyword">if</span>(to == par) <span class="keyword">continue</span>;</span><br><span class="line">            dep[to] = dep[now] + <span class="number">1</span>;</span><br><span class="line">            dfs(to, now);</span><br><span class="line">            dfn[cnt++] = now;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> st[maxn &lt;&lt; <span class="number">1</span>][N];</span><br><span class="line">    <span class="comment">//通过深度数组获取st表, st维护区间中深度最小的节点标号</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getst</span><span class="params">()</span></span>&#123;</span><br><span class="line">        dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt; i++) st[i][<span class="number">0</span>] = dfn[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; N; j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt; i++)&#123;</span><br><span class="line">                <span class="keyword">int</span> nxt = i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>));</span><br><span class="line">                <span class="keyword">if</span>(nxt &gt;= cnt) st[i][j] = st[i][j - <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(dep[st[i][j - <span class="number">1</span>]] &lt; dep[st[nxt][j - <span class="number">1</span>]]) st[i][j] = st[i][j - <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">else</span> st[i][j] = st[nxt][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//O1获取两点之间的距离</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getdis</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == y) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> l = min(pos[x], pos[y]), r = max(pos[x], pos[y]);</span><br><span class="line">        <span class="keyword">int</span> k = (<span class="keyword">int</span>)(log2(r - l) + eps);</span><br><span class="line">        <span class="keyword">int</span> lca = st[l][k];</span><br><span class="line">        <span class="keyword">if</span>(dep[lca] &gt; dep[st[r - (<span class="number">1</span> &lt;&lt; k) + <span class="number">1</span>][k]]) lca = st[r - (<span class="number">1</span> &lt;&lt; k) + <span class="number">1</span>][k];</span><br><span class="line">        <span class="keyword">return</span> dep[x] + dep[y] - <span class="number">2</span> * dep[lca];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取子树大小并初始化线段树</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ini</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> par)</span></span>&#123;</span><br><span class="line">        sze[now] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = head[now]; ~i; i = edge[i].next)&#123;</span><br><span class="line">            <span class="keyword">int</span> to = edge[i].to; <span class="keyword">if</span>(to == par) <span class="keyword">continue</span>;</span><br><span class="line">            ini(to, now);</span><br><span class="line">            sze[now] += sze[to];</span><br><span class="line">        &#125;</span><br><span class="line">        seg[<span class="number">0</span>].root[now] = seg[<span class="number">0</span>].build(<span class="number">0</span>, sze[now]);</span><br><span class="line">        seg[<span class="number">1</span>].root[now] = seg[<span class="number">1</span>].build(<span class="number">0</span>, sze[now] + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;tree[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//第k个城市上发生x的增量，当前处理到now节点，保证now节点一定是k的祖先</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> k, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dis = tree[<span class="number">0</span>].getdis(now, k);</span><br><span class="line">    seg[<span class="number">0</span>].add(seg[<span class="number">0</span>].root[now], <span class="number">0</span>, tree[<span class="number">1</span>].sze[now], dis, x);</span><br><span class="line">    <span class="keyword">if</span>(tree[<span class="number">1</span>].par[now])&#123;</span><br><span class="line">        dis = tree[<span class="number">0</span>].getdis(tree[<span class="number">1</span>].par[now], k);</span><br><span class="line">        seg[<span class="number">1</span>].add(seg[<span class="number">1</span>].root[now], <span class="number">0</span>, tree[<span class="number">1</span>].sze[now] + <span class="number">1</span>, dis, x);</span><br><span class="line">        add(tree[<span class="number">1</span>].par[now], k, x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查询距离k城市距离小于等于x的价值和，当前处理到now</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> k, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> d = tree[<span class="number">0</span>].getdis(now, k);</span><br><span class="line">    ans += seg[<span class="number">0</span>].query(seg[<span class="number">0</span>].root[now], <span class="number">0</span>, tree[<span class="number">1</span>].sze[now], <span class="number">0</span>, x - d);</span><br><span class="line">    <span class="keyword">if</span>(tree[<span class="number">1</span>].par[now])&#123;</span><br><span class="line">        <span class="keyword">int</span> D = tree[<span class="number">0</span>].getdis(tree[<span class="number">1</span>].par[now], k);</span><br><span class="line">        ans -= seg[<span class="number">1</span>].query(seg[<span class="number">1</span>].root[now], <span class="number">0</span>, tree[<span class="number">1</span>].sze[now] + <span class="number">1</span>, <span class="number">0</span>, x - D);</span><br><span class="line">        ans += query(tree[<span class="number">1</span>].par[now], k, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//     Fastin;</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, w + i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> u, v; scnaf(<span class="string">"%d %d"</span>, &amp;u, &amp;v);</span><br><span class="line">        tree[<span class="number">0</span>].add(u, v); tree[<span class="number">0</span>].add(v, u);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    tree[<span class="number">0</span>].getst();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> root = tree[<span class="number">0</span>].rebuild();</span><br><span class="line">    tree[<span class="number">1</span>].add(E);</span><br><span class="line"></span><br><span class="line">    tree[<span class="number">1</span>].ini(root, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) add(i, i, w[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    whlie(q--)&#123;</span><br><span class="line">        <span class="keyword">int</span> op, x, y; <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;op, &amp;x, &amp;y);</span><br><span class="line">	      <span class="comment">//强制在线</span></span><br><span class="line">        x ^= ans; y ^= ans;</span><br><span class="line">        <span class="keyword">if</span>(op)&#123;</span><br><span class="line">            add(x, x, y - w[x]);</span><br><span class="line">            w[x] = y;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans = query(x, x, y));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>主要数据结构<ul>
<li>tree[0]: 原树<ul>
<li>利用mx[maxn]、sze[maxn]、vis[maxn]、root、S对树进行重构，将重构结果的边暂时保存在vector<pair<int, int>&gt; E中，等待之后存放到tree[1]中</li>
<li>利用dfn[maxn &lt;&lt; 1]、pos[maxn]、cnt、dep[maxn]、st[maxn &lt;&lt; 1][N]建立st表，提供接口getdis进行O1查询距离。<strong>ST表的大小应当与dfn相同！同时注意建立ST表时边界越界的问题！</strong></li>
</ul>
</li>
<li>tree[1]: 原树重构后得到的点分树<ul>
<li>利用ini()函数获取点分树上所有子树的大小，将该大小作为线段树的边界，同时完成动态开点的线段树的初始化。</li>
</ul>
</li>
<li>seg[0]: 动态开点的权值线段树(单点修改、区间查询)<ul>
<li>通过seg[0].root数组作为tree[1]中每个节点的入口</li>
<li>对于某个节点u而言，权值线段树的值域区间为[0, tree[1].sze[u]]，存储的内容为tree[1]中u节点所有孩子对u的贡献</li>
<li>需要的空间为n <em> logn </em> 4</li>
</ul>
</li>
<li>seg[1]: 动态开点的权值线段树(单点修改、区间查询)<ul>
<li>通过seg[1].root数组作为tree[1]中每个节点的入口</li>
<li>对于某个节点u而言，权值线段树的值域区间为[0, tree[1].sze[u] + 1] (<code>+1</code>是必要的)，存储的内容为tree[1]中u节点所有孩子对<strong>par[u]</strong>（如果存在的话）的贡献</li>
<li>需要的空间为n <em> logn </em> 4</li>
</ul>
</li>
</ul>
</li>
<li>使用指南<ul>
<li>读入原树到tree[0]后，调用tree[0].getst()初始化st表</li>
<li>调用tree[0].rebuild()重构原树，新树的边存放在E中，再开变量root存放函数的返回值(即新树的根)</li>
<li>调用tree[1].add(E)将E中的有向边加入到tree[1]中</li>
<li>调用tree[1].ini(root)从新树的根开始，完成新树上套线段树的建立</li>
<li>调用add函数将原树的所有点权加入到线段树中，完成线段树的初始化</li>
<li>读入q次查询，根据查询的类型调用add/query进行操作即可。</li>
</ul>
</li>
</ul>
<h3 id="pruefer序列"><a href="#pruefer序列" class="headerlink" title="pruefer序列"></a>pruefer序列</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">5e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> par[maxn], prufer[maxn], du[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">encode</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ptr = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">if</span>(ptr == <span class="number">-1</span> &amp;&amp; du[i] == <span class="number">1</span>) ptr = i;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> leaf = ptr;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">2</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> next = prufer[i] = par[leaf];</span><br><span class="line">        <span class="keyword">if</span>(--du[next] == <span class="number">1</span> &amp;&amp; next &lt; ptr) leaf = next;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            ptr++;</span><br><span class="line">            <span class="keyword">while</span>(du[ptr] != <span class="number">1</span>) ptr++;</span><br><span class="line">            leaf = ptr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rebuild</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ptr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(du[ptr] != <span class="number">1</span>) ptr++;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> leaf = ptr;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">2</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> next = par[leaf] = prufer[i];</span><br><span class="line">        <span class="keyword">if</span>(--du[next] == <span class="number">1</span> &amp;&amp; next &lt; ptr) leaf = next;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            ptr++;</span><br><span class="line">            <span class="keyword">while</span>(du[ptr] != <span class="number">1</span>) ptr++;</span><br><span class="line">            leaf = ptr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    par[leaf] = n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hsh</span><span class="params">(<span class="keyword">int</span> a[maxn], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) ans ^= (i + <span class="number">1</span>) * <span class="number">1l</span>l * a[i];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//    Fastin;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> op;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;op);</span><br><span class="line">    <span class="keyword">if</span>(op == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, par + i);</span><br><span class="line">            du[par[i]]++; du[i]++;</span><br><span class="line">        &#125;</span><br><span class="line">        encode();</span><br><span class="line">        hsh(prufer, n - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) du[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">2</span>; i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, prufer + i);</span><br><span class="line">            du[prufer[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        rebuild();</span><br><span class="line">        hsh(par + <span class="number">1</span>, n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用指南</p>
<ul>
<li>读入点数n和操作数op</li>
<li>op = 1 读入节点$[1, …,n-1]$的父亲，调用encode后将prufer序列保存在$prufer[0, n - 2)$中</li>
<li>op = 2 读入长为n-2的prufer序列，调用rebuild后将节点$[1, …, n -1]$的父亲存储在$par[1, .. n -1]$中</li>
</ul>
<p>TIPS</p>
<ul>
<li>因为prufer序列构造的特性，节点n一定是留到最后的那个节点，所以程序中读入/输出的par序列均是以n节点为根时的父子关系。</li>
</ul>
<h4 id="计数相关定理"><a href="#计数相关定理" class="headerlink" title="计数相关定理"></a>计数相关定理</h4><h5 id="凯莱公式"><a href="#凯莱公式" class="headerlink" title="凯莱公式"></a>凯莱公式</h5><p>完全图$K_n$有$n^{n-2}$棵生成树。</p>
<p>证明显然。</p>
<h5 id="图联通方案数"><a href="#图联通方案数" class="headerlink" title="图联通方案数"></a>图联通方案数</h5><p>一个n节点的带标号无向图有k个联通块。添加k-1条边使得图联通的方案数为$n^{k-2} * \prod s_i$.</p>
<p>证明：</p>
<p>尝试对k个联通块构造prufer序列。</p>
<p>由于每个联通块的度未知，因而设$d_i$为联通块i的度。$d_i$满足$\sum d_i = 2(k-1)$</p>
<p>则对于给定d序列后构造prufer序列的方案数为$(^{\space \space \space \space \space \space \space \space k-2}_{(d_1-1)!…(d_k-1)!})$</p>
<p>而对于某个联通块$s_i$而言，其连接方式为$s_i^{d_i}$种，因而对于给定d序列后图联通的方案数是$(^{\space \space \space \space \space \space \space \space k-2}_{(d_1-1)!…(d_k-1)!})*s_i^{d_i}$</p>
<p>接下来枚举d序列，即$\sum_{d_i≥1,\sum d_i=2k-2}(^{\space \space \space \space \space \space \space \space k-2}_{(d_1-1)!…(d_k-1)!})*\prod _{1 \leq i \leq k}s_i^{d_i}$</p>
<p>利用多元二项式定理: $(x_1+…+x_m)^p=\sum_{c_i≥0, \sum c_i=p}(^{\space \space \space \space p}_{c_1, …, c_m}) * \prod x_i^{c_i}$, 并换元$e_i=d_i-1$。$\sum e_i=k-2$</p>
<p>则原式成为$\sum _{e_i≥0, \sum e_i = k-2} (^{\space \space k-2}_{e_1, …, e_k})*\prod s_i^{e_i+1}$</p>
<p>化简得$(s_1+…+s_k)^{k-2} * \prod s_i$</p>
<p>即$n^{k-2} * \prod s_i$</p>
<h2 id="6-数学"><a href="#6-数学" class="headerlink" title="6 数学"></a>6 数学</h2><h3 id="异或线性基"><a href="#异或线性基" class="headerlink" title="异或线性基"></a>异或线性基</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">200</span> + <span class="number">10</span>;</span><br><span class="line">ll a[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> L = <span class="number">63</span>;</span><br><span class="line">ll d[L];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">add</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = L - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) <span class="keyword">if</span>(x &amp; <span class="number">1l</span>l &lt;&lt; i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(d[i] == <span class="number">-1</span>)&#123;d[i] = x; <span class="keyword">return</span> <span class="literal">true</span>;&#125;</span><br><span class="line">        x ^= d[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//    Fast;</span></span><br><span class="line">    <span class="keyword">int</span> t; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t); <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(d, <span class="number">-1</span>, <span class="keyword">sizeof</span> d);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, a + i);</span><br><span class="line">        <span class="keyword">char</span> s[maxn]; <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s);</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(add(a[i]) &amp;&amp; s[i] == <span class="string">'1'</span>)&#123;</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, flag);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="多项式"><a href="#多项式" class="headerlink" title="多项式"></a>多项式</h3><h4 id="FTT"><a href="#FTT" class="headerlink" title="FTT"></a>FTT</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">COM</span>&#123;</span></span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line">    COM <span class="keyword">operator</span> *(<span class="keyword">const</span> COM &amp;b)&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;x * b.x - y * b.y, x * b.y + y * b.x&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    COM <span class="keyword">operator</span> -(<span class="keyword">const</span> COM &amp;b)&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;x - b.x, y - b.y&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    COM <span class="keyword">operator</span> +(<span class="keyword">const</span> COM &amp;b)&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;x + b.x, y + b.y&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, sum, N, wei;</span><br><span class="line">COM a[maxn &lt;&lt; <span class="number">2</span>], b[maxn &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> inv[maxn &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//将0到N-1的多项式表示转化为点值表示</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fft</span><span class="params">(COM *a, <span class="keyword">int</span> op)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) <span class="keyword">if</span>(i &lt; inv[i]) swap(a[inv[i]], a[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//逆fft将范德蒙德行列式的每一项取共轭再除以n</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = wei - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="keyword">int</span> d = <span class="number">1</span> &lt;&lt; (wei - i);</span><br><span class="line">        COM wn = &#123;<span class="built_in">cos</span>(<span class="number">2</span> * pi / d), op * <span class="built_in">sin</span>(<span class="number">2</span> * pi / d)&#125;;</span><br><span class="line">        <span class="comment">//j遍历第i层的开头</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j += d)&#123;</span><br><span class="line">            <span class="comment">//对j开头的一小段进行更新</span></span><br><span class="line">            COM w = &#123;<span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; d / <span class="number">2</span>; k++)&#123;</span><br><span class="line">                COM x, y;</span><br><span class="line">                x = a[j + k]; y = a[j + k + d / <span class="number">2</span>] * w;</span><br><span class="line">                a[j + k] = x + y; a[j + k + d / <span class="number">2</span>] = x - y;</span><br><span class="line">                w = w * wn;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//#define LOCAL</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%lf"</span>, &amp;a[i].x);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; i++) <span class="built_in">scanf</span>(<span class="string">"%lf"</span>, &amp;b[i].x);</span><br><span class="line">    </span><br><span class="line">    sum = n + m + <span class="number">1</span>; N = <span class="number">1</span>; wei = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(N &lt; sum)&#123;N *= <span class="number">2</span>; wei++;&#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">1</span> &lt;&lt; wei; j++)</span><br><span class="line">        inv[j] = inv[j &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span> | (j &amp; <span class="number">1</span>) &lt;&lt; (wei - <span class="number">1</span>);</span><br><span class="line">    fft(a, <span class="number">1</span>); fft(b, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) a[i] = a[i] * b[i];</span><br><span class="line">    fft(a, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n + m + <span class="number">1</span>; i++) <span class="built_in">printf</span>(<span class="string">"%d "</span>, (<span class="keyword">int</span>)(a[i].x / N + <span class="number">0.5</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输入n、m，接n+1和m+1个整数，分别表示n次多项式和m次多项式从低到高的系数。</p>
<p>输出n+m+1个系数。</p>
<h4 id="NTT"><a href="#NTT" class="headerlink" title="NTT"></a>NTT</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> p = <span class="number">3</span>, invp = <span class="number">332748118</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, sum, N, wei;</span><br><span class="line">ll a[maxn &lt;&lt; <span class="number">2</span>], b[maxn &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> inv[maxn &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quick_pow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    ll ans = <span class="number">1</span>, res = a;</span><br><span class="line">    <span class="keyword">while</span>(p)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p &amp; <span class="number">1</span>) ans *= res; ans %= M;</span><br><span class="line">        res *= res; res %= M;</span><br><span class="line">        p &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans % M;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//逆fft将范德蒙德行列式的每一项取共轭再除以n</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fft</span><span class="params">(ll *a, <span class="keyword">int</span> op)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) <span class="keyword">if</span>(i &lt; inv[i]) swap(a[inv[i]], a[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = wei - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="keyword">int</span> d = <span class="number">1</span> &lt;&lt; (wei - i);</span><br><span class="line">        ll gn = quick_pow(op == <span class="number">1</span>? p: invp, (M - <span class="number">1</span>) / d);</span><br><span class="line">        <span class="comment">//j遍历第i层的开头</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j += d)&#123;</span><br><span class="line">            <span class="comment">//对j开头的小段进行更新</span></span><br><span class="line">            ll g = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; d / <span class="number">2</span>; k++)&#123;</span><br><span class="line">                ll x, y;</span><br><span class="line">                x = a[j + k] % M;</span><br><span class="line">                y = a[j + k + d / <span class="number">2</span>] * g; y %= M;</span><br><span class="line">                a[j + k] = (x + y) % M; a[j + k + d / <span class="number">2</span>] = (x - y + M) % M;</span><br><span class="line">                g = g * gn; g %= M;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//#define LOCAL</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n,  &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, a + i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; i++) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, b + i);</span><br><span class="line"></span><br><span class="line">    sum = n + m + <span class="number">1</span>; N = <span class="number">1</span>; wei = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(N &lt; sum)&#123;N *= <span class="number">2</span>; wei++;&#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">1</span> &lt;&lt; wei; j++)</span><br><span class="line">        inv[j] = inv[j &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span> | (j &amp; <span class="number">1</span>) &lt;&lt; (wei - <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    fft(a, <span class="number">1</span>); fft(b, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) a[i] = (a[i] * b[i]) % M;</span><br><span class="line">    fft(a, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">int</span> invn = quick_pow(N, M - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n + m + <span class="number">1</span>; i++) <span class="built_in">printf</span>(<span class="string">"%lld "</span>, (a[i] * invn + M) % M);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输入n、m，接n+1和m+1个整数，分别表示n次多项式和m次多项式从低到高的系数。</p>
<p>输出n+m+1个系数。</p>
<h3 id="高斯整数"><a href="#高斯整数" class="headerlink" title="高斯整数"></a>高斯整数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">GaussianInteger</span>&#123;</span></span><br><span class="line">    ll x, y;</span><br><span class="line">    <span class="function">ll <span class="title">norm</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> x * x + y * y;&#125;</span><br><span class="line">    GaussianInteger <span class="keyword">operator</span> + (<span class="keyword">const</span> GaussianInteger &amp;b)&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;x + b.x, y + b.y&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    GaussianInteger <span class="keyword">operator</span> - (<span class="keyword">const</span> GaussianInteger &amp;b)&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;x - b.x, y - b.y&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    GaussianInteger <span class="keyword">operator</span> * (<span class="keyword">const</span> GaussianInteger &amp;b)&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;x * b.x - y * b.y, x * b.y + y * b.x&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//(专用! 因为此处b保证大于0)四舍五入除法</span></span><br><span class="line">    <span class="comment">//高斯整数商的实部虚部在某个整数的**(-1/2, 1/2]**区间中。</span></span><br><span class="line">    <span class="function">ll <span class="title">D</span><span class="params">(ll a, ll b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a &gt;= <span class="number">0</span>) <span class="keyword">return</span> (a % b) * <span class="number">2</span> &lt; b? a / b: a / b + <span class="number">1</span>;</span><br><span class="line">        a = -a; <span class="keyword">return</span> -((a % b) * <span class="number">2</span> &lt;= b? a / b: a / b + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    GaussianInteger <span class="keyword">operator</span> / (<span class="keyword">const</span> GaussianInteger &amp;b)&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;D(x * b.x + y * b.y, x * b.x + y * b.y), D(y * b.x - x * b.y, x * b.x + y * b.y)&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    GaussianInteger <span class="keyword">operator</span> % (<span class="keyword">const</span> GaussianInteger &amp;b)&#123;</span><br><span class="line">        GaussianInteger a = &#123;x, y&#125;;</span><br><span class="line">        <span class="keyword">return</span> a - a / b * b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> GaussianInteger NODE;</span><br><span class="line"><span class="function">NODE <span class="title">gcd</span><span class="params">(NODE a, NODE b)</span></span>&#123;<span class="keyword">return</span> !b.norm()? a: gcd(b, a % b);&#125;</span><br></pre></td></tr></table></figure>
<h3 id="线性代数"><a href="#线性代数" class="headerlink" title="线性代数"></a>线性代数</h3><h4 id="Gauss-Jordan消元法"><a href="#Gauss-Jordan消元法" class="headerlink" title="Gauss-Jordan消元法"></a>Gauss-Jordan消元法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">使用指南：</span></span><br><span class="line"><span class="comment">    读入"整形"增广矩阵a，修改行列信息equ、var。</span></span><br><span class="line"><span class="comment">    从零开始编号，则行为[0, equ - 1], 列为[0, var];</span></span><br><span class="line"><span class="comment">    返回值：</span></span><br><span class="line"><span class="comment">        返回0说明有整数解，结果存放在x数组中</span></span><br><span class="line"><span class="comment">        返回-2说明有浮点解，需要修改数据类型再运算</span></span><br><span class="line"><span class="comment">        返回-1时无解</span></span><br><span class="line"><span class="comment">        返回正数k时说明有k个自由变元，自由变元存放在flag中；</span></span><br><span class="line"><span class="comment">Tips:</span></span><br><span class="line"><span class="comment">    处理过程可能爆int</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e2</span>;</span><br><span class="line"><span class="comment">//有equ个等式，var个变量，那么增广矩阵有equ行，var + 1列；模版中从0开始标号。</span></span><br><span class="line"><span class="keyword">int</span> equ, var;</span><br><span class="line"><span class="keyword">int</span> a[maxn][maxn];</span><br><span class="line"><span class="comment">//x是解集，flag标记是否自由</span></span><br><span class="line"><span class="keyword">int</span> x[maxn], flag[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gauss</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; equ &amp;&amp; j &lt; var; i++, j++)&#123;</span><br><span class="line">        <span class="keyword">int</span> l = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = i + <span class="number">1</span>; k &lt; equ; k++) <span class="keyword">if</span>(<span class="built_in">abs</span>(a[k][j] &gt; a[l][j])) l = k;</span><br><span class="line">        <span class="keyword">if</span>(l != i) swap(a[l], a[i]);</span><br><span class="line">        <span class="comment">//i行及以下的该列全为0，转而处理下一列。</span></span><br><span class="line">        <span class="keyword">if</span>(a[i][j] == <span class="number">0</span>)&#123;</span><br><span class="line">            i--; <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = i + <span class="number">1</span>; k &lt; equ; k++) <span class="keyword">if</span>(a[k][j])&#123;</span><br><span class="line">            <span class="keyword">int</span> lcm = <span class="built_in">abs</span>(a[k][j] * a[i][j]) / gcd(<span class="built_in">abs</span>(a[k][j]), <span class="built_in">abs</span>(a[i][j]));</span><br><span class="line">            <span class="keyword">int</span> pa = lcm / a[k][j], pb = lcm / a[i][j];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> col = j; col &lt;= var; col++) a[k][col] = a[k][col] * pa - a[i][col] * pb;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//循环完成后，i是有效行数，也就是秩（？）；</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//(I)存在(0, 0, ... ,0, k!=0)的结构存在，即无解,返回-1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = i; k &lt; equ; k++) <span class="keyword">if</span>(a[k][var] != <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//(II)存在自由变元，返回变元数量，并且在flag数组中标记出所有的自由变元。</span></span><br><span class="line">    <span class="keyword">if</span>(j &lt; var)&#123;</span><br><span class="line">        <span class="comment">//i是秩，[0, i - 1]均为非全零的行</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = i - <span class="number">1</span>; k &gt;= <span class="number">0</span>; k--)&#123;</span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="number">0</span>, free_id = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; var; col++) <span class="keyword">if</span>(a[k][col] &amp;&amp; flag[col])&#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                free_id = col;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//一定存在至少一个自由变元，不然一定会被向下过程消去。</span></span><br><span class="line">            assert(free_id != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//有两个及以上变元，那么无法确定这些变元</span></span><br><span class="line">            <span class="keyword">if</span>(cnt &gt;= <span class="number">2</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 注释原因:求解变元会涉及到小数？故注释掉，实际操作时根据具体情况处理</span></span><br><span class="line">            <span class="comment">// //只剩一个变元free_id，可以求解出来。</span></span><br><span class="line">            <span class="comment">// int temp = a[k][var];</span></span><br><span class="line">            <span class="comment">// for(int col = 0; col &lt; var; col++) if(a[k][col] &amp;&amp; col != free_id) temp -= a[k][col] * x[col];</span></span><br><span class="line">            <span class="comment">// x[free_id] = tmep / a[k][free_id];</span></span><br><span class="line"></span><br><span class="line">            flag[free_id] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> var - i;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//(III)求解方程，此时保证有唯一解:如果全部为正整数解，返回0，如果出现浮点数解，返回-2；</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = var - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="keyword">int</span> tmep = a[i][var];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; var; j++) <span class="keyword">if</span>(a[i][j]) tmep -= a[i][j] * x[j];</span><br><span class="line">        <span class="keyword">if</span>(temp % a[i][i]) <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">        x[i] = temp / a[i][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改算法中的+-为异或就可以变成异或加的高斯消元法。</p>
<h4 id="逆矩阵高斯消元"><a href="#逆矩阵高斯消元" class="headerlink" title="逆矩阵高斯消元"></a>逆矩阵高斯消元</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">使用指南：</span></span><br><span class="line"><span class="comment">    读入矩阵大小n和初始矩阵在a[i][j]中, i ,j ∈[0, ... ,n - 1】</span></span><br><span class="line"><span class="comment">    返回在模M意义下的整数矩阵在a[i][j + n]中, i ,j ∈[0, ... ,n - 1】</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e2</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n; ll a[maxn][maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prt</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ;j &lt; <span class="number">2</span> * n; j++) <span class="built_in">printf</span>(<span class="string">"%-10lld "</span>,a[i][j]);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">inverse</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) a[i][j + n] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) a[i][i + n] = <span class="number">1</span>;</span><br><span class="line">    prt();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> l = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = i + <span class="number">1</span>; k &lt; n; k++) <span class="keyword">if</span>(<span class="built_in">abs</span>(a[k][i] &gt; a[l][i])) l = k;</span><br><span class="line">        <span class="keyword">if</span>(l != i) swap(a[l], a[i]);</span><br><span class="line">        prt();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!a[i][i]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        ll inv = qp(a[i][i], M - <span class="number">2</span>, M);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">2</span> * n; k++) a[i][k] = a[i][k] * inv % M;</span><br><span class="line">        prt();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) <span class="keyword">if</span>(j != i)&#123;</span><br><span class="line">            ll t = a[j][i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">2</span> * n; k++) a[j][k] = ((a[j][k] - t * a[i][k]) % M + M) % M;</span><br><span class="line">            prt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>没有经历过较强数据的测试，使用时需谨慎！⚠️！！！</p>
<h4 id="行列式"><a href="#行列式" class="headerlink" title="行列式"></a>行列式</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n; ll a[maxn][maxn];</span><br><span class="line"><span class="function">ll <span class="title">det</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ll ans = <span class="number">1</span>, temp = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> l = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) <span class="keyword">if</span>(<span class="built_in">abs</span>(a[j][i]) &gt; <span class="built_in">abs</span>(a[l][i])) l = j;</span><br><span class="line">        <span class="keyword">if</span>(l != i)&#123;</span><br><span class="line">            swap(a[i], a[l]);</span><br><span class="line">            ans = -ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!a[i][i]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) <span class="keyword">if</span>(j != i &amp;&amp; a[j][i])&#123;</span><br><span class="line">            ll lcm = a[i][i] * a[j][i] / gcd(<span class="built_in">abs</span>(a[i][i]), <span class="built_in">abs</span>(a[j][i]));</span><br><span class="line">            ll ta = lcm / a[j][i], tb = lcm / a[i][i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; k++) a[j][k] = ta * a[j][k] - tb * a[i][k];</span><br><span class="line">            temp *= ta;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) ans *= a[i][i];</span><br><span class="line">    <span class="keyword">return</span> ans / temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>没有经历过较强数据的测试，使用时需谨慎！⚠️！！！</p>
<h3 id="自适应辛普森求定积分"><a href="#自适应辛普森求定积分" class="headerlink" title="自适应辛普森求定积分"></a>自适应辛普森求定积分</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">f</span><span class="params">(<span class="keyword">double</span> x)</span></span>&#123;</span><br><span class="line">    <span class="comment">//填入积分函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">simpson</span><span class="params">(<span class="keyword">double</span> l, <span class="keyword">double</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (r - l) * (f(l) + f(r) + <span class="number">4</span> * f((l + r) / <span class="number">2</span>)) / <span class="number">6</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">solve</span><span class="params">(<span class="keyword">double</span> L, <span class="keyword">double</span> R, <span class="keyword">double</span> ans)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> mid = (L + R) / <span class="number">2</span>, l = simpson(L, mid), r = simpson(mid, R);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fabs</span>(l + r - ans) &lt;= eps) <span class="keyword">return</span> ans; </span><br><span class="line">    <span class="keyword">return</span> solve(L, mid, l) + solve(mid, R, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="7-数据结构"><a href="#7-数据结构" class="headerlink" title="7 数据结构"></a>7 数据结构</h2><h3 id="区间合并线段树"><a href="#区间合并线段树" class="headerlink" title="区间合并线段树"></a>区间合并线段树</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tree</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, ll, rr, all;</span><br><span class="line">&#125;tree[maxn &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化区间线段树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    tree[p].l = l; tree[p].r = r;</span><br><span class="line">    tree[p].ll = tree[p].rr = tree[p].all = r - l + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(r == l) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    build(ls, l, mid);</span><br><span class="line">    build(rs, mid + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">	<span class="comment">//更新连续左区间</span></span><br><span class="line">    <span class="keyword">if</span>(tree[ls].ll == tree[ls].r - tree[ls].l + <span class="number">1</span>) tree[p].ll = tree[ls].ll + tree[rs].ll;</span><br><span class="line">    <span class="keyword">else</span> tree[p].ll = tree[ls].ll;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//更新连续右区间</span></span><br><span class="line">    <span class="keyword">if</span>(tree[rs].rr == tree[rs].r - tree[rs].l + <span class="number">1</span>) tree[p].rr = tree[ls].rr + tree[rs].rr;</span><br><span class="line">    <span class="keyword">else</span> tree[p].rr = tree[rs].rr;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//更新全区间</span></span><br><span class="line">    tree[p].all = max(tree[ls].all, max(tree[rs].all, tree[ls].rr + tree[rs].ll));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//将x所在的元素置为k(k = 0/1)；当前节点为p</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> x, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree[p].l == tree[p].r &amp;&amp; tree[p].l == x)&#123;</span><br><span class="line">        tree[p].all = tree[p].ll = tree[p].rr = k;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= (tree[p].l + tree[p].r) &gt;&gt; <span class="number">1</span>) update(ls, x, k);</span><br><span class="line">    <span class="keyword">else</span> update(rs, x, k);</span><br><span class="line">    up(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">que</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree[p].l == tree[p].r) <span class="keyword">return</span> tree[p].all;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//x处于中心位置的区间则更新之</span></span><br><span class="line">    <span class="keyword">if</span>(x &gt;= tree[ls].r - tree[ls].rr + <span class="number">1</span> &amp;&amp; x &lt;= tree[rs].l + tree[rs].ll - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> tree[ls].rr + tree[rs].ll;</span><br><span class="line">    <span class="comment">//x处于左边其他某个位置</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(x &lt; tree[ls].r - tree[ls].rr + <span class="number">1</span>) <span class="keyword">return</span> que(ls, x);</span><br><span class="line">    <span class="comment">//x处于右边其他某个位置</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> que(rs, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="线段树哈希"><a href="#线段树哈希" class="headerlink" title="线段树哈希"></a>线段树哈希</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls (p &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs ((p &lt;&lt; 1) | 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mid ((l + r) &gt;&gt; 1)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">5e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="comment">//数值对mod取模</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">65536</span>;</span><br><span class="line"><span class="comment">//哈希的基底和模数</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> pp = <span class="number">999983</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1000237529</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意mod和M！实际运用时不要写错了！</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//st为哈希和线段树; st1为极值线段树，用于维护对mod取模的相关信息。</span></span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line">ll tag[maxn &lt;&lt; <span class="number">2</span>], st1[maxn &lt;&lt; <span class="number">2</span>], st[maxn &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="comment">//po[i] = pp ^ i; pre[i] = po[0] + po[1] + ... + po[i]，用于对区间快速更新哈希和</span></span><br><span class="line">ll po[maxn], pre[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    st[p] = st[ls] + st[rs] * po[mid - l + <span class="number">1</span>] % M; st[p] %= M;</span><br><span class="line">    st1[p] = max(st1[ls], st1[rs]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r &amp;&amp; l == k)&#123;</span><br><span class="line">        st[p] = st1[p] = x;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(k &lt;= mid) build(ls, l, mid, k, x);</span><br><span class="line">    <span class="keyword">else</span> build(rs, mid + <span class="number">1</span>, r, k, x);</span><br><span class="line">    up(p, l, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tag[p])&#123;</span><br><span class="line">        tag[ls] += tag[p];</span><br><span class="line">        tag[rs] += tag[p];</span><br><span class="line">        </span><br><span class="line">        st[ls] += pre[mid - l] * tag[p] % M; st[ls] %= M;</span><br><span class="line">        st[rs] += pre[r - mid - <span class="number">1</span>] * tag[p] % M; st[rs] %= M;</span><br><span class="line">        </span><br><span class="line">        st1[ls] += tag[p];</span><br><span class="line">        st1[rs] += tag[p];</span><br><span class="line">        </span><br><span class="line">        tag[p] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R)&#123;</span><br><span class="line">        st[p] += pre[r - l] * x % M; st[p] %= M;</span><br><span class="line">        st1[p] += x; tag[p] += x;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    down(p, l, r);</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= mid) udpate(ls, l, mid, L, R, x);</span><br><span class="line">    <span class="keyword">if</span>(R &gt; mid) update(rs, mid + <span class="number">1</span>, r, L , R, x);</span><br><span class="line">    up(p, l, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">purify</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(st1[p] &lt; mod) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">        st[p] %= mod; st1[p] %= mod;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    down(p, l, r);</span><br><span class="line">    <span class="keyword">if</span>(st1[ls] &gt;= mod) purify(ls, l, mid);</span><br><span class="line">    <span class="keyword">if</span>(st1[rs] &gt;= mod) purify(rs, mid + <span class="number">1</span>, r);</span><br><span class="line">    up(p, l, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">hsh</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R) <span class="keyword">return</span> st[p];</span><br><span class="line">    down(p, l, r);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(R &lt;= mid) <span class="keyword">return</span> hsh(ls, l, mid, L, R);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(L &gt; mid) <span class="keyword">return</span> hsh(rs, mid + <span class="number">1</span>, r, L, R);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">      需要注意！</span></span><br><span class="line"><span class="comment">      往子树递归时[L, R]要变化成[L, mid](不重要)和[mid + 1, R](重要)！</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">        ll ans = hsh(ls, l, mid, L, mid);</span><br><span class="line">        ans += hsh(rs, mid + <span class="number">1</span>, r, mid + <span class="number">1</span>, R) * po[mid - L + <span class="number">1</span>] % M;</span><br><span class="line">        ans %= M;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//Fastin;</span></span><br><span class="line">    po[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; maxn; i++) po[i] = po[i - <span class="number">1</span>] * <span class="number">1l</span>l * pp % M;</span><br><span class="line">    pre[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; maxn; i++) pre[i] = pre[i - <span class="number">1</span>] + po[i], pre[i] %= M;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> n, m; <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, a + i);</span><br><span class="line">        build(<span class="number">1</span>, <span class="number">1</span>, n, i, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="keyword">int</span> op; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;op);</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> l, r, x; <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;l, &amp;r, &amp;x);</span><br><span class="line">            update(<span class="number">1</span>, <span class="number">1</span>, n, l, r, x);</span><br><span class="line">          <span class="comment">//每次更新完后都会将超出范围的叶子结点进行更新，实际应用时需要考虑复杂度是否支持！</span></span><br><span class="line">            purify(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> l, r, k; <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;l, &amp;r, &amp;k);</span><br><span class="line">            </span><br><span class="line">            ll res1 = hsh(<span class="number">1</span>, <span class="number">1</span>, n, l, l + k - <span class="number">1</span>);</span><br><span class="line">            ll res2 = hsh(<span class="number">1</span>, <span class="number">1</span>, n, r, r + k - <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">puts</span>(res1 == res2? <span class="string">"yes"</span>: <span class="string">"no"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>INPUT</code></p>
<p>数据长度n 操作次数m</p>
<p>$a_1, a_2,…,a_n$</p>
<p>$op_1, l_1, r_1, x_1$</p>
<p>$op_2, l_2, r_2, x_2$</p>
<p>…</p>
<p>$op_m, l_m, r_m, x_m$</p>
<p><code>功能</code></p>
<ul>
<li>op为1，对区间[li, ri] += xi, 并对指定模数<code>mod</code>取模</li>
<li>op为2，查询以li和ri为起点的两端长度均为x的区间的哈希和，以此来判断序列是否相同。</li>
</ul>
<h3 id="线段树合并"><a href="#线段树合并" class="headerlink" title="线段树合并"></a>线段树合并</h3><h4 id="子树最多出现次数颜色和的查询"><a href="#子树最多出现次数颜色和的查询" class="headerlink" title="子树最多出现次数颜色和的查询"></a>子树最多出现次数颜色和的查询</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 动态开点线段树：</span></span><br><span class="line"><span class="comment">    - 插入一个节点</span></span><br><span class="line"><span class="comment">    - 合并两棵树</span></span><br><span class="line"><span class="comment"> 维护出现最多的次数的颜色的和，记录两个值(出现次数，颜色和)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mid ((l + r) &gt;&gt; 1)</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1e5</span> * <span class="number">20</span> * <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> haed[maxn], top = <span class="number">0</span>, root[maxn];</span><br><span class="line">star edge[maxn &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    edge[top].to = v;</span><br><span class="line">    edge[top].next = head[u];</span><br><span class="line">    head[u] = top++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NODE</span>&#123;</span><span class="keyword">int</span> mx; ll sum;&#125;;</span><br><span class="line">NODE st[M];</span><br><span class="line"><span class="keyword">int</span> ls[M], rs[M], cnt = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//cnt必须从1开始！这是由merge的实现所决定的！</span></span><br><span class="line"><span class="comment">//加入一个单点作为初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> &amp;p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!p) p = cnt++;</span><br><span class="line">    <span class="keyword">if</span>(l == r &amp;&amp; l == k)&#123;</span><br><span class="line">        st[p].mx = <span class="number">1</span>; st[p].sum = k;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(k &lt;= mid)&#123;</span><br><span class="line">        update(ls[p], l, mid, k);</span><br><span class="line">        st[p] = st[ls[p]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        update(rs[p], mid + <span class="number">1</span>, r, k);</span><br><span class="line">        st[p] = st[rs[p]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(st[ls[p]].mx &gt; st[rs[p]].mx) st[p] = st[ls[p]];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(st[ls[p]].mx &lt; st[rs[p]].mx) st[p] = st[rs[p]];</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        st[p].mx = st[ls[p]].mx;</span><br><span class="line">        st[p].sum = st[ls[p]].sum + st[rs[p]].sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将r1与r2对应的两棵结构相同的线段树进行合并，返回值为合并后的树的标号</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> r1, <span class="keyword">int</span> r2, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!r1) <span class="keyword">return</span> r2;</span><br><span class="line">    <span class="keyword">if</span>(!r2) <span class="keyword">return</span> r1;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">        st[r1].mx += st[r2].mx;</span><br><span class="line">        <span class="keyword">return</span> r1;</span><br><span class="line">    &#125;</span><br><span class="line">    ls[r1] = merge(ls[r1], ls[r2], l, mid);</span><br><span class="line">    rs[r1] = merge(rs[r1], rs[r2], mid + <span class="number">1</span>, r);</span><br><span class="line">    up(r1);</span><br><span class="line">    <span class="keyword">return</span> r1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll ans[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> par)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[now]; ~i; i = edge[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> to = edge[i].to; <span class="keyword">if</span>(to == par) <span class="keyword">continue</span>;</span><br><span class="line">        dfs(to, now);</span><br><span class="line">        root[now] = merge(root[now], root[to], <span class="number">1</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">    ans[now] = st[root[now]].sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//    Fastin;</span></span><br><span class="line">    clr(head, <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> c; scnaf(<span class="string">"%d"</span>, &amp;c);</span><br><span class="line">        udpate(root[i], <span class="number">1</span>, n, c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> u, v; <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;u, &amp;v);</span><br><span class="line">        add(u, v); add(v, u);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    prt(ans + <span class="number">1</span>, n);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>给出一棵n节点的树，每个节点具有一个颜色。</p>
<p>输出在以1为根时，每个节点及其子树上所有节点中最多数量的颜色的和。</p>
<p>$n \leq 1e5, c_i \leq n$</p>
<p>每插入一个节点，会产生logn个新节点，因而总共至多产生nlogn个新节点。</p>
<p>而在每一次merge时，会合并掉一个节点，合并的复杂度是$O(1)$，所以至多进行nlogn次合并。</p>
<p>因而线段树合并的总体复杂度是$O(nlogn)$</p>
<h3 id="segment-tree-beats"><a href="#segment-tree-beats" class="headerlink" title="segment tree beats"></a>segment tree beats</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls (p &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs ((p &lt;&lt; 1) | 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mid ((l + r) &gt;&gt; 1)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[manx];</span><br><span class="line"><span class="comment">//st中记录区间和，mx记录最值，cnt记录最值的数量，smx记录第二极值的大小。</span></span><br><span class="line">ll st[maxn &lt;&lt; <span class="number">2</span>]; <span class="keyword">int</span> mx[maxn &lt;&lt; <span class="number">2</span>], cnt[maxn &lt;&lt; <span class="number">2</span>], smx[maxn &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    st[p] = st[ls] + st[rs];</span><br><span class="line">    <span class="keyword">if</span>(mx[ls] &gt; mx[rs])&#123;</span><br><span class="line">        mx[p] = mx[ls];</span><br><span class="line">        cnt[p] = cnt[ls];</span><br><span class="line">        smx[p] = max(mx[rs], smx[ls]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(mx[ls] &lt; mx[rs])&#123;</span><br><span class="line">        mx[p] = mx[rs];</span><br><span class="line">        cnt[p] = cnt[rs];</span><br><span class="line">        smx[p] = max(mx[ls], smx[rs]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        mx[p] = mx[ls];</span><br><span class="line">        cnt[p] = cnt[ls] + cnt[rs];</span><br><span class="line">        smx[p] = max(smx[ls], smx[rs]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    st[p] -= <span class="number">1l</span>l * cnt[p] * (mx[p] - x);</span><br><span class="line">    mx[p] = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(mx[ls] &gt; mx[p] &amp;&amp; mx[p] &gt; smx[ls]) fun(ls, mx[p]);</span><br><span class="line">    <span class="keyword">if</span>(mx[rs] &gt; mx[p] &amp;&amp; mx[p] &gt; smx[rs]) fun(rs, mx[p]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">        st[p] = mx[p] = a[l];</span><br><span class="line">        cnt[p] = <span class="number">1</span>;</span><br><span class="line">        smx[p] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    build(ls, l, mid);</span><br><span class="line">    build(rs, mid + <span class="number">1</span>, r);</span><br><span class="line">    up(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(mx[p] &lt;= x) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R)&#123;</span><br><span class="line">        <span class="keyword">if</span>(smx[p] &lt; x)&#123;</span><br><span class="line">            fun(p, x); <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    down(p);</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= mid) update(ls, l, mid, L, R, x);</span><br><span class="line">    <span class="keyword">if</span>(R &gt; mid) update(rs, mid + <span class="number">1</span>, r, L, R, x);</span><br><span class="line">    up(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getmx</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R) <span class="keyword">return</span> mx[p];</span><br><span class="line">    down(p);</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= mid) ans = max(ans, getmx(ls, l, mid, L, R));</span><br><span class="line">    <span class="keyword">if</span>(R &gt; mid) ans = max(ans, getmx(rs, mid + <span class="number">1</span>, r, L, R));</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">getsum</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R) <span class="keyword">return</span> st[p];</span><br><span class="line">    </span><br><span class="line">    down(p);</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= mid) ans += getsum(ls, l, mid, L, R);</span><br><span class="line">    <span class="keyword">if</span>(R &gt; mid) ans += getsum(rs, mid + <span class="number">1</span>, r, L, R);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// Fastin;</span></span><br><span class="line">    TTT&#123;</span><br><span class="line">        <span class="keyword">int</span> n, m; <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;m);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) scnaf(<span class="string">"%d"</span>, a + i);</span><br><span class="line">        build(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">            <span class="keyword">int</span> op; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;op);</span><br><span class="line">            <span class="keyword">int</span> x, y, z;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;x, &amp;y);</span><br><span class="line">            <span class="keyword">if</span>(op == <span class="number">0</span>)&#123;</span><br><span class="line">                scnaf(<span class="string">"%d"</span>, &amp;z);</span><br><span class="line">                update(<span class="number">1</span>, <span class="number">1</span>, n, x, y, z);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, getmx(<span class="number">1</span>, <span class="number">1</span>, n, x, y));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, getsum(<span class="number">1</span>, <span class="number">1</span>, n, x, y));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=5306" target="_blank" rel="noopener">hdu 5306模板</a></p>
<p>给出长度为$n$的序列，要求支持如下操作:</p>
<ul>
<li>给出$l ,r, x$，令$a_i = min(a_i, x), i = l, …, r$</li>
<li>给出$l, r$，查询区间中的最大值/区间和</li>
</ul>
<p>听说不进行区间加减的话复杂度均摊$O(nlogn)$</p>
<h2 id="10-技术"><a href="#10-技术" class="headerlink" title="10 技术"></a>10 技术</h2><h3 id="1-快读"><a href="#1-快读" class="headerlink" title="1 快读"></a>1 快读</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> <span class="keyword">_t</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(<span class="keyword">_t</span> &amp;x)</span></span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">_t</span> fu = <span class="number">1</span>; <span class="keyword">char</span> ch = getchar();</span><br><span class="line">    <span class="keyword">while</span>(ch &lt; <span class="string">'0'</span> || ch &gt; <span class="string">'9'</span>)&#123;<span class="keyword">if</span>(ch == <span class="string">'-'</span>) fu = - <span class="number">1</span>; ch = getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>)&#123;</span><br><span class="line">        x = (x &lt;&lt; <span class="number">3</span>) + (x &lt;&lt; <span class="number">1</span>) + (ch &amp; <span class="number">15</span>);</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    x *= fu ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-对拍套件（坑）"><a href="#2-对拍套件（坑）" class="headerlink" title="2 对拍套件（坑）"></a>2 对拍套件（坑）</h3><h2 id="100-待处理"><a href="#100-待处理" class="headerlink" title="100 待处理"></a>100 待处理</h2><h3 id="多项式算法"><a href="#多项式算法" class="headerlink" title="多项式算法"></a>多项式算法</h3><h3 id="tarjan"><a href="#tarjan" class="headerlink" title="tarjan"></a>tarjan</h3>
    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/06/16/%E5%88%A9%E7%94%A8%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%9601Trie%E8%A7%A3%E5%86%B3%E5%8C%BA%E9%97%B4%E5%BC%82%E6%88%96%E4%B8%80%E7%B1%BB%E9%97%AE%E9%A2%98/" rel="prev" title="利用可持久化01Trie解决区间异或一类问题">
      <i class="fa fa-chevron-left"></i> 利用可持久化01Trie解决区间异或一类问题
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/06/18/%E5%AF%B9%E6%8B%8D%E7%A8%8B%E5%BA%8F/" rel="next" title="对拍程序">
      对拍程序 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-字符串"><span class="nav-number">1.</span> <span class="nav-text">1 字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#trie树"><span class="nav-number">1.1.</span> <span class="nav-text">trie树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Manacher"><span class="nav-number">1.2.</span> <span class="nav-text">Manacher</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#KMP"><span class="nav-number">1.3.</span> <span class="nav-text">KMP</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AC自动机"><span class="nav-number">1.4.</span> <span class="nav-text">AC自动机</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#回文树"><span class="nav-number">1.5.</span> <span class="nav-text">回文树</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-计算几何"><span class="nav-number">2.</span> <span class="nav-text">2 计算几何</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#已知平面圆上三点求圆心及其半径"><span class="nav-number">2.1.</span> <span class="nav-text">已知平面圆上三点求圆心及其半径</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#平面上圆的k次交"><span class="nav-number">2.2.</span> <span class="nav-text">平面上圆的k次交</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#凸包周长"><span class="nav-number">2.3.</span> <span class="nav-text">凸包周长</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-图论"><span class="nav-number">3.</span> <span class="nav-text">3 图论</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#最短路"><span class="nav-number">3.1.</span> <span class="nav-text">最短路</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#01bfs"><span class="nav-number">3.1.1.</span> <span class="nav-text">01bfs</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#异或MST-（Boruvka算法）"><span class="nav-number">3.2.</span> <span class="nav-text">异或MST （Boruvka算法）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#图的匹配"><span class="nav-number">3.3.</span> <span class="nav-text">图的匹配</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#二分图最大匹配"><span class="nav-number">3.3.1.</span> <span class="nav-text">二分图最大匹配</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#匈牙利算法"><span class="nav-number">3.3.1.1.</span> <span class="nav-text">匈牙利算法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#最大流-Dinic实现"><span class="nav-number">3.3.1.2.</span> <span class="nav-text">最大流(Dinic实现)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#二分图最大权匹配"><span class="nav-number">3.3.2.</span> <span class="nav-text">二分图最大权匹配</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#流算法"><span class="nav-number">3.4.</span> <span class="nav-text">流算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#最大流"><span class="nav-number">3.4.1.</span> <span class="nav-text">最大流</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#dinic-当前弧优化"><span class="nav-number">3.4.1.1.</span> <span class="nav-text">dinic (当前弧优化)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#isap-gap优化"><span class="nav-number">3.4.1.2.</span> <span class="nav-text">isap (gap优化)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#最高标号预流推进HLPP"><span class="nav-number">3.4.1.3.</span> <span class="nav-text">最高标号预流推进HLPP</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#费用流-dijstra"><span class="nav-number">3.4.2.</span> <span class="nav-text">费用流 (dijstra)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线段树优化建图"><span class="nav-number">3.5.</span> <span class="nav-text">线段树优化建图</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-可持久化"><span class="nav-number">4.</span> <span class="nav-text">4 可持久化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#可持久化01-Trie"><span class="nav-number">4.1.</span> <span class="nav-text">可持久化01-Trie</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#可持久化权值线段树-静态区间第k大查询"><span class="nav-number">4.2.</span> <span class="nav-text">可持久化权值线段树 静态区间第k大查询</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BIT套权值线段树-带单点修改的区间第k大查询"><span class="nav-number">4.3.</span> <span class="nav-text">BIT套权值线段树 带单点修改的区间第k大查询</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-树"><span class="nav-number">5.</span> <span class="nav-text">5 树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#树链剖分"><span class="nav-number">5.1.</span> <span class="nav-text">树链剖分</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#求lca"><span class="nav-number">5.1.1.</span> <span class="nav-text">求lca</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#支持路径修改-查询、子树修改查询"><span class="nav-number">5.1.2.</span> <span class="nav-text">支持路径修改&#x2F;查询、子树修改查询</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#点分治"><span class="nav-number">5.2.</span> <span class="nav-text">点分治</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#计数树上两点之间路径长度为k的对数（开桶加速-多组查询）"><span class="nav-number">5.2.1.</span> <span class="nav-text">计数树上两点之间路径长度为k的对数（开桶加速 多组查询）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#点分树"><span class="nav-number">5.3.</span> <span class="nav-text">点分树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#多组查询与某点距离小于等于k的所有点权和-并支持单点修改"><span class="nav-number">5.3.1.</span> <span class="nav-text">多组查询与某点距离小于等于k的所有点权和 并支持单点修改</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pruefer序列"><span class="nav-number">5.4.</span> <span class="nav-text">pruefer序列</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#计数相关定理"><span class="nav-number">5.4.1.</span> <span class="nav-text">计数相关定理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#凯莱公式"><span class="nav-number">5.4.1.1.</span> <span class="nav-text">凯莱公式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#图联通方案数"><span class="nav-number">5.4.1.2.</span> <span class="nav-text">图联通方案数</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-数学"><span class="nav-number">6.</span> <span class="nav-text">6 数学</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#异或线性基"><span class="nav-number">6.1.</span> <span class="nav-text">异或线性基</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多项式"><span class="nav-number">6.2.</span> <span class="nav-text">多项式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#FTT"><span class="nav-number">6.2.1.</span> <span class="nav-text">FTT</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#NTT"><span class="nav-number">6.2.2.</span> <span class="nav-text">NTT</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#高斯整数"><span class="nav-number">6.3.</span> <span class="nav-text">高斯整数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线性代数"><span class="nav-number">6.4.</span> <span class="nav-text">线性代数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Gauss-Jordan消元法"><span class="nav-number">6.4.1.</span> <span class="nav-text">Gauss-Jordan消元法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#逆矩阵高斯消元"><span class="nav-number">6.4.2.</span> <span class="nav-text">逆矩阵高斯消元</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#行列式"><span class="nav-number">6.4.3.</span> <span class="nav-text">行列式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#自适应辛普森求定积分"><span class="nav-number">6.5.</span> <span class="nav-text">自适应辛普森求定积分</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-数据结构"><span class="nav-number">7.</span> <span class="nav-text">7 数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#区间合并线段树"><span class="nav-number">7.1.</span> <span class="nav-text">区间合并线段树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线段树哈希"><span class="nav-number">7.2.</span> <span class="nav-text">线段树哈希</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线段树合并"><span class="nav-number">7.3.</span> <span class="nav-text">线段树合并</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#子树最多出现次数颜色和的查询"><span class="nav-number">7.3.1.</span> <span class="nav-text">子树最多出现次数颜色和的查询</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#segment-tree-beats"><span class="nav-number">7.4.</span> <span class="nav-text">segment tree beats</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-技术"><span class="nav-number">8.</span> <span class="nav-text">10 技术</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-快读"><span class="nav-number">8.1.</span> <span class="nav-text">1 快读</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-对拍套件（坑）"><span class="nav-number">8.2.</span> <span class="nav-text">2 对拍套件（坑）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#100-待处理"><span class="nav-number">9.</span> <span class="nav-text">100 待处理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#多项式算法"><span class="nav-number">9.1.</span> <span class="nav-text">多项式算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#tarjan"><span class="nav-number">9.2.</span> <span class="nav-text">tarjan</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="rqdmap"
      src="/uploads/huiye.png">
  <p class="site-author-name" itemprop="name">rqdmap</p>
  <div class="site-description" itemprop="description">rqdmap's personal blogs.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">51</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">49</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/rqdmap" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;rqdmap" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:414060972@qq.com" title="E-Mail → mailto:414060972@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://blog.csdn.net/Herr_Shiiiii" title="https:&#x2F;&#x2F;blog.csdn.net&#x2F;Herr_Shiiiii" rel="noopener" target="_blank">原CSDN博客</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">rqdmap</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>

<script src="/js/utils.js"></script>


<script src="/js/next-boot.js"></script>


  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : 'bbbd1fae621180c2d543',
      clientSecret: '89c23ca14e82470755f6d1e45485d1b266b8f0bb',
      repo        : 'GitalkComments',
      owner       : 'rqdmap',
      admin       : ['rqdmap'],
      id          : '27010a8f8dba24cfc86dd8d74d2280c3',
        language: '',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

</body>
</html>
