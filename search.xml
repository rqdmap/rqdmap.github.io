<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Factorio</title>
      <link href="/2021/07/19/Factorio/"/>
      <url>/2021/07/19/Factorio/</url>
      
        <content type="html"><![CDATA[<p>Factorio模块设计指北</p><span id="more"></span> <p>[toc]</p><p><del>看Linux内核看了一半来打游戏了qaq</del></p><h2 id="电路"><a href="#电路" class="headerlink" title="电路"></a>电路</h2><h3 id="秒表0型"><a href="#秒表0型" class="headerlink" title="秒表0型"></a>秒表0型</h3><p>点信号恒定输出1，第一个判断器设置点信号小于60时输出点信号，且反馈到输入端。</p><p>这样，在0tick时，输入端恒定1个点，1tick点信号通过判断器反馈到输入端，此时判断器上不仅有反馈来的点信号量，也有常量箱中恒定的1个点信号增量。不断反复循环，累积量通过判断器反馈，常量箱给出增量。该信号系统的点信号在1到60之间循环，每tick变换一次。</p><p>第二个判断器检查点信号是否为<strong>60</strong>，注意，当第一个判断器输入59+1个点信号时，尽管不会输出60，但是在该信号系统中的点信号为60，因而与该系统相连的第二个判断器应该检查60。检查成功后输出一个S信号表示秒，类似地给出一个累加器即可记录总共经历的秒数。</p><p>秒表0型实现简单，逻辑器件少，但是由于常量箱表示增量，因而开关常量箱只会暂停/继续计数，所以不支持清零。</p><p><img src="/images/Factorio/one_second_counter_0.png" alt=""></p><p>蓝图代码:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0eNrNlW1vgjAQx7/LvUYjiIpk+xS+XAzh4dgugZaU1syYfvddYTJnNqKbLntD0uvd/x5+tD1AVhlsFAkN8QEol6KF+OkALT2LtHI2vW8QYtiR0oYtHoi0dobeY+KD9YBEga8Q+3brAQpNmrCX6Rb7RJg6Q8UOQ3SBORWoJrmsMxKploqVG9lyqBQuLctNounCgz3EEafgyrSSVZLhS7ojdmefd5GE94ousHXWklSrk4sbKKSGXr/VqRvDcuZWdZOqrqwYHjhGGt2Yn6g2ey7PCJ2UStYJCVaBWCuDtk8qMB8q991HYXE6Oiq6seWkckO6WwZ2y7HBZc6+9T5tz8e3Q9a2J7YjueA6csu/ILe5A7fN7agF59RGQYxDDc6pfU1pfh2l1f84X4835lSmVXu343UhiXAo+Nj4OIr1EcV08Q2MkiqN6srbeRi+cZP3T2/qX83HupueNNac6uMF8aBKM+S6QApMWnT/Tc8HXc87Lr9rOYj8cLUOVuFsvgrCyNo3FPk+Cg==1</span><br></pre></td></tr></table></figure><h3 id="秒表1型（可清零）"><a href="#秒表1型（可清零）" class="headerlink" title="秒表1型（可清零）"></a>秒表1型（可清零）</h3><p>上述的简单模型无法解决清零的操作，因为每个信号都被存放在信号系统中而不可能被清零（除非手动拆线等），因而本模型添加了一个运算器，判断器在获得累加的结果后不直接反馈到输入端，而是<strong>通过一个运算器后</strong>再输出到输入端。这样我们就可以通过运算器来进行清零/不变的操作，但是要注意的是，每通过一个运算器都要消耗1tick，所以该模型下点信号达到30时就已经度过了1秒。</p><p>具体来说，运算器中进行点信号乘以检查信号，输出点信号。当打开检查信号时开始计数，当关闭检查信号时反馈终止，判断器只能获得最初的一个点信号而无法获得以往的累积量，这样就实现了点信号的可清零操作。</p><p>接下来考察秒数。如果直接按照计时器0统计S信号，会发现S每次跨度为2地增长。这是因为在模型0中，每个信号脉冲都只持续1tick，而在该模型中，点信号的传递经过2个运算器，需要2tick，也就是说2tick才会进行一次点信号自增，那么也就意味着该系统中信号的脉冲宽度为2，这就解释了为什么S信号会以2为步长进行增加。</p><p>我们使用如下的结构来统计秒数，S信号输入到判断器中，判断器输出到运算器中，运算器再反馈到判断器的输入端。这个结构与点信号的结构相同，所以自然也支持清零操作。但是更精妙的是，在本模型中进位来的S信号持续2tick，在第1tick时累加的S信号通过判断器，达到运算器，在2tick时通过运算器，回到输入端，正好与进位S信号汇合。该过程说明了一个宽度为2的S进位信号脉冲恰好引起一次秒数累加器的进位（<del>其实这也说明了为什么1秒60tick的常量箱点信号只能产生30个点信号累加结果</del>），那么累加器中的秒数就直接是实际的秒数，而不需要任何的二次转化。</p><p><img src="/images/Factorio/one_second_counter_1.png" alt=""></p><p>蓝图代码:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0eNrNlt1umzAUx9/FlxOpCjGQoq03fYRcTpVlzMlyNLCRMdGiiHefDRkNaRPhLNV2g2Sb8+H/7xzbB5KXLdQapSHZgaBQsiHZ9wNp8IfkpZsz+xpIRnaoTWtnAiJ55SaGPxYh6QKCsoBfJAu7wMPy5cQy6l4DAtKgQRgS6Ad7JtsqB21dj9YuRcOlWQhV5Si5Udq6rlVjbZV0ca2/xdNDHJC9tYsfYhumQA1iWI8C58JoVbIctnyH1t4abbA0oD03L7YgfrptCNU6BcMTKV77aSmHuI3zFrqPhuJ0g1gMKaEWLZp+6Gw7J+WZBtEYnms02woMiusqrC5okHyswZtbZpcLHBPfoG4Mmy1LoYwTpQHnhfmrqWrQfMiUfLG/qdbUrW/8br7+4YnYbkynPKKeZXTBmM6Dt7y1gOlnFvCR1N+V70wF6Bi8AIEF6Fm1O3f7R593Kdw/hCy1Rzeqaq77LDPy9dZydH7qPeuVZhutKobSeiGZ0S141OryrFaj81qdLifv2Vwu5Xfn0NRXOo9z7Mc58Tun78J5PaV8Dvn5Bsjr+yFOriNNfU6nmcySm5j9Z7357c7YNrxsfLhRn16L54FJve98Or58pmzo5975639646+97nt6vcFinwb7kKN9zKKByub39rwOSMlzsJshSgI7KtUXneuM0qHc2ft76KNVSNOnKKWPyzSiq677DVQ5/nw=</span><br></pre></td></tr></table></figure><h3 id="产物计数器"><a href="#产物计数器" class="headerlink" title="产物计数器"></a>产物计数器</h3><p>借助秒表1型和一个简单的可清零累加器，就能够统计传送带上的物品速度。打开检查信号后开始统计，记录经过的秒数和经过的物品，作除法输出在最后一个运算器中。</p><font color=#ee0000> 为了避免信号冲突，必须使用绿线与传送带连接。统计不同的产物时，应该更改累加器和均值器中对应的物品。</font><p><img src="/images/Factorio/one_second_counter_2.png" alt=""></p><p>蓝图代码:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0eNrNV91u0zAUfhdfomwsWbq0EfASk7hBU5Qm7maRPznORFVFWhEbAm0DwSQECNguBgMJJqEJum4oD0PSbFe8AnZalbZr0yZbgZuqjn0+n3O+c/zZNVA2POhgZBEg14AOXQ0jhyDbAjIIG82wuXFeD6L1rTDYi558jza+xp/qv043o2D9fO8k/BHEOwfxSRA3g7CxHZ7unq/Vo8b7s+Bta3v/59r9+OTd2Ze9sLEVPd2MXz0Imx/iRx9bL74xhObO2eF+6/VRa+c4PjqMHu9GLw+iZ5vRm4fR2in9HzY+R4fHdBk1pFbR8zoFBBxAmm25QL5TAy5atlSD+U2qDqQOIwJNusJSTTbSoYZ0iGc02ywjSyU2Bj41t3R4D8i8z40FUDEiKyYkSBuOIfhLHIAWQQTBtkfJoKpYnlmGmG4yBooDju2idrZrgHklzhY4UAXyjEC30RGGWntW5AANm2DbUMpwRV1F1Jqa/IFV6LSeQLlsooKwS5Qx8UGDwmPbYk4hrHmIsOBcyKAu2q4iTDz6pWveXjGjrUDtLjO0HYjVTulco8tsjzheLid8PwnXakefBMSzHwz13jQjOlpgHCxjCK3BGZr8DmAypGRRVGEETKl/MT8pKl3IvL3AvNCNj1UrUS2Sznuhy/tsoZ95YTjzFWQQiEf0wSiqdDthWLM91u58TzMsTZ7x+ckyMJ/WhxcTIGULv4M5WdWPTUebIerzHBuZjooTL2VwI6WMx6I6VSXJtFLBtqkgi6IAmWAPZihvoSezbCwOJr9/WspS84VMWKN4FrPxXPoveb6Zg+fFFJYrquFmoXlIT43mrTgZMYWs4iPw2bjJKj6piZy66qTsnp+owfYsZum/Ynr/lSajeSGv0vDTVJouPZfTGv5Kjigp8zVMGpGihel2Queg+me9kOyf6fLFpXdHWvlPeI8o5tIX/m/qy2K/ugyKy60rFpeMVwgx/cgqXOrKMJyzUl7p4ackPdN49ywOdtz1HDzfztRvhXQqh7x4fPaQSaKXe176HDDUMjQSzaDVBRkjq/SMb6e8yItSSZDEuXlJEIu+/xv7McIE</span><br></pre></td></tr></table></figure><h3 id="电子时钟"><a href="#电子时钟" class="headerlink" title="电子时钟"></a>电子时钟</h3><h4 id="八段数码管"><a href="#八段数码管" class="headerlink" title="八段数码管"></a>八段数码管</h4><p>设置ABCDEFG七个信号，同时开启颜色选项，不支持小数点。</p><p><img src="/images/Factorio/digit_disp.png" alt=""></p><p>蓝图代码:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0eNrdmkuO2zAMhu+itWdgUX4vCvR9iCIInERtBfgR+BE0CLzoIbpvLzDopleauUblCVqkTAiYCxeQNwEsm1L0gSJ/0j6JTdHrfWOqTmQnYbZ11Yrsw0m05lOVF+NYd9xrkYmDabrejniiystx4PzEXSIGT5hqp7+ITA7eDUvT6fLCrMyL4q7Iy/2FIQwrT+iqM53R5/WfL47rqi83urEz37L3xL5urUldjavZae5kENyHnjiKLJH3oZ3f7qdr6mK90Z/zg6mb8cGtaba96db23u6v9UfTtN168q7fifPkbZeP5PzxotznTd6Na4gX4+2+1XaNom7sjrqm12eLSm/HNdtxETn+NHp3uWOzG3F4/1xLf1gNw8XgHyzAxuLPiuXlrFgkwhIQVNRUKrAEKgGiEhFUgqlU1BKo4COkCCrhVCr+EqhEiEpCUImmUpFLoKIQlZCgEk+kotL/k4RezUolwUlIElgSNhaXnSVEWGKCSspOzcphxWIVCvIWKjlLnw0GXAaDuKQUFsk+ReBwcImxuwDFBdhclMNcJPYXSTqMYp+jcFYw7+cFg2WuxFoGSBcK2KQChyNOikFR0leG7DrJaQ/CDiMp9SsjdqnkNBisfyUlgGXMrpacBoMlMFB9GJmwCyanwWARLCkVLFN2+g5cTt8w1WPAZ4Nx2mPia12DSFEFA/B7v/GspN7O27i6ciGqoQf87m/kMhg5VdiAYp+teT3m9bxgsDQGSthAwAYTuQxGTY7GIfsopS4fpavaiaoyIWKDSZYUY4CSwsBvBqcuHyUshRWZrvnt4GRRMYaSwsDuCKfz9snfzAsG1wiKen+gfG4fwmkwCscYRekYJbl9CLc9BpcEikrXCrh9CLc9Rk0Nvkpx+xBug8FvnRTVA1Zs5es2GLidlVbe+Wus7OKzL08U+Ubb/yySx4dfj99+Pn3/+vTww44fdNM+7w4SGcQpxIGvYgiSYfgN/VUK8A==</span><br></pre></td></tr></table></figure><h4 id="控制信号"><a href="#控制信号" class="headerlink" title="控制信号"></a>控制信号</h4><p>10个常量箱中分别给出了0-9对应的7位硬编码，用于控制7个数码管。T信号为0-9的一个数码，通过绿线给进后，10个判断器会根据T的值决定到底输出哪一个X，X在10个逻辑与运算器下输出0/1决定7个数码管的开关。</p><p><img src="/images/Factorio/digit_control.png" alt=""></p><p>蓝图代码:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0eNrNmjtv2zAQx78LZ6cQSUmUDHRIn1unDgGKwJBtJiGgh0HLaY1AQ7dOndq9nbq1XdJ+oib9GKWsxnFjPXiMKmkJIJF3Ov5/R4V38gWahiu+kCJO0fgCiVkSL9H41QVaitM4CPN76XrB0RidC5mu1J0RioMov1HMOPBQNkIinvM3aIyzUYmlSHm0YxYFYXgQBtFix5CUGlY98vGOJc2OR4jHqUgFLyLfXKwn8Sqacqli2loHUqRnEU/F7GCWRFMRB2kilfNFslTWSZw/WXk8wLb9wBmhNRr7VD1ISZLKJJxM+VlwLpSFmnbraqKG5xvzZT5wIuQynWiv5ChfyZLnPnJHyzTIOaiQkwWXQREUOnzxRBkmq3SxArg+RFlWRB/z2TY+nP+RfL6rlFBXRM0UcrYS6eZyA3JnGON/x0l2rHwTPWf55GzH4Q0ZYkCG9kuGtEHmEYgMridD7w7XgdmjWOurihs14Eb65Wa3we1xmzvKgXAj9dwcPW62ATer5zeh2wa4pyBwTj04BgHn1INjeuAcA3C4X3BeG9yegLjRem42hBut52brcXPh3KjXLze3lTflcxA40I5i9WS8ChTMAIXfLwraymHjGQiFXb+HXAgpu56Uq7eHvO2CbpRpwsZusKkzhwpvLmSx8OLfaAnGExGmXALLnjUPw+Q12ki7+nto31ZBx/qKa8rgb58/5zMx57JJBbcpef/6uV/mviwEuElZP7+IFoHchDVGDw0S9qhwuVhPNsJOTmQSTUSsfKBxKlcccnS28uLwVHIe7w15oHOzp0cJW+bZSv9nth7tJqpFzVLV35esVAQMzNXbctvpMFetYeUqqcnV+9R4e5W8ZpGHCZQi6YMiGRhFDKB4BwyoIsQNJ1SsWRNiCsVM+8CMB4aZVGMGdtIaMDdU/mV9uVLMNhSz1Qdme2CYaTXmhi4BBhU1uKFPgDUbBdiBYsZ9YKYDw2xXY24oiPZ3ey3mhpIIazbOsQutBrw+MLsDw+xUY2YNmH0Q5oYexV1vlZgZFLPfB2ZnYJjdasxuA2ZQjxC7DZg1u4TYM67tu8TsDQwzq8Tst7mZ/Zb2MriBw/qAzAYG2QM0cEYNex3W4Bk17PWKT9rgBtBt88PtqgHkGvZ/ykqXUhEwWATSuQi+Yb+27MRXKgIBi0C7zwRDDaimBhSsgdW5BtgihirYmirYYBVw5yow31AER1MEB9wZ97pPhTxKIxVcTRVcsAp+DxvCNBeYpgoMrILbQy4wQxU8TRXu8WWzu9eCoQaln4rUUW7zU9Dxzm9ORygMplyFhbyrr5dXH79ff3p7/fXz1fsvv979uP5w+fvnNzXnXC2iWKeHbeYTZluUEdvLsj/M45Vl</span><br></pre></td></tr></table></figure><h4 id="60-60计数器"><a href="#60-60计数器" class="headerlink" title="*/60/60计数器"></a>*/60/60计数器</h4><p>计数时分秒，暂时不限制小时的上限。<del>大概一定玩不到那么久。</del></p><p><img src="/images/Factorio/digit_counter.png" alt=""></p><p>蓝图代码:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0eNrNl01r4zAQhv/KMmenjWXZTkx72kthm1OOSzH+UHYFtmRkKTQE/feVnDYk3caNEicNGINGmlcjPbygWUNeKdIIyiQka6AFZy0kv9fQ0j8sq2xMrhoCCVBJavCAZbUdlaSgJRGjgtc5ZZnkArQHlJXkFRJfv3hAmKSSko1aN1ilTNU5EWZBn44HDW9NKmd2dyM38sPoLvRgBUmMzS6mRil4lebkb7akJsMse9NJzVzZ5bY2uqCilel/R1lSIZWJbKvYrBiVXMJGv5WZvZBobEd1k4musgQeTA5XslGnqDYrU55iMl0IXqeUGRVIpFBEbzZlpNhW7tufIOXu7dGyu7mCikJR2Q2RfjG56LjFvvb2plH/9MRo653YOzzkCi+8EXiPJ8Cb96BbZFV7MXbBRzifwwhcYeCrwJhfwEfz4VwUfCTRawxHUPta+DiO2JVjcBMcT7HUbEBLBS6kwuNQhK4o0FVQzC5gqdlwlgr7LYXPArWvFR/HMXLlOL4Kx6d9jtPpAByfhuMYuYCKnEChA6BiV1D+TRju8XtBhWeAOkRisq33/dxfoYi3KO7CAzAWtJJEHOgqvnzNKXv3/m5rcdaDS9vWpGtlkp3Ox4Mqy4mpCxC+j8bm+/Hz+ZcJL03h3XnRxMfxFMV4HMQIT7T+B3xTh1w=</span><br></pre></td></tr></table></figure><h4 id="完整时钟实现"><a href="#完整时钟实现" class="headerlink" title="完整时钟实现"></a>完整时钟实现</h4><p><img src="/images/Factorio/digit_clock.png" alt=""></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0eNrlXVtvXMmN/i8C9s3OVpGsm5FdYDKTC7A7eZmXAIFhyHLPuBFdDF1mdxD4v2+3nFXb4mGTPGrpnDr9kADySFSLZLHI72OR/zx5f363+nS9vrw9efPPk/XZ1eXNyZu///PkZv3L5en59t9uf/u0Onlzsr5dXZy8Ork8vdh+dXNxen7++vz04tPJ51cn68sPq/89eRM/v311srq8Xd+uV1+k3H/x27vLu4v3q+vNNzz8/Pb33J5e3r4+u7p4v748vb263gj/dHWz+dmry+2v3ch7HVP6XXp18tvmJ8vv0uYXbX7s9vrq/N371cfTX9ebn9l848/r89vVtfCpf11f395t/mX3we+/4/WHq9uTe3l32z88fv0nfPk1l6uz7Se52cqK2/+7Xn34+k9ab76CzXeur8/u1rdfvtz87OfPr9hfDQ+//MPqbP1hda390fTwRwt/8r/kvNv8tw/rh4/58/r65vadXwVfLHHyJoftVxefTq/vP9mbk99vfubq7vbT3Ripn357d6/ddz9fX128W19upJy8ub2+W31+koJfnYDtm+NXlhj6Gh9/+7Dx0Gs8nInx/mOE8X7aY7qfT89vns12ZDMGeY0BL2KMn57hHP10uFNEjy2x9yA4DfWtrMTs+Orkl+vV6vKxnFiaYOPktXGchY3HHLcfD3jcyGPFbDtu2WuK8CKm+PEZjtuPhztuef9xS08y1LeyytOPW3HamNosbDzmuP3lGW28z4jVliZWryXqi1jiL99aorUDnLYDWqI+wRLKcYIRx6k9/Kmn1+vbjxer2/WZZkc13d+JOoApb1ZbGe92Fo2bs3X1abWx5/2nOvm3EQalk8+SzYYVGPgN9C+zDX4/GhPErVy3/tO89P/vI/SfnPpvSq107997DZKMBokjDAIvZZAfn+1AgPdAgO9AyBEowgiN47w0PuYIoFfj8alnIFmDEo6wSHgpi/z0bGcgeC1CzjOgFLbRGqNohH3ivOwz5sREr33wqScmomIxOaolv42wTGsjevoROvu4OvvHE80EmlGqVJHE7MbrH3LZeo/Xf1hff/nMX0qmQ6H3f/sKuy/jsPvYjMGhjOcsXkwHEcZqoRq14C1OH5QA4VsV0DOWqunbUrUeADP42+Eq1U0UEutJLR+HJF6NBt8GTZwYANpY6mpCs5eZmT3LZlfwCACX1et+q4OVrgzuiAcvH/FCG8nZGnk/8HPVOEHcTyO1AEYtwFj6c8IAkOcVACCOjvtDzjo+7AMaAwCOpVknNHqamdGDaHRQGhWgeIzOo/p+aaLRyR3vwsvn+mODvpHwhORWQpzg6oORWihGLYzmfSc8/ziz80/y+S/7zz8G1/kvSndHMJ7/MrbvYkKj08yMnmSjK9jZUITaY3QFR4NsNHr1xrsd6fxi8S6Pi3YYjdGuuXXQXlwHbWSH6lAsGexyDGPbQCY8/TCz09/k06/08Qz56p7Tr3QYPZYmnX6MYztOJjR6nJnRq2h0fvZeqRS6bHR+j++XJhod3OEu94NnW/tEEN1aKC9/8eFIJRh5T/S2Uz94wkuef5o1qI9yk5iCxqAC/kZ0gT+ooL9MnBggvA3YDydjwlshzMwrUIb8gu/yVqweNasbgV50U71E/cDdaCR70U32UuqF8EYj1YvuPuQ0/a0wM84PZaoXlRc0Q6665/xrb3uaMeh7iV6i6Y0+M54HZaJXu+vpoFc9GW96chO9BP2g3WS8+chN9BL2Q3eTke4mL9FLMH0AmBn8SzLnRwr8Sy74lxT4l4zwL3mJXsLpjT4zopdkdh8Vdp9c7T2o1JNkbO8hN9FLoRu8m4wUJ7mJXordsN1kZLvJy/NSnP74z4znJZnyI6XPg1x9HqT0eZCxz4PcD37D9EafGdNDMrlPCtOTXPAOaW/JjUwPuXlebL3wvMnI85Kb58XaDeSfjDxv8vK8WKc//TMDd0nmeX2nO2ngLVmt6iVysU1v1ZkRuSQTuaQ0bCVXwxYpDVvJ2LCV3EQuln6IXOvb2uQmcjH3gtgnI4+bvDwuTsHY4ax53LRn2IeSeXMzPQ7jLnQ3Je1WMMK7yUvkYp7eLWZG5CSZyE3aKDQXkZMUIicZiZzk5nEx9cPjJiOPm9w8LlI/mH4yMrnJy+QiTR8AZgbvJpnJTQq8m13wblLg3WyEd5OXycU0vdFnxuQmmcnVLvuhszn+rk/G0XHZzeQi9sPkZiOTm91MLkI3oH42ErnZS+QiTn/+Z0bkZpnITUonR/bl+konRzam+tlL5CJMb/SZMTlZJnKzwuRkF5OTlXoyG5mc7CZyMfQC6mfrhGI3j4uxGzI7G8ns7OVxMUx/+mcG/2aZ0ssK/Ftc8G9W4N9ihH+zl8fFOL3RZ8bjZpm8z/mQ93zOB7rn3Twu1H4w/2JkcrObyYXWDZNbjJxf8TK50KY//zNjcnNznP+nnO9o5eeLl8mFKfh5mDWVk2Umt2hUTdKGAtf9A+aLRt5YO3aKm92F3A+OX4zsbnGzu1B6YXeLkd0tXnYX8vQhYWaAboHRIaG4aDzt/BcjjVe83C2U6Y0+M+62yNxtUcJ8IZfRlT6uQkaju7lboH5Q/GJkLYubu4XUD3dbjAx28XK3QNMHgJnB+EWm8YrC3VZXeV8U7rYay/vi5W4hTW/0mRH2RSbsi9KxU1zcbVE6dop17ZebuwXoBsKuRuq2uqlbwG6o22qkbquXugWY/vjPDNKtMnVblTe41cXiVeUNbjWyeNVL3QJOb/SZUbdVpm6LwtdXV5NWUfj6amzSqm7qFkI3CHY1crfVzd1C7IW/rkbqtnqpWwjTn/6ZofhVpm6dIb1o4K2xeKtebhbi9FadGSFfZW625kPG9JoPFNPd3GysvWDVzUhfVTczG1s//HQz8tPNS83GKUi8OGvwtsokXlPA2+aaq9sU8LYZ5+o2L3Mb2/RGnxlzW2U+vinDlGNWmdu03w+UuZzsF4iO4GZuY+mHuW1G1rK5mduY+0Hxm5G/bl7uNubpg8LMAN0m03hN4W6bC9BtCnfbjIBu83K3sUxv9JkR9g1G3wTNxd1qYb8Zudvm5m5j6oe7bUbutrm520jdwPjNWP03L3Ub0/Tnf2bUbZOp26aweM3VsNMUFq8ZG3aal7qNNL3RZwbjN5m6bdqyhOB6hNG0ZQnB+Arj/ht9dsfp7T4zzi4Gmb9p2mbs4OrUaNpm7IBWw7sZ64jd0PaDx2lYDf5qF3ohcQZ9a1gLXhI3wvRRIM4tCuwZwRQ0+Ce4QL+B+K7Ik+OAu8SfgsELs8b9Yih7TK9d/bk+DfljvwG03yA7g7v0j9PHgTA3Z8h7nMG3ED2gZtlmjfD++j5207ExGD2H1eAv8EM/BN99MLfpwVvjhzZ91J8Zxbc5IXsOOmkXfvNFAtIu/GaN8d5KP9TpTZ/nZvrwhAs/Oi8B7XqP1povulu1Q+2H2hs8UsN6cNe+ofXS6jLgfpIWvO3aIU8fCGhugUBu8xo4548Prqu9b+CcK/LkQOCt90OZ3vRpbqanPXeABvtF8N0BGu4XwWp6d+t2KP00NgzercN6cHdvh9wP4TnoX8N68HZwB5o+FMyNAIhtzy2gjN+KEH23gNblDdEaCrxt3iFNb3qcm+nrHtODdgtkn+lBuwWy1fTuZu+Quml0GMyrhtXg7vcO1A8JFo0PmSJ4SeAA0weCucG+sG8Dhy/Eg7ZYqZgt6+3qDji9ZedG7AHuCfFZu92DL8Rrk9jA2tkBbmY7QD+IP1gJfnA3cgfshuCHaNWCu+pLD2l+fLlqZ7Q3WPkf8BKc6SHlhZeLh+nbeNjmFg/3AB+ujvVo5aVhV6SeXq9vP16sbtdnmuXQZ7md4KcZ717TN6utjHdfERib33r1abUx4f1nOPnurz+MsOKfTz67DOXDF0GrLEsVDVRGGAjmZCCEQxjoT04DqdmDjyUENXuwsoRQRxg0zMmg9RD2/MFpTw32RV82CBrsi+ZssI2wZ5yTPbeZ8dMN+senRtDHB6oeNsSC9UrE4DcotTkZ9CA34vdOe2rcPDordY2bRysYi3GEPeuc7HmQC/QPPnui1leLPp4Ntb5atPJsCCPsWWYVcA9hz+9c9sTkPE6aOc2nz0uIU56gLqR514Uo14XoetSKZDWbG9ag1BGsgVYyG9OIYENHXx+jrz5GLXnbDm8UDDQCwCA4+vQbtfQb62EtiOb0ewTgQXj0gAdqgAf63kGhBnig9R0UjgA8KB474KHbsx3YnlYAC0cAHhSOvT5GrT4mZwKu1cdkzdBpBN6B9cjrqRSc6lfMabfWCDQD29GjGRp8TD74GDX4mKzwMbmbCTB3VGiRtdAi96LqMgFOgPPGCUjulEounCBZcQKiEeGIjj5bJ23dIPkKaNLgPbI+YKERgAemowc8iHz20h6dVjlQjgA8EI69nCIN7yAf3kEa3kFWvING4B2IRw9gkfYMnPJhTyRZXwDQCLwD47HXx6ThHeTDO0jDO8iKd9AIvAPDsVdcpOEdyVdxUXUu0hbtmUbgHdCOHO8YOH6v9m6nB8Wc1tOXxu89h8k2psytLkzgWHjrW2grmQ1G7+fuAdZI1ucBCUcEm3z05VTykVVJK38rigYaAWAAHX36nTQAI5XDWjBZAYw0AsCAdPSIVNJGqvgARCYPNHmyQUcAHgDHXk8lDfBIPsAjqSvwrIBHGgF4AB47gJU0vCP58I6k4R3JinekEXgHxGOvj5OGdyQf3pGyc0WlbM8ReAeEY6+Pk7ZOOLvqY3M0zWH0cskeCq1sLbTy+C17MNmA5bnhBDk4div6didKZhvxmCPmo8/Ws5atZ1+2ntVx2NZsPY8APGI5esAj+15TZW1e1Xb1tWCgEYBHTEcPeGRt4lhOh7VgtvZX5xGAR6Rjr6eyVk9lH4CVtXoqWwGsPALviHDs9VTW8I7sq6dycS6IkO05Au+IeOz4VdYA5uzDO7IGMGcr3pHr6L0+MNnkt7lVGiV4Njw4FzhIhhsBbMR47MBGzs4FWwqyYT5nJYzeJdAFsmHdJlBGvPgI9egrquKrqIpaUWXRQCMwjFCOHsPgnSePh6L5trkUdbardZtLGYFhhHz0JXLRSuSSDnski7VELiMwj0DHnoIXLQUvvhK5aCl4sZbIZQTkEdKxQx5FA42LL/EuGmhcrJl5GQF5BDj2zByC8zxp9jQfvxGIRsBjR6iKhjgWH6JRyDnLXrZnHT/DGp6z0vptdX5+9T9fl1tjx1gr3RGA4gDeskMNbu7eb5Rz/2cOzpj7ohESPpcAdux3CsXGyp+lvZlQt6hob2i0NztaTXXvkhv9rta/fHx/dXfvH5t/fYUhvx0yRg3jx5L14anaoD4gkdmrcfwogT6Uoz1zhrQHVqxi/KtgPOLbWb/+I14a68Xa/2eolXEd2mT+SBU1P/6XloZO2ya+bX76VcIwfOJw/EOOPpxK61SGJCI/lcY3X/WhHK0xBLL4sqIm46naXjP+U1Uff5SmnZrBHd5Dlw+2zXGA4eOQx4PSfVhcg9Egi6lS3dUFNxen5+evz08vPu1fULC5nYdFVasoVEU1q6ioiWrBKiqooqJR1G60uCgKrKKqKgqtorIqiqyiiioqWUWRKipbRSVVlNXbSfX2ZvV2Ur29Wb2dNBeFYPV2iqooq7djVUVZvR2bKsrq7VhUUVZvx6yKsno7kirK6u2YVFFWb0dQRVm9HVEVZfV2VF00Wr0d1YMTrd4OqotGq7eDenCi1dtB9fZo9XZQvT1avR1Ub49WbwfV26PV20H19mj1dlC9PVq9HVQXBau3g3pwwOrtUXVRsHp7VA8OWL09qt4OVm+PqreD1duj6qJg9faoHhywentUXRSs3h7VgwNWb4+qi6LV26N6cNDq7UF1UbR6e1APDlq9PaguilZvD+rBQau3B9XbMbvrwSyJKm5RRRJV3aVluQcBhsr+/y+6H+iuEWzXd/s3Of/n9j/f3aw2v+P8aosw3LdtOrCByniTx9gmlCbAA4DNXT33rK0tp/QYu5fWWAAFNxzQt26Y31AUdRPd+EbXutl4yWPdoKgbcAM2fesGGc8h+w26Eai+dROZ34CoG3JDal3fXJWfKc6YydpKbnyub08ipq0s6ia7YdC+dcP8hqqom+IGY/vWDc94xGyQqhtd7ls3jI+nIuqmuTHuvnVTWCxOkm5ScGPafd9c7FZP7F+q6EkpusmErj0psXs+ibd6AjcP0bduuCeJdUVCN93Tt254148cgcjNFPWtG54pi7d6Sm5Crm/dsHo0kaib7Oby+r65uG7YPd/E6j0VN13Ztyex/DCJdUWqbv61b90wv8kikpqam1DuWjeZZTxZPFM5uBnyvv2G1aNJvLlydPP0feuGIfBNzAYzuCn+vs8Uu7myeKtndPcs9H2rM2wws9y5iWhhJndbRt+exNunxboiJ3efSd+64Z4k+012N870rRtWc2UR48nF3QnUt274yyb5Vvf3I/UdnZlu8uN7HoOYO2d/y1XfnsTywyLqpvh7yPrWDe/sEeuK4m+K61o3hdVcRUSZi7/Lr2/dMJS5iHVFQXevYd+6ARaLZd2Qu3lS6ngs/j5MqeOx+PswqyTK34fZJFH+Psz2rH70p2f2I36nixlQ8T9/rD3rhnddFhFHrcHdPfe8fvOH59UN45Ixind6jW7d1K51E+zdcxXc3XNdnyneDyYuVISKbt10HYvZHAKMsm7I3dfTd7xJTDci+lWTWzd9xxuy98rV7H6o/Lx+c/ZxdfaPb/UDj/Tze4d+jBM+MIoYmHn0xK4rrOuIzPucqpzlVLdu+o7IhfmNfLKau5en66iTWNRpIuLV/C/i+76tWFUFYnZsHt+y6+XpO95wzF3Mjpt/ZkHX8aaxqgrEDNA8YAdwEfEmMzSwiUy6eWIQ4CLiTUPmN2J2bB6BBHHRGSCIGaB5slNsi4jIvEelybopbt30HZEz8xsxAzTP3oq0jKjDshyUb/Lm1k3ftxXvT5aqKjRPR9t1FvQdbyrjHKKom+jWTc/xZttR8fhMkagbcHOePcebLcP5WDdZ1I2fD+463hSmmwCibvx8sMC8YvDzwU0SlY1DftMXQQhDA6gTtLeD0t0U8RaKGP6g7oGy2xdKw6LcjOr9p+qXbWaRP0qYEZqnKO50E7uO/CybEllDjG5G9Zn95qUZVYyybtxzbJ7Zb575VowMMxLZH4xuRrXveMPeDWIUs6nonmPTd7yJTDdJjsVuRrXzeEPMb8RM0zwrdqebvuMNY+JTEXVTvGzzM/vNS2CNfF8KRrH2N8/03Wkodq+hLfv+aDmVXK2YRxU/cM6d31ksRwYxLoN7gk3ndxbLkbOsm+jlnPu+sxrLkUE8U+bp2DvddH1nAcuRxVe4aB73/cA59x1vGmfGZN2QWzddxxtgObL4rhTNA9kBlxFvWI4Msm6yWzd9xxuWI4svl9A8Mh/ignLkxjQEYo5s3gQAcUE5MrAcWca87AsO2jLuLNaXiWIeaN/Y0JZxZ7EcuYj3uXkFRaRFxGVkuU6V/Qbcuun7Pmd1J4qsvHlJyAMr3/eZQpbriBO+0bz1ZKeb0DVvxWorFHMd+xqXsox4w5BAcd4lmvfShLKEeLPxBXvHgnnRTkgae29etBOSxt5/vYVmb8fCtuFiuGPhfl12HOxYMO9x2bUZgPBBzWtPdqJQEgVuVh6e1Uv//MyII0PV2N4QJDG/Mu8NedhT1Le2iOVX4rYHNO8N2XkSPqtu/vjSummy3yTvnqLO/Ybdk+JGA7RvCWnL0A2PN0nUTfHuKepcN8ne+2LfEpJfJt58/8y6YThAk2Nxc+um71ud31PVHoHMe0N2nUJ9a4tVv2z/A4q7MdC8N2Snra7vefaeHuWXH+a9IYSL8CSuG3FvCJr3hjxsA+tcNywmiXtD0Lw3hJZRVyRHz5l5bwgto0JNvI9TrCuSv1ex6xwo8T4zEe83bwnBZdQVkdVcKTs8yT0Jpu9bne3GoCDrpnk3pfXtSUw3KO4NwezvWOxaN8AzHlaXidt50LxJBBeSH/L+TrGuMG8SwWXkh5n3MIr5oXmTyK6/s+t7nu1/oCBiHdm9c6/zCMTqiowOT3Jv4ev8lIG9Uzi7t/B17kkMB2JTLjCL+Kt5t8hOW31njJnFJFk37i18nZ8y3qMmZ4zNu72xc91Ue8+5eZMILKPSYBsh9vRVmzeJQFqo34gbaNC8SQRwEfkhm45C8tyJ4p6r2PmZggG/Mb/sMO8WictAzZDppvC3HrK2knf7Zee+xTLGIuL2xT11se/8kOmGxIn2aF5wE5eRAw2cKREjM2/sicvInQuruYpYV5g39sRl5EB8vpT8vsO8sScuI3fGOOA3j7UlVmHV/1Ko64yRTZwieQKMeYdPXAYSjQw/5HOWqoiaVf/boa7veTZ5muRpMOatPnEZaCufyl3FHMi81ScuA7fnM6iqmDubt/qEZdQVfC+L/K7KvM8nLKNC5ZuyqnxzVfebs75v9ccZD4Gc8TS3bvq+1bnfVLsnmTf8hKS9VjMvxAlJe61m3h+ze/hGkih0i0qSKP/LJ+r65RO7yZp4y5u3k+x0k3rWDZuiQzLWat5LsnulQV2/YGHxR9xLgua9JDvdpJ51w/aSkDytwbyXZPcCo+t4w1+nNDE7NO8l2emm73hTmd9IsZjMe0l2HdFdx5vEOzaiqJvo1k3P8YbYXhIiWTfgnmlLC5hpy05WQFFD6NZQ6l5D2xm/j30IRA2Ru0+87zuLe48cl5NbNz3fWduXFo/9RtZNdnf3dn1nsV5eCkXUTXHrpu87i93n4nQAMi/12XWn9n2mGBKW5Fjc3LqhrnVTB/qcBd2YtxQBLiLeFM5miXmgeUsR4CLiDZsVReLLLjJvKYK4oBwZWJYTxRzZvKsI4oJyZDaZhJJ4Z0V/72XXdxbbPEPi9gcybyyKbRH1Q2G5jrjpiswbiyIt4s6qkelGvs+LWzd931nMb8S3gGTeVbTr3On6TFX+akCOxc2tm75jMbvJxZd/ZN5SFMoizhTbNkNFPFPmLUWhLCMWM78Rt1uReUtRSArlTualPiEpjQBk3oGzawTIkqjkFlUkUdnNm+eueSyWC4J4p5s3rOx0U55VNz88c/xhd7q4W4XMu1V2E4r71g2bCAXyvdXck2b71g3nhsXYbN6qsptQ3LduGF6KIl6K/u3cueteFHamxA0QZN6qsptQ3LXfsPei+3SDbr/pWzdg7mEi9G/n7ls3LL9BMb8xb1XZ6abv3I/HYhHrMm9V2U2R7dtveCwWcz/zVhXCZegmO/ymuqfILk03Yl6MzT19uG/dsLyYxLyY/D2Tfeum2fsCyd8zmbvuP4kOv/H3TOYFdASKubB5cxIuI98j3uOWRd34eyP71g3a+//I3xuZu+5VYnWCuI2MzJuTEJfqN2INZd6chMuoE9jGLUry3VTdfaN966Y5dNPcuuk7p2H1JYn1pXlPEi6jhqJqjzfmrUiwDPw88b428Z4yb0Xa6abrO5y9V9x2IEu6Qfek4L79huXF4lYkMm9FgmVwC2zzz9aTJN0k9zTcpelGrKfMW5FgGbUm26ZFSb6niruHv2/dZHsPv3kHEuAicr8YHX7T3N37C8Cz5NcM5r1HsS0ip2E7Q0ncCUXmLUdxGZg53yUmbjki85ajuIw6gW05InH/Cpm3HMVl5MJ8y5G4GYLMW47iMnJhtrdn4x2ibpL7jUff9zbDbOT3rOadRnEZdQJ/P79HN/63QX3rxvE2KPvfBvWtG4YRi9tWKPvfBvWd+zHdZLGGMm8wisvAiNmWHhI3X5F5g1FcBu/C9s5QEfNi8wajsIyaofA3ZWJ+Y95gFJZRM/CZFEWsGcz7isIy8mK++Up+i2jeThTKIvJiCA6/ye4HhNJTPfMyn5C0B4Tm3Te7B4RVEmVNUtJDktIEUebNKrtPJYqK7udpoihwvwIURaH78ZMoitxvzERRyf20RhTlnzQsiiruxwmiKHNPdlJFNfezAEmUefI5qd5unnxOqrebJ5+T6u3myeeoert58jmq3m4eFI6qi5rnaqN6cMxjqFH1dvPUZlS93TzkGDVvT/aZwKiKiu72IFEUuLuwRFHmBoumiiJ3H4soKrnbPkRR2d0lIYoq7qYCUVR1c/CiqOamZSVR9ul+6sGxD8NTXXTE7DhRFLrpJVGUfxqZKCq5iR1RVHbzIKIoP/wriqpulF0UZQYXVW83z+mJqrebx9pE1UXNU2CienDAD4yIosiNP4mi/GW3KMpcpaoHB/xVapVEVbco8VN95e13729uT+9/frDGuRdE8fPmB1brXz6+v7rbQgR/x839lzC8HZL+9VCLvdK3H2NQ+vYDxk2lmTAO/4Zo/A3b62L482Pbfv7N/2D4N+yOy/v1L69X56uz2+v12etPV+erYf+U/pTNZ401vf389tXJ+nZ1sRV4frf6dL2+vN0IOj99vzrf/Nv3//1fm69+XV3f3EuFulF9g0IBC1D9/Pn/AEXCAp8=</span><br></pre></td></tr></table></figure><h2 id="产线"><a href="#产线" class="headerlink" title="产线"></a>产线</h2><p>为了实现标准的<code>3*n</code>物理结构，开始尝试学习混料技术，本章中的模板基本只使用混料技术，且使用蓝色组装机。</p><p>小标题命名规则：&lt;产物名&gt;&lt;组装机数量&gt;</p><h3 id="绿板2"><a href="#绿板2" class="headerlink" title="绿板2"></a>绿板2</h3><p>组装机配比：铜线3，绿板2</p><p>原材料配比：铁板2，铜板3</p><p>测定了5台组装机不同的排序方式，使用了如下的方式，可以获得较高的产量。</p><p>使用时需要往出口处放80个绿板左右以启动设施。</p><p>稳定产量大约在133绿板/min</p><p><img src="/images/Factorio/lvban2.png" alt=""></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0eNrVWt1u5DQUfhWUWxJIHOdvBE/CVqNM4ulYJE7keCqqaqSCkFZwUy5WICG4gl0qLpaLlQDtatt3gU67+xY4yXR+ndR2AGlv2ibxfCfnnM+fzzmdM2OSzVFJMWHG6MxIUZVQXDJcEGNk3F2+WD7//ublL28fX4zec1z3wxyTR+Tm9fXdk8vb735/+8P5m2efL6/Ol49fLi9+Wv785e2Tq9C++fPXu1fXtz9eL/94trx4cfPq6fKb35ZfX755fnX77eu/z794RAzTwElBKmP0yZlR4WMSZ7V5dloibhczlPMVJM7rK5ShhNGC4MRKME3mmBkL/nGSos+MkbM4Mg1EGGYYtWjNxemYzPMJonzBGmcaV8xiNCZVWVBmTVDGuJGyqHDr7pnB8Swn+sAzjdPVX9xQiim336yAC/MAH+ziz/lr0WNa8N+dFsJuC755H4Nizsp57emBRVffo1DGI7jGz1GK57nVJoCHvywy1O9Qa4AgfDybFHNaZyQ6Etjwdn3ApEKU8QcC8KAnWgJkf40cVxXKJxkmx1YeJzNMkAVEBry9t+fwuElBUpQlolYST7jbAlOBeupdmdRj0pH5UN0gGMa1SJkLoI8L0HSgiA6OLc8HR40PjqNKiKiLD0IhOjSorgjBIFY4rrJBfxgrHGWJ8HsVwnSEIuHIq4SnSApllXB1RcJRVwl7YHY0ZGIYAZVVwu6jA2cXcEV8ANIqYavRAahqBBgmEUBZIrxhlACuYoa83gRFpguECYKqfsFBxAOeYt5C3V0MfFnq+YrUU5YHxxnIhT15qMoMM6ErW5bCXTucv1Oc1R8SUt5cmR/zvqKg3DhfRjmBxO8TKUfAHsQa11Y2OKxscxV7EMdVK9hdoLi7D6rCne3NxQLaou3tKnYeB7XgNoNE+Bv5qHtDFhNmJUU+wSRmhYifParIQ8IxOC+z8QTN4hPOw/pTLWs72s4TTNmc31m/RbvCSmYo+bTuORPOEVab22o/zQf7V8w3h1VmMUPbGGCNASQwVvp0gOKuUVwJFHEnffhGcHHU3CekDWdVIzr1D4rS7SYb8yvIs7ZCa655R75YiLLrSevOLmuafbUtJRmaiveZr8hPqKbVbqCIH3Tz3xfz8z6Q/Fm6hppiWrGxIsva/cNLofoiL2Pa7KGR8VHzeGUGkfrAG6e4ag6+EaNztHlKUZyOZzFJ69dhPBjV/or7++3SvEg5hi1PHTfcp47Z+xzsPfe9Lq5tzriYk2aWI1Zzvk9LAkUl2eBuklX1ZKtLXBCvVuqUVKiGGe8kruB7Pl7N4t7fnKqK2AuFhAT7EQaNFADZ9RBIikEkLQZ+VxEi2qLQVj0Ko75KV1zmQke5gAh7leDBmg1uTviUl6xpXar2kTlSJPMKdCCTTxA9Zbz0Pu5XoL++eqrB5a1DuDwdN2fWeEqLfNyWXaNpnFVooa89/USXPeSg8iwG2DLU6KwtIVRiRt3p/v/M2MpdFyk+1pG3PcIJeVEfWCq0gA8oWj9POk8k6OlP7QOZ4hn6Q/4REQjo8CD1Ap0hvpwz4ZDReo8zPRIbDRmu68TP0xp6S8XPcwbMoLXC54EBQ2it6Lkaw2G54MEBE1stV7wBA1u9bPnqk1S52AX6k02t0IX6E0e9yEXqg0CpyPn2gDGYliu+/lhKziOgPS46wIf/drvcNQp5N9tmcc3hq87rdveiCBFqT1i6ED3tmUrwn89UDqdu7wQ9DppyeFjCCnPhD+hrA52+1g8GtEvBg+3SkdkmdLT1JSfTyGIOze+tvs/E7/A+omplLHRgEIEA2m4AYLhY/AOtQnOC</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux-Kernel</title>
      <link href="/2021/07/17/Linux-Kernel/"/>
      <url>/2021/07/17/Linux-Kernel/</url>
      
        <content type="html"><![CDATA[<p>深入理解Linux内核学习笔记</p><span id="more"></span><p>[toc]</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>想要学习Linux内核的契机大抵源于读OS相关的paper时感到力不从心，就正好趁机学习一下素来感兴趣的内核知识。</p><p><del>写下“兴趣”二字后不禁想到日向晶也的论述，兴趣绝不能成为训练的动力，否则遇挫后兴趣消失也就自然放弃了训练；然而学习内核确实也没有什么迫切的压力与强制的要求，随意为之吧</del></p><p>此外，考虑到以往学习知识点时的失败经验，本篇学习笔记大概一定不会系统地梳理全部的知识。阅读时不断梳理知识点虽有一定的合理性，但也确实消耗了读者的经历与耐心，一如阅读外文书籍时频繁地查阅生词，最终使人索然乏味。因而本篇笔记会写的十分随意，只粗略记一些三言两语。</p><h2 id="运行环境"><a href="#运行环境" class="headerlink" title="运行环境"></a>运行环境</h2><p>本机系统为Ubuntu 20.04.2 LTS</p><p>研究的Linux内核为kernel-2.6.11.12版本</p><h2 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h2><p>绪论中从总体的框架介绍了一下操作系统、文件系统与Unix内核相关内容，不予过多赘述。</p><p>一个新学到的内容是<strong>可重入(内核</strong>，这意味着多个进程可以同时在内核下执行。这个特性太过于自然以至于让我一直没有注意到<del>也没有在教材上见过</del>，如果某个进程在内核态中被阻塞被挂起，那么它当然不应该影响到其余进程对CPU的使用。在可重入内核的要求下，内核控制路径就会被交替执行。</p><p><strong>自旋锁</strong>是在多处理器系统中可能采用的一种同步方式。因为信号量操作太慢了，当某些互斥访问时间很短时，使用信号量就很低效。自旋锁本质上就是不断查询是否可用，是一种忙等待，但是在上述场合自旋锁是很有效的。</p><p>内核处理信号有五种默认的方式（终止、终止并核心转储、忽略、挂起、恢复），其中<strong>核心转储(core dump)</strong>是指将执行上下文和进程地址空间中的内容写入一个文件，该文件保存了程序终止前的各种信息，可以使用gdb结合源程序进行调试，用于恢复终止前的案发现场。默认的Linux设置好像是不生成core文件，可以使用<code>ulimit -c</code>查看core允许使用的大小，在文件<code>/proc/sys/kernel/core_pattern</code>中添加一条记录给出core允许使用的大小就可以开启核心转储功能。</p><p>另一个没怎么了解过的是<strong>进程组和登陆会话</strong>。进程组其实就是有一堆进程们，他们之间可能有兄弟关系、父子关系等，使用进程组可以比较统一地管理许多进程。而一个会话则可能包含多个进程组，但只有一个前台进程组。会话也有一个组长，即创建会话的进程。一个会话可以有一个控制终端，也可以没有控制终端，只有会话组长才可以打开控制终端。因而，在<strong>Daemon</strong>的实现中，先创建第一子进程来生成一个新的会话脱离原来的会话与进程组，并成为会话组长，再创建第二子进程成为该会话的成员，以防止其打开终端，这样就能创建一个使用独立的进程组、独立的登陆会话且不是会话组长、父进程是init的守护进程。</p><p>今天大概花了3个小时看这章并整理笔记，明天把2章内存寻址看了。</p><h2 id="内存寻址"><a href="#内存寻址" class="headerlink" title="内存寻址"></a>内存寻址</h2><p>本章主要介绍80x86微处理器的内存寻址方式以及Linux如何利用寻址硬件的。</p><p>在x86系统下，有三种不同的地址：</p><ul><li>逻辑地址。每一个逻辑地址由段和偏移量组成。</li><li>线性地址（也称虚拟地址）。这是一个32位的无符号整数。</li><li>物理地址。用于内存芯片级的内存单元寻址，由32位/36位无符号整数表示。</li></ul><p>内存控制单元（MMU）通过若干硬件电路对地址进行转化，如下图所示。</p><p><img src="/images/addressConvert.png" alt=""></p><p>此外，在多处理器系统中，由于所有CPU共享统一内存，存在一种称为<strong>内存仲裁器</strong>的硬件电路延迟/分配CPU对内存的访问。但是从编程的角度来看，仲裁器由硬件电路管理，是隐藏的。</p><h3 id="硬件中的分段"><a href="#硬件中的分段" class="headerlink" title="硬件中的分段"></a>硬件中的分段</h3><p>80286模型以后，Intel处理器有两种不同的地址转换方式：实地址模式和保护模式。实地址其实就是段寄存器内容左移四位再与偏移地址相加的结果，有效的寻址范围为1MB；而保护模式则是使用段寄存器的高13位作为段选择符，在GDT或LDT中查找相应的段描述符，该描述符会给出32位基址地址，使用该地址与偏移量相加即可寻址4GB的内容。下面我们主要讨论保护模式下的地址转化方式。</p><h4 id="段选择符和段寄存器"><a href="#段选择符和段寄存器" class="headerlink" title="段选择符和段寄存器"></a>段选择符和段寄存器</h4><p>段选择符为16位长的字段，最低2位RPL表示请求者特权级，第3位TI指示该段描述符在GDT中（TI=0）或在LDT中（TI=1）</p><p><img src="/images/segDes.png" alt=""></p><p>为了快速的找到段选择符，处理器提供了6个段寄存器，其唯一目的就是存放段选择符。</p><p>6个寄存器中有3个有特殊用途：</p><ul><li>cs: 代码段寄存器</li><li>ss: 栈段寄存器</li><li>ds: 数据段寄存器</li></ul><p>其余三个作一般用途，可以指向任意的数据段。</p><p>cs寄存器还有一个2位的字段，用于知名CPU当前的特权级。Linux只使用0（内核态）和3（用户态）。</p><h4 id="段描述符"><a href="#段描述符" class="headerlink" title="段描述符"></a>段描述符</h4><p>每个段都由一个8字节的段描述符(Segment Descriptor)表示，它表述了段的特征。段描述符放在全局描述符表（Global Descriptor Table, GDT）或局部描述符表（Local Descriptor Table, LDT）中。</p><p>通常只有一个GDT，而每个进程如果需要附加的段则可以使用LDT。GDT在主存中的地址和大小存放在gdtr控制寄存器中，当前正在使用的LDT则放在ldtr控制寄存器中。</p><p>下图给出段描述符字段的结构与描述。</p><p><img src="/images/SD.png" alt=""></p><p><img src="/images/SD_type.png" alt=""></p><p>Linux使用如下一些描述符的类型：</p><ul><li>代码段描述符。指明一个代码段，可以放在GDT/LDT中，S为1。</li><li>数据段描述符。指明一个数据段，可以放在GDT/LDT中，S为1。栈段是通过一般的数据段实现的。</li><li>任务状态段描述符（TSSD）。指明一个任务状态段，该段用于保存处理器寄存器的内容。只能出现在GDT中，根据进程是否在CPU上运行，Type类型又分别为11/9，S标志为0.</li><li>局部描述符表描述符。该描述符指明的段用于存放LDT，该描述符只存在于GDT中。</li></ul><h4 id="快速访问段描述符"><a href="#快速访问段描述符" class="headerlink" title="快速访问段描述符"></a>快速访问段描述符</h4><p>x86处理器提供一种附加的非编程用的寄存器，专门供6个段寄存器使用，每个寄存器可以存放一个8字节的段描述符。每当一个段选择符被装入段寄存器中，其对应的段描述符就由内存装入到对应的特殊寄存器中。以后针对该段的地址访问就不需要每次都去查描述符表，而直接可以从寄存器中获取相应的地址信息。</p><h4 id="分段单元"><a href="#分段单元" class="headerlink" title="分段单元"></a>分段单元</h4><p>下面说明分段单元如何将逻辑地址转换为线性地址。</p><ul><li>首先检查段选择符的TI位，用于决定描述符在GDT还是LDT中，从对应的gdtr/ldtr中获得描述表的基地址。</li><li>获取段选择符的高13位地址，将该地址乘以8（一个段描述符的大小）后与描述符表的基址相加，即得到当前段的描述符。</li><li>获取描述符内的基址信息，与逻辑地址的偏移量相加即得到了线性地址。</li></ul><p><img src="/images/seg_unit.png" alt=""></p><h3 id="Linux中的分段"><a href="#Linux中的分段" class="headerlink" title="Linux中的分段"></a>Linux中的分段</h3><p>Linux中用户态的所有进程使用同一对相同的代码段和数据段，内核态中的所有进程也使用一对相同的代码段和数据段，下标给出这四个重要段的描述符信息。</p><p><img src="/images/Linux_four_segs.png" alt=""></p><p>可以看出，这四个段的线性地址都从0开始，有$2^{32}-1$的寻址限长，这意味着无论用户态还是内核态的所有进程都可以使用<strong>相同的</strong>逻辑地址。此外也可以发现，LInux下逻辑地址和线性地址总是一致的。</p><h4 id="Linux-GDT"><a href="#Linux-GDT" class="headerlink" title="Linux GDT"></a>Linux GDT</h4><p>一个CPU对应一个GDT，每个GDT有18个段描述符和14个空的、未使用的、保留的描述符。</p><p>下图给出GDT的布局图：</p><p><img src="/images/Linux_gdt.png" alt=""></p><p>18个描述符分别为：</p><ul><li>4个上述的代码段和数据段描述符</li><li>TSS任务状态段</li><li>一个缺省的LDT段描述符，这个段通常为所有进程共享</li><li>3个局部线程存储（Thread-Local Storage）段：这种机制允许多线程应用使用最多3个局部于县城的数据段。</li><li>3个与高级电源管理(AMP)有关的段。</li><li>5个与支持即插即用功能(PnP)的BIOS服务程序有关的段</li><li>内核用于处理“双重错误”异常的特殊TSS段</li></ul><h4 id="Linux-LDT"><a href="#Linux-LDT" class="headerlink" title="Linux LDT"></a>Linux LDT</h4><p>大多数Linux程序不使用LDT，因而内核定义了一个缺省的LDT段。在某些情况下，进程需要创建自己的LDT，如Wine运行面向段的MS/Windows程序。<code>modify_ldt()</code>系统调用允许进程创建自己的LDT。</p><h3 id="硬件中的分页"><a href="#硬件中的分页" class="headerlink" title="硬件中的分页"></a>硬件中的分页</h3><p>从80386开始，所有的x86处理器都支持分页，它通过设置<code>cr0</code>寄存器中的PG标志启用，PG=0时线性地址直接解释成物理地址。</p><p>32位的线性地址分为3个域：</p><ul><li>目录：高10位</li><li>页表：中间10位</li><li>偏移量：最低12位</li></ul><p>线性地址的转化分两步完成，第一次使用页目录表，第二次使用页表。这种二级模式的目的在于减少每个进程页表所需要RAM的数量。</p><p>正在使用的页目录的物理地址存放在控制寄存器<code>cr3</code>中，目录字段决定页目录中的目录项，而目录项指向相应的页表。</p><p>页目录项和页表项有相同的结构，都包含如下的字段：</p><p><img src="/images/page1.png" alt=""></p><p><img src="/images/page2.png" alt=""></p><h4 id="拓展分页"><a href="#拓展分页" class="headerlink" title="拓展分页"></a>拓展分页</h4><p>从奔腾模型开始，x86处理器引入了拓展分页，允许页框大小为<strong>4MB</strong>， 用于将大段连续的线性地址转换为对应的物理地址。在这种情况下，内核可以节省内存并保留TLB项。</p><p>在拓展分页下，分页单元将32位划分为10/22，页目录项的字段也基本相同，除了：</p><ul><li>Page Size标志必须设置</li><li>20位的物理地址只有最高10位有意义</li></ul><p>通过设置<code>cr3</code>的PSE标志能够使得拓展分页与常规分页共存。</p><h4 id="硬件保护方案"><a href="#硬件保护方案" class="headerlink" title="硬件保护方案"></a>硬件保护方案</h4><p>若页表项中的<code>User/SUpervisor</code>标志位为0，则只有内核态可以对页寻址，不然则总能对页寻址。</p><p>另外，与段的3种存储权限（读写执行）不同，对页只有两种权限（读写）。当<code>Read/Write</code>为0时，则该页只读，否则可读可写。</p><h4 id="物理地址拓展（PAE）分页机制"><a href="#物理地址拓展（PAE）分页机制" class="headerlink" title="物理地址拓展（PAE）分页机制"></a>物理地址拓展（PAE）分页机制</h4><p>为了拓展32位x86所支持的RAM容量，Intel在处理器上将引脚数从32提高到了64，使得最大的寻址能力达到64GB。但是相应的也需要一种分页机制，将32位的线性地址转换到36位的物理地址才能真正地增加可用的地址。</p><p>PAE所采取的主要变化其实是将页表项从32位变成了64位，同时引入了一个新的页表级别：页目录指针表（PDPT），它由4个64位的表项组成，每一项均能够指向一个页目录。由于PDPT存放在RAM的前4GB中，且按照32位对齐，因而使用27位即可对PDPT进行寻址，这27位地址就放在<code>cr3</code>控制寄存器中。</p><p>每次解释32位地址时，首先从<code>cr3</code>中获取到PDPT的地址，接下来取高两位选择一个表项，接下来根据9位选择一个目录项，再根据9位选择一个表项，最终12位决定页内偏移。</p><p>借助<code>cr3</code>或PDPT，就可以使用32位的虚拟地址来寻址36位的物理地址了。其<strong>本质</strong>其实就是动态的变化<code>cr3</code>中的地址，完成地址的扩充。</p><p>由于只有内核能够修改进程的页表，所以PAE允许内核使用64GB的RAM，但是用户态态的进程仍然只能使用4GB的物理空间。</p><h4 id="64位系统中的分页"><a href="#64位系统中的分页" class="headerlink" title="64位系统中的分页"></a>64位系统中的分页</h4><p>一般都使用多级分页的方式来避免页表中存在过多的表项</p><h4 id="硬件高速缓存"><a href="#硬件高速缓存" class="headerlink" title="硬件高速缓存"></a>硬件高速缓存</h4><p>高速缓存单元由两部分组成，一个是高速缓存控制器，一个是SRAM高速缓存。书中对于具体的描述不详，博客<a href="https://zhuanlan.zhihu.com/p/340573903">https://zhuanlan.zhihu.com/p/340573903</a> 给出了详细的说明<del>顺便偷图</del>。</p><p>Cache引入了一个新的单位“行”，一行由几十个连续的字节组成，是DRAM和SRAM交换的单位。</p><p>高速缓存中存储着许多行数据，高速缓存控制器则存放着一个表项数组，每个表项对应高速缓存中的一行。</p><p>每个表项有标签和描述高速缓存行状态的几个标志。</p><p>当<strong>访问一个主存单元</strong>时，首先将地址划分为标记、组索引、块偏移三个结构。通过组索引来选择cache中的某一个组，接下来遍历该组中所有的行信息，检查该行的标签是否与地址中的标签相同，如果相同则cache命中，根据块偏移即可访问到对应的主存单元。</p><p>下图给出了一个生动的过程。</p><p><img src="/images/cache.jpg" alt=""></p><p>另一个有趣的问题是，cache中存的地址是虚拟地址还是物理地址？</p><p>博客<a href="https://zhuanlan.zhihu.com/p/107096130">https://zhuanlan.zhihu.com/p/107096130</a> 排版的很漂亮：</p><p><a href="https://blog.csdn.net/hx_op/article/details/89244618">https://blog.csdn.net/hx_op/article/details/89244618</a></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kernel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ECNU夏令营记</title>
      <link href="/2021/07/13/ECNU%E5%A4%8F%E4%BB%A4%E8%90%A5%E8%AE%B0/"/>
      <url>/2021/07/13/ECNU%E5%A4%8F%E4%BB%A4%E8%90%A5%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>华东师范大学计算机营游记</p><span id="more"></span><p><strong>7月12日线上宣讲</strong></p><p>华师老师自己也说学校的计算机专业小而专，一看全都是ML、CV相关，爬了爬了。。结果听到大数据系统方向是几乎唯一一个涉及到计算机组成、OS、算法的，加上老师、团队成果听起来很牛，让人心动。。</p><p><strong>7月13日ECNU OJ机试 &amp; 团队交流</strong></p><p>上午机试，虽然难度比BUAA难了不止一点，但是体验却还不错，毕竟总算有点像是个ACM类的比赛了。。（有专门的OJ、及时反馈结果、CSL出题等等。。。）</p><p>一共有四题，稍微记录一下：</p><p><strong>A</strong></p><p><del>A数据点70分很小，暴力模拟能拿70分的题，写起来也特别简单。。但是我纠结了很久的题意。。甚至还去问答区提问了。。之后考虑了很久发现可能是自己算法考虑的太NAIVE了。。所以觉得题目描述有问题。。</del></p><p>给出n个数字，保证严格单调增，进行q次区间加法，保证每次操作后序列总是严格单调增，每次操作后问是否有$a[i] = i$成立, $n \leq 10^7, q \leq 10^3$</p><p>一直naive地认为大概没有负数。。那么一旦某个数达到$i$后再往后就永远不可能符合条件了。。就用了个傻逼set乱搞。。结果WA2。。while1交题debug了一下发现有负数。。</p><p>重新考虑后仔细关注了单调增的条件。。使用区间加、单点查的线段树维护所有点的信息，每次询问的时候在1-n上二分，检查是否有值等于下标的即可，复杂度$O(qlog^2n)$。。最开始线段树上维护了每个点的真实值。。一直T后仔细考量发现这样复杂度是$O(nlogn)$的（建树）。。就改为只维护每次的增量，这样复杂度仅有$O(qlogn)$，非常好，顺利通过最后3个点。</p><p><strong>B</strong></p><p>傻逼贪心题。。开局A题受挫WA2后看了B题2min切了</p><p><strong>C</strong></p><p>给出$n$个值$a_i$，表示$i$处有高度$a_i$的平台，现在从p点倒s滴水，问最后平衡情况下所有平台的高度，$n \leq 10^3, s \leq 10^6$. </p><p>另外有如下规定：</p><ul><li>最左和最右有无限高的屏障，水不会流出去</li><li>如果某个平台上的水既可以向左流动，又可以向右流动，那么他会均分向左向右</li><li>结果如果有小数，使用最简带分数的表示形式输出</li></ul><p>很毒瘤啊。。。最开始想暴力模拟，但是一看复杂度$O(ns)$，还可能常数不小。。那么可能就要一批批地灌水。。头就大起来了。。好在一看数据集60%是一个山谷的情况，就写了一发针对山谷骗分的算法。。最后出下来40分，不知道为啥挂了20分。。还挺难受。。</p><p><strong>D</strong></p><p><a href="http://218.28.19.228:8081/cogs/problem/problem.php?pid=pNNySmVeU">NOI1997原题</a></p><p>最开始特别naive地写了个trie…后来发现自己太傻逼了想挫了。。而且虽然样例里没有<code>?</code>，最终答案可能输出<code>?</code>…罢了，直接跑了</p><p>比赛结束前交了个样例输出骗了2分就跑了。。</p><p>最终242分。。感觉也差不多了。。再给我点时间可能可以C题多想想多骗点分出来、D题多想想说不定就出来了。。不管了。。退役ACM选手半夜还得再复习复习OS计组线代啥的。。</p><p><del>上午机试的时候手机开着热点&amp;摄像机&amp;中目会议，靠着充电宝🐶着10%的电，电脑开着录屏&amp;摄像机&amp;中目会议，还在编译运行我的挫比代码，滚烫。。编译一个程序要tm10s，急死人了。。</del></p><p>下午在系统组和老师进行了交流。。听了很多别的同学的发言。。有些让人忍俊不禁。。偷偷记录一些语录，太好笑了</p><blockquote><p>沙老师：</p><p>你是一个好学生，很老实，很好。（憋笑</p><p>你有没有女朋友？你为什么没有女朋友，因为你没有信心</p><p>…</p><p>学生：</p><p>我最大的优点就是比较自信</p><p>我有个特点，打过的比赛都能拿到奖</p><p>…</p></blockquote><p>感觉下午的交流各侧重于表达自我，为什么要进系统组。。遇到个金牌选手，还有一两位银牌选手，还遇到个山东科技的常州老乡。。中间我提到我平时都使用linux系统老师进而疑问不可能吧（估计也是知道linux没有腾讯会议）又谈到icpc都是ubuntu系统，只有国内的比赛才是windows。。（看来老师只知icpc名不知其具体内容）还趁机问了我fork懂不懂，好在之前socket编程学过fork。。问了想不想来上海，问了操作系统自我感觉如何，还阐述了ACM比赛和今后系统组要做的工作的区别。。大概还问了许多别的，但是也就感觉是随意交流交流想法，再说已经被之前的同学老师的交流逗乐了，所以倒是蛮轻松的。。。不知道自己的表述能不能打动老师，只知道老师最后交流结束后连说了几个“好！好，好！”，又确认了一下我的名字。。结合前几位同学的交流情况，便可推知老师的好好好含义因人而异，但我想这次的好好好大抵应当还算是个不错的结果。。</p><p><strong>7月14日面试</strong></p><p>上午面试。。考前看了很久的计算机组成原理，结果就复习到了面试题，针不戳，不然又要战死沙场了。。</p><p>先是让我自我介绍一下，中英文都可以，考虑到用中文势必要介绍的井井有条。。就掏出了之前的英文讲稿随意背诵了一下。。</p><p>接下来让我阅读一段英文文章并进行翻译，是与软件工程有关的，几乎没有生词，阅读起来总体感觉还行，翻译下来虽然磕磕绊绊的但总体感觉还行。。</p><p>接下来随机给了2个问题，一个是解释一下容器和虚拟机，一个是说明一下支持向量机。。。容器老实说自己不知道，虚拟机回答的也很差劲，回答了利用主机的资源等等运行其余的操作系统。。回答的很垃圾。。向量机不知道，因为报的方向是大数据系统方向，不了解ML。。</p><p>由于报的大数据系统老师又问了几个组成原理的问题。。一个是Cache的组织结构。。正好考前看了全相连、组相连那几个内容。。Lucky。。说明了一下这几种方式的优缺点。。还问了我L1L2L3级Cache分别使用的什么方式，我不会，只能跟老师说L1要求性能而不过多考虑消耗，所以使用全相连，而L3则相反所以是直接相连。。老师又问了我一遍L3，听他语气后我就改口说L3是组相连，因为确实组相连可能更有道理一些。。随后老师问我了不了解三级Cache。。我老实说没有专门的学过。。只了解大概的概念。。</p><p>随后老师问了我想不想来上海，问了家在哪里，问了为什么选择ECNU不选择其余高校（排名不够），问了专业排名和保研率，问了为什么想要选择系统方向（兴趣+能力）。。</p><p>总体而言面试的内容很少，比BUAA的要少很多，只问了一部分组成原理的知识，其余的专业课根本不问，感觉上还是十分轻松的。。。</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>BUAA夏令营记</title>
      <link href="/2021/07/12/BUAA%E5%A4%8F%E4%BB%A4%E8%90%A5%E8%AE%B0/"/>
      <url>/2021/07/12/BUAA%E5%A4%8F%E4%BB%A4%E8%90%A5%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>北航夏令营记</p><p><del>好像大概一定可能有保密要求？但是也只是在手册里看到一眼，老师也没有专门说，况且我这个博客门可罗雀，就大概更新一下吧</del></p><span id="more"></span> <p>百味杂陈大抵如此…</p><p>仍然记得那个早晨，7月1日的早晨，通宵肝完编译原理实验报告，4点多钟想rush完BUAA的申请表再睡觉，结果忽然意识到早上的考试可能来不及复习了，下午三点多钟卡着截止时间才填表交好。本来甚至都没想报BUAA，2k字的研究计划让人望而却步，最终抱着随意海海的心态结果成了少数几个过了初审的夏0营。</p><p><strong>机试</strong></p><p>机试很简单，一道模拟一道MST基础题，没有评测结果以及不能出考场很头大，<del>差点憋死在座位上</del></p><p><strong>面试</strong></p><p>面试大抵也很简单。。然而就跟模电考试类似，只要学过就能轻易解答，像我这种不好好学习的人就啥也不会。。</p><p>先是1-10随机抽了一道政治题，随意口胡了15秒就FIN了，胡不出更多了。</p><p>然后应该是自我介绍，英文口胡了2分钟左右之后就开始问问题了。。</p><p>问了几个数学题，啥是特征值特征向量（定义不记得了，说了个计算公式和实际的意义FIN），啥是极大线性无关组，啥是可微可导连续（具体也不记得了，随意说了点记得的内容），应该还有些啥但不太记得了</p><p>问了个算法，啥是dijstra，感觉答的不算好，因为要口述算法流程，还是比较费口力的</p><p>问了操作系统，进程上下文？切换进程时OS会干啥？我只能口胡回收资源分配资源。。</p><p>问了计组，单指令周期变成流水线的话指令时间会变化吗？我学的不好啊我也不会做。。感觉上是不会，只是把多条指令交错地一起运行，这样回答后老师又问我确定吗。。。我想不到特殊的情况只能说确定。。</p><p>问了网络，其实更偏向于网络安全，https和http有啥区别。。安全导论考试前和密码学考试前全都没看这块内容，啥也不懂，面试的时候自然也不会，只说了个SSL，具体有啥我不知道（老师非常失望，认为这是网安的基础。。。）一石三鸟，遇到一个GG一个。让我模拟一下传输我的申请表到北航的情况，公私钥加密，如何保证公钥确实是北航的（回答了第三方可信机构有证书，但是不太确定是否正确）。。还问了https和shttp的区别？？？只能老实说从来没听说过shttp…问了如何抓包？抓互联网上的包？我只回答了wireshark可以抓本地的包，但是不太清楚怎么抓外部的包，再说外部的包应该也只能抓未加密的。。。还问了ARP欺骗，但我具体不太记得了，就随口答了一下修改IP包的源地址。。老师惊讶的问我就这么简单吗。。。后来发现完全答错了qaq</p><p>问了区块链，我就把大数据安全隐私的两个实验大概说了下。。因果关系不记得了，可能是看了我的实验内容问我区块链的。。<del>老实说，我不是很懂区块链。。</del></p><p>问了平时遇到感兴趣的会如何查阅资料。。回答了国内的CSDN等博客论坛和国外的谷歌学术直接查论文。。</p><p>根据简历上“精通”c/c++编程，问了我几个C/C++问题。。C++中类中static函数有啥用。。想了半天不知道。。只知道java是可以直接用类来调用，但是C++可能不太一样，就没敢说。。其实后来查阅好像是跟java一样。。看我不会老师又问C中static有啥用。。emm。。不会啊但是估计是一样的。。但我啥也没说 毕竟都不会。。又问了我父类子类。。子类创建实例时会不会掉用父类的构造函数。。。我口胡了不会。。我确实不会。。几乎没有学过C++类有关知识。。问了堆和栈的区别，分别有什么变量放在上面（全局、局部）。。问了malloc放在哪里（回答了堆，猜对了）</p><p>总而言之，感觉答下来特别的差。。没有掌握应该掌握的知识。。当时感觉就是凉了。。</p><p>最终结果出后居然是优营。。真的太神秘了。。一看名单，含电量极高，110人优营有10人西电的。。</p><p>🤤🤤</p><p>和网络的夏老师取得了联系，直接签好了双向意愿表(<del>听另一个CV方向老师的同学说甚至还有组织面试？？真是热门啊</del>)，也咨询了手下的学长，感觉还蛮不错的。。但是一考虑到本校甚至有可能会丧失保研资格。。。。</p><p>再看吧qaq</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>BMP-FS</title>
      <link href="/2021/05/28/BMP-FS/"/>
      <url>/2021/05/28/BMP-FS/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><p>BMP文件格式初探</p><p>实现BMP文件的放缩</p><span id="more"></span><p>搜索资料时找到，笑死。</p><blockquote><p>此为课程设计的第四题,这道题体现了大作业的精髓:在抄中知道，在抄中学习，在抄中苟且。</p></blockquote><h1 id="BMP-文件结构"><a href="#BMP-文件结构" class="headerlink" title="BMP 文件结构"></a>BMP 文件结构</h1><p>一般的情况如下所示，摘自<a href="https://en.wikipedia.org/wiki/BMP_file_format#File_structure">wiki</a></p><div class="table-container"><table><thead><tr><th style="text-align:center">Structure name</th><th style="text-align:center">Optional</th><th style="text-align:center">Size</th><th style="text-align:center">Purpose</th><th style="text-align:center">Comments</th></tr></thead><tbody><tr><td style="text-align:center">Bitmap file header</td><td style="text-align:center"><strong>No</strong></td><td style="text-align:center">14 bytes</td><td style="text-align:center">To store general information about the bitmap image file</td><td style="text-align:center">Not needed after the file is loaded in memory</td></tr><tr><td style="text-align:center">DIB header</td><td style="text-align:center"><strong>No</strong></td><td style="text-align:center">Fixed-size (7 different versions exist)</td><td style="text-align:center">To store detailed information about the bitmap image and define the pixel format</td><td style="text-align:center">Immediately follows the Bitmap file header</td></tr><tr><td style="text-align:center">Extra bit masks</td><td style="text-align:center">Yes</td><td style="text-align:center">3 or 4 <a href="https://en.wikipedia.org/wiki/DWORD">DWORDs</a><a href="https://en.wikipedia.org/wiki/BMP_file_format#cite_note-AlphaBitFields-6">[6]</a> (12 or 16 bytes)</td><td style="text-align:center">To define the pixel format</td><td style="text-align:center">Present only in case the DIB header is the BITMAPINFOHEADER and the Compression Method member is set to either BI_BITFIELDS or BI_ALPHABITFIELDS</td></tr><tr><td style="text-align:center">Color table</td><td style="text-align:center">Semi-optional</td><td style="text-align:center">Variable size</td><td style="text-align:center">To define colors used by the bitmap image data (Pixel array)</td><td style="text-align:center">Mandatory for <a href="https://en.wikipedia.org/wiki/Color_depth">color depths</a> ≤ 8 bits</td></tr><tr><td style="text-align:center">Gap1</td><td style="text-align:center">Yes</td><td style="text-align:center">Variable size</td><td style="text-align:center">Structure alignment</td><td style="text-align:center">An artifact of the File offset to Pixel array in the Bitmap file header</td></tr><tr><td style="text-align:center">Pixel array</td><td style="text-align:center"><strong>No</strong></td><td style="text-align:center">Variable size</td><td style="text-align:center">To define the actual values of the pixels</td><td style="text-align:center">The pixel format is defined by the DIB header or Extra bit masks. Each row in the Pixel array is padded to a multiple of 4 bytes in size</td></tr><tr><td style="text-align:center">Gap2</td><td style="text-align:center">Yes</td><td style="text-align:center">Variable size</td><td style="text-align:center">Structure alignment</td><td style="text-align:center">An artifact of the ICC profile data offset field in the DIB header</td></tr><tr><td style="text-align:center">ICC color profile</td><td style="text-align:center">Yes</td><td style="text-align:center">Variable size</td><td style="text-align:center">To define the color profile for color management</td><td style="text-align:center">Can also contain a path to an external file containing the color profile. When loaded in memory as “non-packed DIB”, it is located between the color table and Gap1.<a href="https://en.wikipedia.org/wiki/BMP_file_format#cite_note-DIBHeaderTypes-7">[7]</a></td></tr></tbody></table></div><p>一般来说，现在获取到的BMP文件的DIB头都是第五代(BITMAPV5HEADER)，长124字节；但是针对本实验而言，只需要极少的一些信息，因而只保留40字节，剩余84字节读进来不与使用。</p><p>调色盘在24位(RGB各占一个字节)时不需要，因而像素矩阵的偏移就是14 + 124</p><p>因而在本实验中，BMP结构仅有三部分：</p><ul><li>BMP file header</li><li>DIB header</li><li>pixel array</li></ul><h2 id="BMP-file-header"><a href="#BMP-file-header" class="headerlink" title="BMP file header"></a>BMP file header</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">u_int16_t</span> bfType;   </span><br><span class="line">    <span class="keyword">u_int32_t</span> bfSize;   </span><br><span class="line">    <span class="keyword">u_int16_t</span> bfReserved1;   </span><br><span class="line">    <span class="keyword">u_int16_t</span> bfReserved2;   </span><br><span class="line">    <span class="keyword">u_int32_t</span> bfOffBits;  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        PRINT_FONT_GRE;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;BmpFileHeader\n&quot;</span>);</span><br><span class="line">        PRINT_ATTR_REC;</span><br><span class="line">        <span class="built_in">fflush</span>(stdout);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;bfType: %d\n&quot;</span>, bfType);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;bfSize: %d kb\n&quot;</span>, bfSize);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;bfReservered1, 2: %d %d\n&quot;</span>, bfReserved1, bfReserved2);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;bfOffBits: %d\n&quot;</span>, bfOffBits);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;BmpFileHeader;</span><br></pre></td></tr></table></figure><p>该头固定14字节</p><h2 id="DIB-header"><a href="#DIB-header" class="headerlink" title="DIB header"></a>DIB header</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span>&#123;</span>  </span><br><span class="line">    <span class="keyword">u_int32_t</span> biSize;   </span><br><span class="line">    <span class="keyword">u_int32_t</span> biWidth;   </span><br><span class="line">    <span class="keyword">u_int32_t</span> biHeight;   </span><br><span class="line">    <span class="keyword">u_int16_t</span> biPlanes;   </span><br><span class="line">    <span class="keyword">u_int16_t</span> biBitCount;   </span><br><span class="line">    <span class="keyword">u_int32_t</span> biCompression;   </span><br><span class="line">    <span class="keyword">u_int32_t</span> biSizeImage;   </span><br><span class="line">    <span class="keyword">u_int32_t</span> biXPelsPerMeter;   </span><br><span class="line">    <span class="keyword">u_int32_t</span> biYPelsPerMeter;   </span><br><span class="line">    <span class="keyword">u_int32_t</span> biClrUsed;   </span><br><span class="line">    <span class="keyword">u_int32_t</span> biClrImportant;   </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 由于目前一般dedaodeBMP文件均采用第5代DIBHEADER格式，因而DIBHEADER信息长为124字节</span></span><br><span class="line"><span class="comment">     * 我们额外吸收掉这些额外的信息，在本实验中不予考虑它们。</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">u_int8_t</span> foo[<span class="number">84</span>];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        PRINT_FONT_GRE;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;DibHeader\n&quot;</span>);</span><br><span class="line">        PRINT_ATTR_REC;</span><br><span class="line">        <span class="built_in">fflush</span>(stdout);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;biSize: %d\n&quot;</span>, biSize);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;biWidth: %d\n&quot;</span>, biWidth);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;biHeight: %d\n&quot;</span>, biHeight);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;biPlanes(always 1): %d\n&quot;</span>, biPlanes);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;biBitCount: %d\n&quot;</span>, biBitCount);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;biCompression: %d\n&quot;</span>, biCompression);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;biSizeImage: %d\n&quot;</span>, biSizeImage);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;biXPelsPerMeter: %d\n&quot;</span>, biXPelsPerMeter);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;biYPelsPerMeter: %d\n&quot;</span>, biYPelsPerMeter);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;biClrUsed(0 if 2^biBitCount): %d\n&quot;</span>, biClrUsed);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;biClrImportant(0 if all important): %d\n&quot;</span>, biClrImportant);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;DibHeader;</span><br></pre></td></tr></table></figure><h2 id="pixel-array"><a href="#pixel-array" class="headerlink" title="pixel array"></a>pixel array</h2><p>对于缩放后的图片的每一个像素点，将其按对应比例映射回原图，在原图中假设该投影点被四个点$A,B,C,D$构成的矩形包围，那么就利用这四个点的颜色构造出该点的颜色。</p><p><img src="/images/Screenshot from 2021-05-28 23-01-55.png" alt=""></p><p>使用博客<a href="https://blog.csdn.net/gtyinstinct/article/details/116144674">位图图像文件缩放（c++）</a>提及的<strong>双线性插值</strong>：</p><script type="math/tex; mode=display">F(X) = dxdyF(B)+(1-dx)(1-dy)F(D)+(1-dx)dyF(a)+dx(1-dy)F(C)</script><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p><strong>坑点： </strong> BMP文件的<strong>width</strong>应当是4的倍数！</p><p>最开始虽然注意到了4的倍数，但是是使得height是4的倍数，导致最后的satou酱不仅是灰色的，还是倾斜的。经过好一番调试才发现是width，也就是列。</p><p><img src="/images/Screenshot from 2021-05-28 23-04-45.png" alt=""></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;rqdmap.h&quot;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(2)   <span class="comment">//对齐</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">u_int16_t</span> bfType;   </span><br><span class="line">    <span class="keyword">u_int32_t</span> bfSize;   </span><br><span class="line">    <span class="keyword">u_int16_t</span> bfReserved1;   </span><br><span class="line">    <span class="keyword">u_int16_t</span> bfReserved2;   </span><br><span class="line">    <span class="keyword">u_int32_t</span> bfOffBits;  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        PRINT_FONT_GRE;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;BmpFileHeader\n&quot;</span>);</span><br><span class="line">        PRINT_ATTR_REC;</span><br><span class="line">        <span class="built_in">fflush</span>(stdout);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;bfType: %d\n&quot;</span>, bfType);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;bfSize: %d kb\n&quot;</span>, bfSize);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;bfReservered1, 2: %d %d\n&quot;</span>, bfReserved1, bfReserved2);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;bfOffBits: %d\n&quot;</span>, bfOffBits);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;BmpFileHeader;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span>&#123;</span>  </span><br><span class="line">    <span class="keyword">u_int32_t</span> biSize;   </span><br><span class="line">    <span class="keyword">u_int32_t</span> biWidth;   </span><br><span class="line">    <span class="keyword">u_int32_t</span> biHeight;   </span><br><span class="line">    <span class="keyword">u_int16_t</span> biPlanes;   </span><br><span class="line">    <span class="keyword">u_int16_t</span> biBitCount;   </span><br><span class="line">    <span class="keyword">u_int32_t</span> biCompression;   </span><br><span class="line">    <span class="keyword">u_int32_t</span> biSizeImage;   </span><br><span class="line">    <span class="keyword">u_int32_t</span> biXPelsPerMeter;   </span><br><span class="line">    <span class="keyword">u_int32_t</span> biYPelsPerMeter;   </span><br><span class="line">    <span class="keyword">u_int32_t</span> biClrUsed;   </span><br><span class="line">    <span class="keyword">u_int32_t</span> biClrImportant;   </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 由于目前一般dedaodeBMP文件均采用第5代DIBHEADER格式，因而DIBHEADER信息长为124字节</span></span><br><span class="line"><span class="comment">     * 我们额外吸收掉这些额外的信息，在本实验中不予考虑它们。</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">u_int8_t</span> foo[<span class="number">84</span>];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        PRINT_FONT_GRE;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;DibHeader\n&quot;</span>);</span><br><span class="line">        PRINT_ATTR_REC;</span><br><span class="line">        <span class="built_in">fflush</span>(stdout);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;biSize: %d\n&quot;</span>, biSize);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;biWidth: %d\n&quot;</span>, biWidth);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;biHeight: %d\n&quot;</span>, biHeight);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;biPlanes(always 1): %d\n&quot;</span>, biPlanes);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;biBitCount: %d\n&quot;</span>, biBitCount);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;biCompression: %d\n&quot;</span>, biCompression);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;biSizeImage: %d\n&quot;</span>, biSizeImage);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;biXPelsPerMeter: %d\n&quot;</span>, biXPelsPerMeter);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;biYPelsPerMeter: %d\n&quot;</span>, biYPelsPerMeter);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;biClrUsed(0 if 2^biBitCount): %d\n&quot;</span>, biClrUsed);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;biClrImportant(0 if all important): %d\n&quot;</span>, biClrImportant);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;DibHeader;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pixel</span>&#123;</span></span><br><span class="line">    <span class="keyword">u_int8_t</span> c[<span class="number">3</span>];</span><br><span class="line">    pixel <span class="keyword">operator</span> * (<span class="keyword">double</span> x)&#123;</span><br><span class="line">        pixel res; res.c[<span class="number">0</span>] = res.c[<span class="number">1</span>] = res.c[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) res.c[i] = c[i] * x;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    pixel <span class="keyword">operator</span> +(<span class="keyword">const</span> pixel &amp;b)&#123;</span><br><span class="line">        pixel res; res.c[<span class="number">0</span>] = res.c[<span class="number">1</span>] = res.c[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) res.c[i] = c[i] + b.c[i];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">prt</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;&lt;%d, %d, %d&gt;\n&quot;</span>, c[<span class="number">0</span>], c[<span class="number">1</span>], c[<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> height, width;</span><br><span class="line">pixel *rawPic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> newHeight, newWidth;</span><br><span class="line">pixel *toPic;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">convert</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">    i = <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">min</span>(i, n));</span><br><span class="line">    j = <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">min</span>(j, m));</span><br><span class="line">    <span class="keyword">return</span> i * m + j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prt</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *to)</span></span>&#123;</span><br><span class="line">    FILE *out = <span class="built_in">fopen</span>(to, <span class="string">&quot;wb+&quot;</span>);</span><br><span class="line">    BmpFileHeader.bfOffBits = <span class="number">14</span> + <span class="number">40</span>;</span><br><span class="line">    BmpFileHeader.bfSize = BmpFileHeader.bfOffBits + newHeight * newWidth * <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    DibHeader.biSize = <span class="number">40</span>;</span><br><span class="line">    DibHeader.biWidth = newWidth;</span><br><span class="line">    DibHeader.biHeight = newHeight;</span><br><span class="line">    <span class="built_in">fwrite</span>(&amp;BmpFileHeader, <span class="built_in"><span class="keyword">sizeof</span></span>(BmpFileHeader), <span class="number">1</span>, out);</span><br><span class="line">    <span class="built_in">fwrite</span>(&amp;DibHeader, DibHeader.biSize, <span class="number">1</span>, out);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; newHeight; i++) <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; newWidth; j++)</span><br><span class="line">        <span class="built_in">fwrite</span>(&amp;toPic[<span class="built_in">convert</span>(i, j, newHeight, newWidth)], <span class="built_in"><span class="keyword">sizeof</span></span>(pixel), <span class="number">1</span>, out);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;      </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argc != <span class="number">4</span> &amp;&amp; argc != <span class="number">2</span>)&#123;</span><br><span class="line">        PRINT_FONT_RED;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot; usage: ./main bmpFrom ratio bmpto&quot;</span>);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot; usage: ./main bmpFile&quot;</span>);</span><br><span class="line">        PRINT_ATTR_REC;</span><br><span class="line">        <span class="built_in">fflush</span>(stdout);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    FILE *in = <span class="built_in">fopen</span>(argv[<span class="number">1</span>], <span class="string">&quot;rb&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fread</span>(&amp;BmpFileHeader, <span class="number">1</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(BmpFileHeader), in);</span><br><span class="line">    <span class="built_in">fread</span>(&amp;DibHeader, <span class="number">1</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(DibHeader), in);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argc == <span class="number">2</span>)&#123;</span><br><span class="line">        BmpFileHeader.<span class="built_in">show</span>();</span><br><span class="line">        DibHeader.<span class="built_in">show</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 考虑到24色RGB颜色无调色盘，接下来的信息就是像素点信息</span></span><br><span class="line"><span class="comment">     * 这一点也可以从:</span></span><br><span class="line"><span class="comment">     *  bfOffBits(138) = BmpFileHeader(14) + biSize(124)得以印证</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line"></span><br><span class="line">    height = DibHeader.biHeight;</span><br><span class="line">    width = DibHeader.biWidth;</span><br><span class="line">    rawPic = (pixel*)<span class="built_in">malloc</span>(height * width * <span class="built_in"><span class="keyword">sizeof</span></span>(pixel));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; height; i++) <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; width; j++)</span><br><span class="line">        <span class="built_in">fread</span>(rawPic + <span class="built_in">convert</span>(i, j, height, width), <span class="number">1</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(pixel), in);</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">double</span> ratio; <span class="built_in">sscanf</span>(argv[<span class="number">2</span>], <span class="string">&quot;%lf&quot;</span>, &amp;ratio);</span><br><span class="line">    ratio /= <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    newHeight = ratio * height;</span><br><span class="line">    <span class="comment">// newHeight = (newHeight + 3) / 4 * 4;</span></span><br><span class="line">    newWidth = ratio * width;</span><br><span class="line">    newWidth = (newWidth + <span class="number">3</span>) / <span class="number">4</span> * <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// newWidth = 600;</span></span><br><span class="line">    toPic = (pixel*)<span class="built_in">malloc</span>(newHeight * newWidth * <span class="built_in"><span class="keyword">sizeof</span></span>(pixel));</span><br><span class="line">    <span class="built_in">memset</span>(toPic, <span class="number">0</span>, newHeight * newWidth * <span class="built_in"><span class="keyword">sizeof</span></span>(pixel));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; newHeight; i++) <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; newWidth; j++)&#123;</span><br><span class="line">        <span class="comment">// double _i = i * height / newHeight, _j = j * width / newWidth;</span></span><br><span class="line">        <span class="keyword">double</span> _i = i / ratio, _j = j / ratio;</span><br><span class="line">        <span class="keyword">int</span> ni = _i, nj = _j;</span><br><span class="line">        <span class="keyword">double</span> dx = _i - ni, dy = _j - nj;</span><br><span class="line"></span><br><span class="line">        pixel B = rawPic[<span class="built_in">convert</span>(ni + <span class="number">1</span>, nj + <span class="number">1</span>, height, width)];</span><br><span class="line">        pixel D = rawPic[<span class="built_in">convert</span>(ni, nj, height, width)];</span><br><span class="line">        pixel A = rawPic[<span class="built_in">convert</span>(ni + <span class="number">1</span>, nj, height, width)];</span><br><span class="line">        pixel C = rawPic[<span class="built_in">convert</span>(ni, nj + <span class="number">1</span>, height, width)];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        toPic[<span class="built_in">convert</span>(i, j, newHeight, newWidth)] = \</span><br><span class="line">            (B * dx * dy) + (D * (<span class="number">1</span> - dx) * (<span class="number">1</span> - dy)) + (A * (<span class="number">1</span> - dx) * dy) + (C * dx * (<span class="number">1</span> - dy));</span><br><span class="line">        </span><br><span class="line">    &#125;   </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="built_in">prt</span>(argv[<span class="number">3</span>]);</span><br><span class="line">    <span class="built_in">fclose</span>(in);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><del>最后放一张satou(逃</del></p><p><img src="/images/satou.bmp" alt=""></p>]]></content>
      
      
      
        <tags>
            
            <tag> BMP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>qko-gym</title>
      <link href="/2021/04/02/qko-gym/"/>
      <url>/2021/04/02/qko-gym/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><span id="more"></span><h1 id="Day1"><a href="#Day1" class="headerlink" title="Day1"></a>Day1</h1><h2 id="hdu6643"><a href="#hdu6643" class="headerlink" title="hdu6643"></a><a href="https://vjudge.net/contest/318115#problem/J">hdu6643</a></h2><p>因为例题不仅有点分治还涉及到了树上依赖背包的算法，才发现自己并不太会树形背包的若干优化算法，故学习。</p><h3 id="树形背包"><a href="#树形背包" class="headerlink" title="树形背包"></a>树形背包</h3><p><a href="https://www.acwing.com/problem/content/description/10/">模板题</a></p><p>给出一颗依赖树，询问总重量限定下可能获得的最大价值。</p><p>物品的数量和重量的限制均不超过100</p><p>有不同的做法，复杂度也不同。</p><h4 id="向上合并"><a href="#向上合并" class="headerlink" title="向上合并"></a>向上合并</h4><p>随意采取$O(nm^2)$的算法即可在树上合并。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> manx = <span class="number">1e2</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, W, v[maxn], w[maxn];</span><br><span class="line"><span class="keyword">int</span> dp[maxn][maxn];</span><br><span class="line">star edge[maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> head[maxn], top = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    edge[top].to = v;</span><br><span class="line">    edge[top].next = head[u];</span><br><span class="line">    head[u] = top++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//dp[i][j]表示i子树中重量为j下的最大价值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> par)</span></span>&#123;</span><br><span class="line">    dp[u][w[u]] = v[u];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; ~i; i = edge[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> to = edge[i].to; <span class="keyword">if</span>(to == par) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(to, u);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = W; j &gt;= w[u]; j--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = j; k &gt;= w[u]; k--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[u][k] != <span class="number">-1</span> &amp;&amp; dp[to][j - k] != <span class="number">-1</span>)</span><br><span class="line">                    dp[u][j] = <span class="built_in">max</span>(dp[u][j], dp[u][k] + dp[to][j - k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="comment">// Fastin; </span></span><br><span class="line">    <span class="built_in">clr</span>(head, <span class="number">-1</span>); <span class="built_in">clr</span>(dp, <span class="number">-1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;W);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x, y, z; <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;x, &amp;y, &amp;z); <span class="keyword">if</span>(z == <span class="number">-1</span>) z = <span class="number">0</span>;</span><br><span class="line">        w[i] = x; v[i] = y;<span class="keyword">const</span> <span class="keyword">int</span> manx = <span class="number">1e2</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, W, v[maxn], w[maxn];</span><br><span class="line"><span class="keyword">int</span> dp[maxn][maxn];</span><br><span class="line">star edge[maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> head[maxn], top = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="comment">// printf(&quot;%d %d\n&quot;,树形背包 u, v);</span></span><br><span class="line">    edge[top].to = v;</span><br><span class="line">    edge[top].next = head[u];</span><br><span class="line">    head[u] = top++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//dp[i][j]表示i子树中重量为j下的最大价值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> par)</span></span>&#123;</span><br><span class="line">    dp[u][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; ~i; i = edge[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> to = edge[i].to; <span class="keyword">if</span>(to == par) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= W; i++) dp[to][i] = dp[u][i];</span><br><span class="line">        <span class="built_in">dfs</span>(to, u);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = W; i &gt;= w[to]; i--) <span class="keyword">if</span>(dp[to][i - w[to]] != <span class="number">-1</span>)</span><br><span class="line">            dp[u][i] = <span class="built_in">max</span>(dp[u][i], dp[to][i - w[to]] + v[to]);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="comment">// Fastin; </span></span><br><span class="line">    <span class="built_in">clr</span>(head, <span class="number">-1</span>); <span class="built_in">clr</span>(dp, <span class="number">-1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;W);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x, y, z; <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;x, &amp;y, &amp;z); <span class="keyword">if</span>(z == <span class="number">-1</span>) z = <span class="number">0</span>;</span><br><span class="line">        w[i] = x; v[i] = y;</span><br><span class="line">        <span class="built_in">add</span>(z, i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>; <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= W; i++) ans = <span class="built_in">max</span>(ans, dp[<span class="number">0</span>][i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">add</span>(z, i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>; <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= W; i++) ans = <span class="built_in">max</span>(ans, dp[<span class="number">0</span>][i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="向下传递"><a href="#向下传递" class="headerlink" title="向下传递"></a>向下传递</h4><p>在向下传递的更新背包过程时，dp数组的含义有了些许的变化。此时$dp[i][j]$表示选取i节点的子树<strong>且不允许选取</strong>i本身、总重量为j的最大价值。</p><p>将所有孩子的背包信息存在父节点的dp数组中，但不包含父亲自身的信息，每次传递、回收都只涉及到所有的儿子节点。因而在使用这种方法时，一定要使用一个 <font color="#dd0000"> 超级源点    </font>来统一所有的信息！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> manx = <span class="number">1e2</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, W, v[maxn], w[maxn];</span><br><span class="line"><span class="keyword">int</span> dp[maxn][maxn];</span><br><span class="line">star edge[maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> head[maxn], top = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    edge[top].to = v;</span><br><span class="line">    edge[top].next = head[u];</span><br><span class="line">    head[u] = top++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//dp[i][j]表示i子树中重量为j下的最大价值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> par)</span></span>&#123;fun</span><br><span class="line">    dp[u][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; ~i; i = edge[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> to = edge[i].to; <span class="keyword">if</span>(to == par) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= W; i++) dp[to][i] = dp[u][i];</span><br><span class="line">        <span class="built_in">dfs</span>(to, u);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = W; i &gt;= w[to]; i--) <span class="keyword">if</span>(dp[to][i - w[to]] != <span class="number">-1</span>)</span><br><span class="line">            dp[u][i] = <span class="built_in">max</span>(dp[u][i], dp[to][i - w[to]] + v[to]);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="comment">// Fastin; </span></span><br><span class="line">    <span class="built_in">clr</span>(head, <span class="number">-1</span>); <span class="built_in">clr</span>(dp, <span class="number">-1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;W);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x, y, z; <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;x, &amp;y, &amp;z); <span class="keyword">if</span>(z == <span class="number">-1</span>) z = <span class="number">0</span>;</span><br><span class="line">        w[i] = x; v[i] = y;</span><br><span class="line">        <span class="built_in">add</span>(z, i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>; <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= W; i++) ans = <span class="built_in">max</span>(ans, dp[<span class="number">0</span>][i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h5><p><a href="https://www.cnblogs.com/chdy/p/10095783.html">树上依赖背包总结</a></p><h4 id="dfs序优化"><a href="#dfs序优化" class="headerlink" title="dfs序优化"></a>dfs序优化</h4><p>我们记录树的dfs序列，以及每个节点及其子树的大小。</p><p>有了这样的两个信息，我们就可以得到如下的转移方程</p><p>$dp[i][j] = max(dp[i + size[list[i]]][j], dp[i + 1][j - w[i]] + v[i])$</p><p>第一项表示完全不选这一棵子树，第二项则表示选这个子树并进行转移。</p><p>非常的精妙。</p><h5 id="参考博客压缩"><a href="#参考博客压缩" class="headerlink" title="参考博客压缩"></a>参考博客压缩</h5><p><a href="https://note.youdao.com/ynoteshare1/index.html?id=07619acf27a64381650dbb9dc2000f68&amp;type=note">先序遍历优化树形背包</a></p><h3 id="乘积压缩"><a href="#乘积压缩" class="headerlink" title="乘积压缩"></a>乘积压缩</h3><p>当转移之间的关系不是加法而是乘法时，如果使用一般的方式空间利用密度较低，可以考虑使用一种压缩的方式达到$O(\sqrt W)$的状态空间。</p><p>具体来说，设置$dp[i]$表示乘积$\prod a_i$满足关系 $\frac {W}{\prod a_i}=i$ 的某价值。</p><p>从x到xy转移时即为从dp[W / x]到dp[W / x / y]转移。</p><h4 id="AC下"><a href="#AC下" class="headerlink" title="AC下"></a>AC下</h4><p>在本题中，利用点分治限制树的深度，每次暴力遍历子树，复杂度$O(nlogn)$</p><p>在遍历子树时，记录当前根下每个子树的大小以及dfn序列。</p><p>有了上述两个信息，我们就可以更新依赖背包。</p><p>本题要计数的是连通块的个数，而不是平常的最大背包价值，因而在dp转移时有所不同。</p><p>$dp[i][j]$由<strong>两部分</strong>构成，一部分是dfn[i]节点本身子树构成的总重量为j的计数方案，另一部分递归地继承dfs树上i的<strong>右兄弟</strong>的若干信息。因而除了根节点的dp数组为其真实情况，其余节点的dp数组均有一些继承右兄弟而来的计数方案，仅在前一个dfn元素就是其父亲时将这些贡献统一地传递给父亲。</p><p>接下来用到乘积压缩即可，写的比较丑，将一一映射的关系进行保存，每次仅仅对这$\sqrt W$个可能的状态进行转移即可。</p><p>基本的思路就是这些，把自己坑了一下午的点是最开始写的时候认为getroot后sove(root)时，当前连通块内每个节点的子树大小就是getroot处理出来的大小。这显然是错误的，一旦getroot换根后，子树大小显然也会发生改变，应该重新计数！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e3</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxe = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> K =  <span class="number">2e3</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, W;</span><br><span class="line"><span class="keyword">int</span> head[maxn], top = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> w[maxn];</span><br><span class="line">star edge[maxe &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    edge[top].to = v;</span><br><span class="line">    edge[top].next = head[u];</span><br><span class="line">    head[u] = top++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> mx[maxn], root, vis[maxn], S, sze[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getroot</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> par)</span></span>&#123;</span><br><span class="line">    sze[now] = <span class="number">1</span>; mx[now] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[now]; ~i; i = edge[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> to = edge[i].to; <span class="keyword">if</span>(vis[to] || to == par) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">getroot</span>(to, now);</span><br><span class="line">        sze[now] += sze[to];</span><br><span class="line">        mx[now] = <span class="built_in">max</span>(mx[now], sze[to]);</span><br><span class="line">    &#125;</span><br><span class="line">    mx[now] = <span class="built_in">max</span>(mx[now], S - mx[now]);</span><br><span class="line">    <span class="keyword">if</span>(mx[now] &lt; mx[root]) root = now;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dfn[maxn], cnt = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> par)</span></span>&#123;</span><br><span class="line">    dfn[cnt++] = now; sze[now] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = haed[now]; ~i; i = edge[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> to = edge[i].to; <span class="keyword">if</span>(vis[to] || par == to) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(to, now);</span><br><span class="line">        sze[now] += sze[to];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ll ans = <span class="number">0</span>;</span><br><span class="line">ll dp[maxn][K];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line"><span class="keyword">int</span> mp[K * K];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> now)</span></span>&#123;</span><br><span class="line">    cnt = <span class="number">0</span>; <span class="built_in">dfs</span>(now, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= cnt; i++) <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; vec.<span class="built_in">size</span>(); j++) dp[i][j] = <span class="number">0</span>;</span><br><span class="line">    dp[cnt][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = cnt - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="keyword">int</span> u = dfn[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; vec.<span class="built_in">size</span>(); j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(vec[j] / w[u])&#123;</span><br><span class="line">                <span class="keyword">int</span> pos = mp[vec[j] / w[u]];</span><br><span class="line">                </span><br><span class="line">                dp[i][pos] += dp[i + <span class="number">1</span>][j];</span><br><span class="line">                dp[i][pos] %= M;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i][j] += dp[i + sze[u]][j];</span><br><span class="line">            dp[i][j] %= M;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (itn)vec.<span class="built_in">size</span>(); i++) ans = (ans + dp[<span class="number">0</span>][i]) % M;</span><br><span class="line">    ans = (ans + M - <span class="number">1</span>) % M;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sove</span><span class="params">(<span class="keyword">int</span> now)</span></span>&#123;</span><br><span class="line">    vis[now] = <span class="number">1</span>; </span><br><span class="line">    <span class="built_in">fun</span>(now);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[now]; ~i; i = edge[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> to = edge[i].to; <span class="keyword">if</span>(vis[to]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        S = sze[to]; root = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">getroot</span>(to, now);</span><br><span class="line">        <span class="built_in">sove</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// Fastin; </span></span><br><span class="line">    TTT&#123;</span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">clr</span>(head, <span class="number">-1</span>); top = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;W);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scnaf</span>(<span class="string">&quot;%d&quot;</span>, w + i);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> u, v; <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">            <span class="built_in">add</span>(u, v); <span class="built_in">add</span>(v, u);</span><br><span class="line">        &#125;</span><br><span class="line">        vec.<span class="built_in">clear</span>(); <span class="built_in">clr</span>(mp, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= W; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> res = W / i; </span><br><span class="line">            <span class="keyword">if</span>(vec.<span class="built_in">empty</span>() || *vec.<span class="built_in">rbegin</span>() != res) vec.<span class="built_in">push_back</span>(res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vec.<span class="built_in">size</span>(); i++) mp[vec[i]] = i;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        root = <span class="number">0</span>;</span><br><span class="line">        S = mx[<span class="number">0</span>] = n;</span><br><span class="line">        <span class="built_in">clr</span>(vis, <span class="number">0</span>); <span class="built_in">clr</span>(dp, <span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">getroot</span>(<span class="number">1</span>, <span class="number">0</span>); <span class="built_in">sove</span>(root);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树形背包 </tag>
            
            <tag> 乘积压缩 </tag>
            
            <tag> 点分治 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>arc-116</title>
      <link href="/2021/03/28/arc-116(%E5%9D%91)/"/>
      <url>/2021/03/28/arc-116(%E5%9D%91)/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><span id="more"></span><p><del>自以为A了一道精妙的DP题结果被第二道同样思想的DP卡死</del></p><h1 id="D-总和给定下进行NIM必败态计数"><a href="#D-总和给定下进行NIM必败态计数" class="headerlink" title="D 总和给定下进行NIM必败态计数"></a>D 总和给定下进行NIM必败态计数</h1><p>给出n、m，表示总共有n堆可空石堆$ \{a_i\}$，要求满足$\sum a_i = m, \bigoplus a_i=0$，查询这样的序列的个数。</p><p>感觉上可以称之为非常经典的题目。</p><p>设置dp状态：dp[i]表示n堆石子和为i，异或和为0的序列数量。</p><p>状态转移为：</p><p><script type="math/tex">dp[2x + k] = \sum dp[x] * (^n_k)</script>，k取遍范围内的偶数。</p><p>这个状态的转移本质上是用一些更小的情况不重不漏地刻画新的状态。如果当前已知dp[x]，将这n堆石子的二进制表示全部左移一位，再枚举n个最低位有多少个1，就是和为$2*x+k$的一种构造情况。</p><p>这种思想跟用最小的素因子来刻画数字之间转化关系有着异曲同工之妙，但我暂时想不到什么形而上的表达形式来统一地刻画这种思考方式，故留坑。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">5e3</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">C</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">    m = <span class="built_in">min</span>(m, n - m);</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">        ans = ans * <span class="built_in">qp</span>(i, M - <span class="number">2</span>, M) % M;</span><br><span class="line">        ans = ans * (n + <span class="number">1</span> - i) % M;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll dp[maxn];</span><br><span class="line">ll c[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// Fastin;</span></span><br><span class="line">    <span class="keyword">int</span> n, m; <span class="built_in">scnaf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) c[i] = <span class="built_in">C</span>(n, i);</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &amp; <span class="number">1</span>) dp[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j + j &lt;= i &amp;&amp; j + j &lt;= n; j++)&#123;</span><br><span class="line">                dp[i] += c[<span class="number">2</span> * j] * dp[i / <span class="number">2</span> - j] % M;</span><br><span class="line">                dp[i] %= M;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// prt(dp, m + 1, 1);</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, dp[m]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博弈论 </tag>
            
            <tag> DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>test</title>
      <link href="/2021/03/24/test%E5%9B%BE%E7%89%87/"/>
      <url>/2021/03/24/test%E5%9B%BE%E7%89%87/</url>
      
        <content type="html"><![CDATA[<p>支持图片了！</p><p>在目录/images下插入图片即可！</p><p>eg:</p><p><img src="/images/1.png" alt="1"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>linux多线程</title>
      <link href="/2021/03/23/linux%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
      <url>/2021/03/23/linux%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><p>在linux下，Pthread是一套通用的线程库，由POSIX提出，具有较好的移植性。</p><p>使用头文件<code>&lt;pthread.h&gt;</code></p><span id="more"></span><h1 id="线程基本操作"><a href="#线程基本操作" class="headerlink" title="线程基本操作"></a>线程基本操作</h1><h2 id="线程的创建与退出"><a href="#线程的创建与退出" class="headerlink" title="线程的创建与退出"></a>线程的创建与退出</h2><h3 id="pthead-create"><a href="#pthead-create" class="headerlink" title="pthead_create"></a>pthead_create</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_create</span><span class="params">(<span class="keyword">pthread_t</span> *thread, <span class="keyword">pthread_attr_t</span> * attr, <span class="keyword">void</span> *(*start_routine)(<span class="keyword">void</span> *), <span class="keyword">void</span> *arg)</span></span>;</span><br></pre></td></tr></table></figure><p>传入参数：thread为线程标识符，attr为线程属性设置，start_routine为线程函数起始地址，arg为传给start_routine的参数。</p><p>返回值：0成功，-1失败。</p><h3 id="pthread-exit"><a href="#pthread-exit" class="headerlink" title="pthread_exit"></a>pthread_exit</h3><p>线程可以通过主动调用该函数结束自身。</p><p>值得注意不能使用<code>exit</code>来结束当前<strong>线程</strong>，因为exit会终止<strong>进程</strong>，终止该进程中所有线程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_exit</span><span class="params">(<span class="keyword">void</span> *retval)</span></span></span><br></pre></td></tr></table></figure><p>传入参数：retval为调用者线程的返回值。</p><h3 id="pthread-join"><a href="#pthread-join" class="headerlink" title="pthread_join"></a>pthread_join</h3><p>该函数用于将当前线程挂起，值得被等待的线程结束为止，当函数返回时，被等待线程的资源就被收回。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_join</span> <span class="params">((<span class="keyword">pthread_t</span> th, <span class="keyword">void</span> 参考资料**thread_return))</span></span></span><br></pre></td></tr></table></figure><p>传入参数：th为等待线程的标识符，thread_return为用户定义的指针，用于存储被等待线程的返回值(不为NULL)时。</p><h2 id="修改线程的属性资源"><a href="#修改线程的属性资源" class="headerlink" title="修改线程的属性资源"></a>修改线程的属性资源</h2><p>参考资料：<a href="https://blog.csdn.net/baobingji/article/details/84285951">多线程属性pthread_attr详解</a></p><p>在thread_create函数中，我们可以自定义线程的属性。线程主要有如下的一些属性：绑定属性、分离属性、堆栈地址、堆栈大小、优先级。默认的属性是非绑定、非分离、1M的堆栈、与父进程优先级相同。</p><h3 id="pthread-attr-init"><a href="#pthread-attr-init" class="headerlink" title="pthread_attr_init"></a>pthread_attr_init</h3><p>线程属性的设置通常先调用该函数进行初始化，之后再调用相应的属性设置函数进行设置。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_init</span><span class="params">(<span class="keyword">pthread_attr_t</span> *attr)</span></span></span><br></pre></td></tr></table></figure><p>传入参数: attr线程属性</p><p>返回值：成功0，失败-1</p><h3 id="pthread-attr-setscope"><a href="#pthread-attr-setscope" class="headerlink" title="pthread_attr_setscope"></a>pthread_attr_setscope</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_getscope</span><span class="params">( <span class="keyword">const</span> <span class="keyword">pthread_attr_t</span> * attr, <span class="keyword">int</span> * scope )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_setscope</span><span class="params">( <span class="keyword">pthread_attr_t</span>*, <span class="keyword">int</span> scope )</span></span>;</span><br></pre></td></tr></table></figure><p>传入参数：</p><ul><li>attr线程属性</li><li>scope：PTHREAD_SCOPE_SYSTEM 绑定(系统级竞争资源)，PTHREAD_SCOPE_PROCESS 非绑定(进程内竞争资源)</li></ul><h3 id="pthread-attr-setdetachstate"><a href="#pthread-attr-setdetachstate" class="headerlink" title="pthread_attr_setdetachstate"></a>pthread_attr_setdetachstate</h3><p>线程的分离状态决定一个线程以什么方式结束自己。默认情况下为非分离，此时原有的线程等待新线程的结束，只有当pthread_join返回时，新线程才算终止。而在分离状态下，新线程一旦运行结束马上释放资源。</p><p>需要注意，在<strong>分离状态</strong>下，如果某一个进程运行的飞快，在pthread_create函数返回前就终止了，它终止后就可能将线程号和系统资源给其他线程使用，这时调用pthread_create就可能返回错误的线程号。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_setdetachstate</span><span class="params">(<span class="keyword">pthread_attr_t</span> *attr, <span class="keyword">int</span> detachstate)</span></span></span><br></pre></td></tr></table></figure><p>detachstate: PTHREAD_CREATE_DETACHED 分离， PTHREAD _CREATE_JOINABLE 非分离</p><h3 id="调度策略的获取-设置"><a href="#调度策略的获取-设置" class="headerlink" title="调度策略的获取/设置"></a>调度策略的获取/设置</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_getschedpolicy</span><span class="params">(<span class="keyword">const</span> <span class="keyword">pthread_attr_t</span> *, <span class="keyword">int</span> * policy)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_setschedpolicy</span><span class="params">(pthread_attr_*, <span class="keyword">int</span> policy)</span></span></span><br></pre></td></tr></table></figure><p>传入参数：policy为调度策略，有若干种可能的情况：</p><ul><li>SCHED_FIFO</li><li>SCHED_RR (轮转法)</li><li>SHCED_OTHER</li></ul><p>前两种方法均支持优先级的使用，优先级从1-99，数值越大优先级越高。</p><h3 id="优先级的获取-设置-最值查询"><a href="#优先级的获取-设置-最值查询" class="headerlink" title="优先级的获取/设置/最值查询"></a>优先级的获取/设置/最值查询</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_getschedparam</span><span class="params">(<span class="keyword">const</span> <span class="keyword">pthread_attr_t</span> *,struct sched_param *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_setschedparam</span><span class="params">(<span class="keyword">pthread_attr_t</span> *,<span class="keyword">const</span> struct sched_param *)</span></span>;</span><br></pre></td></tr></table></figure><p>默认的结构大概是这样</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_param</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> sched_priority;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以通过如下两个函数获取系统支持的优先级的最值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sched_get_priority_max</span><span class="params">( <span class="keyword">int</span> policy )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sched_get_priority_min</span><span class="params">( <span class="keyword">int</span> policy )</span></span>;</span><br></pre></td></tr></table></figure><h1 id="线程访问控制"><a href="#线程访问控制" class="headerlink" title="线程访问控制"></a>线程访问控制</h1><p>由于线程共享进程资源，因而需要考虑资源访问的问题。</p><h2 id="mutex互斥锁"><a href="#mutex互斥锁" class="headerlink" title="mutex互斥锁"></a>mutex互斥锁</h2><h3 id="互斥锁的类型"><a href="#互斥锁的类型" class="headerlink" title="互斥锁的类型"></a>互斥锁的类型</h3><p>参考资料 <a href="https://blog.csdn.net/qq_42169059/article/details/90600257">九、Linux下线程互斥锁类型及属性</a></p><ul><li><p>PTHREAD_MUTEX_NORMAL：<strong><font color="#dd0000"> 标准互斥锁：第一次上锁成功，第二次上锁会阻塞。</font></strong><br>描述:<br>此类型的互斥锁不会检测死锁。如果线程在不首先解除互斥锁的情况下尝试重新锁定该互斥锁，则会产生死锁。尝试解除由其他线程锁定的互斥锁会产生不确定的行为。如果尝试解除锁定的互斥锁未锁定，则会产生不确定的行为。</p></li><li><p>PTHREAD_MUTEX_ERRORCHECK：<font color="#dd0000"> <strong>检错互斥锁：第一次上锁成功，第二次上锁会出错。</strong></font></p><p>描述:<br>此类型的互斥锁可提供错误检查。如果线程在不首先解除锁定互斥锁的情况下尝试重新锁定该互斥锁，则会返回错误。如果线程尝试解除锁定的互斥锁已经由其他线程锁定，则会返回错误。如果线程尝试解除锁定的互斥锁未锁定，则会返回错误。</p></li><li><p>PTHREAD_MUTEX_RECURSIVE：<font color="#dd0000"><strong>递归互斥锁：第一次上锁成功，第二次上锁也会成功，内部计数。</strong></font><br>描述:操作操作<br>如果线程在不首先解除锁定互斥锁的情况下尝试重新锁定该互斥锁，则可成功锁定该互斥锁。 与 PTHREAD_MUTEX_NORMAL 类型的互斥锁不同，对此类型互斥锁进行重新锁定时不会产生死锁情况。多次锁定互斥锁需要进行相同次数的解除锁定才可以释放该锁，然后其他线程才能获取该互斥锁。如果线程尝试解除锁定的互斥锁已经由其他线程锁定，则会返回错误。 如果线程尝试解除锁定的互斥锁未锁定，则会返回错误。</p></li><li><p>PTHREAD_MUTEX_DEFAULT：<font color="#dd0000"><strong>默认互斥锁：同标准的互斥锁</strong></font><br>描述:<br>如果尝试以递归方式锁定此类型的互斥锁，则会产生不确定的行为。对于不是由调用线程锁定的此类型互斥锁，如果尝试对它解除锁定，则会产生不确定的行为。对于尚未锁定的此类型互斥锁，如果尝试对它解除锁定，也会产生不确定的行为。允许在实现中将该互斥锁映射到其他互斥锁类型之一。</p></li></ul><h3 id="对互斥锁的操作"><a href="#对互斥锁的操作" class="headerlink" title="对互斥锁的操作"></a>对互斥锁的操作</h3><h4 id="互斥锁的创建"><a href="#互斥锁的创建" class="headerlink" title="互斥锁的创建"></a>互斥锁的创建</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_init</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex, <span class="keyword">const</span> <span class="keyword">pthread_mutexattr_t</span> *mutexattr)</span></span></span><br></pre></td></tr></table></figure><p>mutexattr缺省时默认创建快速互斥锁（PTHREAD_MUTEX_DEFAULT）</p><h4 id="互斥锁的操作"><a href="#互斥锁的操作" class="headerlink" title="互斥锁的操作"></a>互斥锁的操作</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_lock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_trylock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_unlock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex,)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_destroy</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex,)</span></span></span><br></pre></td></tr></table></figure><p>（望文生义即可.jpg）</p><h2 id="信号量线程控制"><a href="#信号量线程控制" class="headerlink" title="信号量线程控制"></a>信号量线程控制</h2><p>功能参见OS教材即可。</p><h3 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h3><p><code>#include &lt;semaphore.h&gt;</code></p><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_init</span><span class="params">(<span class="keyword">sem_t</span> *sem, <span class="keyword">int</span> pshared, <span class="keyword">unsigned</span> <span class="keyword">int</span> value)</span></span></span><br></pre></td></tr></table></figure><p>传入参数：</p><ul><li>sem信号量</li><li>pshared决定信号量能在几个进程间共享，由于目前linux还不能实现进程间信号量的共享，所以该值只能取1</li><li>value信号初始值</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_wait</span><span class="params">(<span class="keyword">sem_t</span> *sem)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_trywait</span><span class="params">(<span class="keyword">sem_t</span> *sem)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_post</span><span class="params">(<span class="keyword">sem_t</span> *sem)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_getvalue</span><span class="params">(<span class="keyword">sem_t</span> *sem)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_destroy</span><span class="params">(<span class="keyword">sem_t</span> *sem)</span></span></span><br></pre></td></tr></table></figure><p>望文生义即可。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>socket</title>
      <link href="/2021/03/23/socket/"/>
      <url>/2021/03/23/socket/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><span id="more"></span><h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="socket常用函数"><a href="#socket常用函数" class="headerlink" title="socket常用函数"></a>socket常用函数</h2><h3 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h3><p>domain指定协议族，type指定socket类型，protocol指定协议（为0时自动选择type类型对应的默认协议）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>;</span><br></pre></td></tr></table></figure><p>返回值大于0成功；-1失败，错误类型保存在全局变量errno中。</p><h3 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h3><p>分配地址族中的特地地址给socket<br> sockfd为socket描述字，通过socket函数的返回值确定<br> addr指向绑定给sockfd的地址，根据socket创建时协议族的不同而不同。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr *addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure><p>返回值等于0成功；-1失败，错误类型保存在全局变量errno中。</p><h4 id="sockaddr-可能的若干结构"><a href="#sockaddr-可能的若干结构" class="headerlink" title="sockaddr*可能的若干结构"></a>sockaddr*可能的若干结构</h4><h5 id="ipv4"><a href="#ipv4" class="headerlink" title="ipv4"></a>ipv4</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> &#123;</span></span><br><span class="line">    <span class="keyword">sa_family_t</span>    sin_family; </span><br><span class="line">    <span class="keyword">in_port_t</span>      sin_port;   </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span>   </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span>       s_addr;     </span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="ipv6"><a href="#ipv6" class="headerlink" title="ipv6"></a>ipv6</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in6</span> &#123;</span> </span><br><span class="line">    <span class="keyword">sa_family_t</span>     sin6_fami一个ly;    </span><br><span class="line">    <span class="built_in">in_port_thtonl</span>()--<span class="string">&quot;Host to Network Long&quot;</span></span><br><span class="line"><span class="built_in">ntohl</span>()--<span class="string">&quot;Network to Host Long&quot;</span></span><br><span class="line"><span class="built_in">htons</span>()--<span class="string">&quot;Host to Network Short&quot;</span></span><br><span class="line"><span class="built_in">ntohs</span>()--<span class="string">&quot;Network to Host Short&quot;</span>       sin6_port;      </span><br><span class="line">    <span class="keyword">uint32_t</span>        sin6_flowinfo;  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span> <span class="title">sin6_addr</span>;</span>      </span><br><span class="line">    <span class="keyword">uint32_t</span>        sin6_scope_id;  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span> &#123;</span> </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span>   s6_addr[<span class="number">16</span>];    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="listen"><a href="#listen" class="headerlink" title="listen"></a>listen</h3><p>服务器监听指定的套接字，backlog指定socket最大连接个数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> backlog)</span></span>;</span><br></pre></td></tr></table></figure><p>返回值等于0成功；-1失败，错误类型保存在全局变量errno中。</p><h3 id="connect"><a href="#connect" class="headerlink" title="connect"></a>connect</h3><p>客户端调用connect函数与服务器进行连接。</p><p>sockfd为客户机的套接字描述符，addr为服务器的套接字地址，addrlen为socket地址的长度。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr *addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure><p>客户机一般不指定自己的端口，系统在1024-5000中选一个（即自由端口），5000以上作为公共端口。</p><h3 id="accept"><a href="#accept" class="headerlink" title="accept"></a>accept</h3><p>当服务器listen到某htonl()—“Host to Network Long”<br> ntohl()—“Network to Host Long”<br> htons()—“Host to Network Short”<br> ntohs()—“Network to Host Short”客户机的connect连接请求，则可以通过accpet函数接受请求，同时建立一个新的套接字，专门用于本次的通信服务。</p><p>sockfd为服务器的监听socket描述符，addr为其地址，addrlen为协议地址的长度，返回连接套接字的描述字。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr *addr, <span class="keyword">socklen_t</span> *addrlen)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h3><p>服务器与客户机像操作文件一样操作socket进行通信。</p><p>有许多对IO操作：</p><ul><li>read/write</li><li>recv/send</li><li>readv/writev</li><li>recvmsg/sendmsg</li><li>recvfrome/sendto</li></ul><p>暂时仅考虑一对IO操作（read/write）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="close"><a href="#close" class="headerlink" title="close"></a>close</h3><p>将套接字<strong>引用计数</strong>-1</p><p>close后进程不再能访问该套接字，但套接字的清除由TCP延后完成。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> sockfd)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="getsockname-getpeername"><a href="#getsockname-getpeername" class="headerlink" title="getsockname, getpeername"></a>getsockname, getpeername</h3><p>获取套接字的名字。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsockname</span><span class="params">(<span class="keyword">int</span> fd,struct sockaddr* localaddr,<span class="keyword">int</span>* addrlen)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getpeername</span><span class="params">(<span class="keyword">int</span> fd,struct sockaddr* peeraddr,<span class="keyword">int</span>* addrlen)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="字节顺序转换"><a href="#字节顺序转换" class="headerlink" title="字节顺序转换"></a>字节顺序转换</h3><p>htonl()—“Host to Network Long”<br>ntohl()—“Network to Host Long”<br>htons()—“Host to Network Short”<br>ntohs()—“Network to Host Short”</p><h3 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h3><p> <a href="https://blog.csdn.net/pashanhu6402/article/details/96428887#t1">Socket原理讲解</a></p><h1 id="Unit-02"><a href="#Unit-02" class="headerlink" title="Unit 02"></a>Unit 02</h1><h2 id="简单的交互示例"><a href="#简单的交互示例" class="headerlink" title="简单的交互示例"></a>简单的交互示例</h2><p>client向server发送三条消息hello hello1 hello2</p><p>server收到消息后回复一个welcome</p><h3 id="server-c"><a href="#server-c" class="headerlink" title="server.c"></a>server.c</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXDATASIZE 128</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PORT 3000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BACKLOG 5</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> **argv)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> sockfd, new_fd, nbytes, sin_size;</span><br><span class="line"><span class="keyword">char</span> buf[MAXDATASIZE];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">srvaddr</span>, <span class="title">clientaddr</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.创建网络端点</span></span><br><span class="line">sockfd=<span class="built_in">socket</span>(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(sockfd==<span class="number">-1</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;can;t create socket\n&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//套接字选项 增添端口地址可重用选项，使得某台服务器崩溃后可以快速用其余服务器重新提供服务</span></span><br><span class="line"><span class="keyword">if</span>(argc==<span class="number">2</span>)&#123;</span><br><span class="line"><span class="keyword">int</span> on=<span class="number">1</span>;</span><br><span class="line"><span class="built_in">setsockopt</span>(sockfd,SOL_SOCKET,SO_REUSEADDR,&amp;on,<span class="built_in"><span class="keyword">sizeof</span></span>(on));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;reuse addr\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//填充地址</span></span><br><span class="line"><span class="built_in">bzero</span>(&amp;srvaddr,<span class="built_in"><span class="keyword">sizeof</span></span>(srvaddr));</span><br><span class="line">srvaddr.sin_family=AF_INET;</span><br><span class="line"><span class="comment">//htons进行字节顺序转换</span></span><br><span class="line">srvaddr.sin_port=<span class="built_in">htons</span>(PORT);</span><br><span class="line"><span class="comment">//服务器上无论有多少个IP发来消息，全部都予以接受</span></span><br><span class="line">srvaddr.sin_addr.s_addr=<span class="built_in">htonl</span>(INADDR_ANY);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将xxx.xxx.xxx.xxx转换为32位的地址</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">if(inet_aton(argv[1],&amp;srvaddr.sin_addr)==-1)&#123;</span></span><br><span class="line"><span class="comment">printf(&quot;addr convert error\n&quot;);</span></span><br><span class="line"><span class="comment">exit(1);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//2.绑定服务器地址和端口</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">bind</span>(sockfd,(struct sockaddr *)&amp;srvaddr,<span class="built_in"><span class="keyword">sizeof</span></span>(struct sockaddr))==<span class="number">-1</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;bind error\n&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3. 监听端口，将主动套接字转换为被动套接字</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">listen</span>(sockfd,BACKLOG)==<span class="number">-1</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;listen error\n&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//一般应该在循环中添加一些退出的方法</span></span><br><span class="line"><span class="keyword">for</span>(;;)&#123;</span><br><span class="line"><span class="comment">//4.接受客户端连接</span></span><br><span class="line">sin_size=<span class="built_in"><span class="keyword">sizeof</span></span>(struct sockaddr_in);</span><br><span class="line"><span class="keyword">if</span>((new_fd=<span class="built_in">accept</span>(sockfd,(struct sockaddr *)&amp;clientaddr, (<span class="keyword">socklen_t</span>*)&amp;sin_size))==<span class="number">-1</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;accept error\n&quot;</span>);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果成功连接，那么打印出客户机的ip、port</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;client addr:%s %d\n&quot;</span>,<span class="built_in">inet_ntoa</span>(clientaddr.sin_addr),<span class="built_in">ntohs</span>(clientaddr.sin_port));</span><br><span class="line"></span><br><span class="line"><span class="comment">//5.接收请求 </span></span><br><span class="line"><span class="comment">//延时 必须读入一个字符才继续 可以检查读入的客户机数据的情况(但是很麻烦所以我删了)</span></span><br><span class="line"><span class="comment">//getchar();</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//sockfd属于监听套接字，new_fd属于连接套接字</span></span><br><span class="line">nbytes=<span class="built_in">read</span>(new_fd,buf,MAXDATASIZE);</span><br><span class="line">buf[nbytes]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;client:%s\n\n&quot;</span>,buf);</span><br><span class="line"></span><br><span class="line"><span class="comment">//6.回送响应</span></span><br><span class="line"><span class="built_in">sprintf</span>(buf,<span class="string">&quot;wellcome!&quot;</span>);</span><br><span class="line"><span class="built_in">write</span>(new_fd,buf,<span class="built_in">strlen</span>(buf));</span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭socket</span></span><br><span class="line"><span class="built_in">close</span>(new_fd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">close</span>(sockfd);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="client-c"><a href="#client-c" class="headerlink" title="client.c"></a>client.c</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXDATASIZE 128</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PORT 3000</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">addr_conv</span><span class="params">(<span class="keyword">char</span> *address,struct in_addr *inaddr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> **argv)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> sockfd,nbytes;</span><br><span class="line"><span class="keyword">int</span> port=PORT;</span><br><span class="line"><span class="keyword">char</span> buf[MAXDATASIZE];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">srvaddr</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//必须输入1/2个参数，具体格式参见printf的内容</span></span><br><span class="line"><span class="keyword">if</span>(argc!=<span class="number">2</span> &amp;&amp; argc!=<span class="number">3</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;usage:./client hostname|ip. Or usage:./client hostname|ip port\n&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果有指定端口号则使用，不然使用默认端口PORT=3000</span></span><br><span class="line"><span class="keyword">if</span>(argc==<span class="number">3</span>) port=<span class="built_in">atoi</span>(argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.创建网络端点</span></span><br><span class="line">sockfd=<span class="built_in">socket</span>(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(sockfd==<span class="number">-1</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;can;t create socket\n&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//指定服务器协议簇，端口（本地socket地址采用默认值）</span></span><br><span class="line"><span class="built_in">bzero</span>(&amp;srvaddr,<span class="built_in"><span class="keyword">sizeof</span></span>(srvaddr));</span><br><span class="line">srvaddr.sin_family=AF_INET;</span><br><span class="line">srvaddr.sin_port=<span class="built_in">htons</span>(port);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">if(inet_aton(&quot;127.0.0.1&quot;,&amp;srvaddr.sin_addr)==-1)&#123;</span></span><br><span class="line"><span class="comment">printf(&quot;addr convert error\n&quot;);</span></span><br><span class="line"><span class="comment">exit(1);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//根据传入参数指定服务器IP地址</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">addr_conv</span>(argv[<span class="number">1</span>],&amp;srvaddr.sin_addr)==<span class="number">-1</span>)&#123;</span><br><span class="line"><span class="built_in">perror</span>(<span class="built_in">strerror</span>(errno));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.连接服务器</span></span><br><span class="line"><span class="comment">//客户端的IP地址等信息不需要手动填写，由内核自动完成</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">connect</span>(sockfd,(struct sockaddr *)&amp;srvaddr,<span class="built_in"><span class="keyword">sizeof</span></span>(struct sockaddr))==<span class="number">-1</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;connect error\n&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.发送请求</span></span><br><span class="line"><span class="built_in">sprintf</span>(buf,<span class="string">&quot;hello&quot;</span>); <span class="built_in">write</span>(sockfd,buf,<span class="built_in">strlen</span>(buf));</span><br><span class="line"><span class="built_in">sprintf</span>(buf,<span class="string">&quot;hello2&quot;</span>); <span class="built_in">write</span>(sockfd,buf,<span class="built_in">strlen</span>(buf));</span><br><span class="line"><span class="built_in">sprintf</span>(buf,<span class="string">&quot;hello3&quot;</span>); <span class="built_in">write</span>(sockfd,buf,<span class="built_in">strlen</span>(buf));</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.接收响应</span></span><br><span class="line"><span class="keyword">if</span>((nbytes=<span class="built_in">read</span>(sockfd,buf,MAXDATASIZE))==<span class="number">-1</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;read error\n&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">buf[nbytes]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;srv respons:%s\n\n&quot;</span>,buf);</span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭socket</span></span><br><span class="line"><span class="built_in">close</span>(sockfd);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">addr_conv</span><span class="params">(<span class="keyword">char</span> *address,struct in_addr *inaddr)</span></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hostent</span> *<span class="title">he</span>;</span></span><br><span class="line"><span class="comment">//inet_aton 函数将一个“字符串类型”的IP地址转化为“整数类型”的地址</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">inet_aton</span>(address,inaddr)==<span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;call inet_aton sucess.\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;call inet_aton fail.\n&quot;</span>);</span><br><span class="line"><span class="comment">//如果输入的不是IP地址而主机名/域名，那么可以通过这些来获得IP地址</span></span><br><span class="line">he=<span class="built_in">gethostbyname</span>(address);</span><br><span class="line"><span class="keyword">if</span>(he!=<span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;call gethostbyname sucess.\n&quot;</span>);</span><br><span class="line">*inaddr=*((struct in_addr *)(he-&gt;h_addr_list[<span class="number">0</span>]));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="套接字最大创建数量"><a href="#套接字最大创建数量" class="headerlink" title="套接字最大创建数量"></a>套接字最大创建数量</h2><h3 id="client-msock-c-主动套接字最大数量"><a href="#client-msock-c-主动套接字最大数量" class="headerlink" title="client_msock.c(主动套接字最大数量)"></a>client_msock.c(主动套接字最大数量)</h3><p>检查最多可创建的套接字数量<br>向程序传入两个参数，第一个参数为IP地址，第二个参数为想要创建的套接字数量<br>具体实现其实是On地尝试创建所有希望的套接字，出错则退出。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXDATASIZE 128</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PORT 3000</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">addr_conv</span><span class="params">(<span class="keyword">char</span> *address,struct in_addr *inaddr)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> **argv)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,sockfd;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">srvaddr</span>;</span></span><br><span class="line"><span class="keyword">int</span> n=<span class="built_in">atoi</span>(argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.创建网络端点</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">sockfd=<span class="built_in">socket</span>(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(sockfd==<span class="number">-1</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Failed to create the %d socket.\n&quot;</span>,i);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//指定服务器地址（本地socket地址采用默认值）</span></span><br><span class="line"><span class="built_in">bzero</span>(&amp;srvaddr,<span class="built_in"><span class="keyword">sizeof</span></span>(srvaddr));</span><br><span class="line">srvaddr.sin_family=AF_INET;</span><br><span class="line">srvaddr.sin_port=<span class="built_in">htons</span>(PORT);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">addr_conv</span>(argv[<span class="number">1</span>],&amp;srvaddr.sin_addr)==<span class="number">-1</span>)&#123;</span><br><span class="line"><span class="built_in">perror</span>(<span class="built_in">strerror</span>(errno));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Finished.\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="server-msock-c-被动套接字最大数量"><a href="#server-msock-c-被动套接字最大数量" class="headerlink" title="server_msock.c(被动套接字最大数量)"></a>server_msock.c(被动套接字最大数量)</h3><p>传入2/4个参数，表示起始端口号、创建连续套接字数量、发送信息大小、接受信息大小。</p><p>具体实现与上述类似，暴力模拟，检验是否可行。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXDATASIZE 128</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BACKLOG 5</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> **argv)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> sockfd,new_fd,nbytes,sin_size;</span><br><span class="line"><span class="keyword">char</span> buf[MAXDATASIZE];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">srvaddr</span>;</span></span><br><span class="line"><span class="keyword">int</span> i,lastsockfd=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> minport,n,sizeSND,sizeRCV;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(argc!=<span class="number">3</span> &amp;&amp; argc!=<span class="number">5</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;You should input 3 or 5 params: &quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;func, startPort, number, SND size, RCV size.\n&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">minport=<span class="built_in">atoi</span>(argv[<span class="number">1</span>]);</span><br><span class="line">n=<span class="built_in">atoi</span>(argv[<span class="number">2</span>]);</span><br><span class="line"><span class="keyword">if</span>(argc==<span class="number">5</span>)</span><br><span class="line">&#123;</span><br><span class="line">sizeSND=<span class="built_in">atoi</span>(argv[<span class="number">3</span>]);</span><br><span class="line">sizeRCV=<span class="built_in">atoi</span>(argv[<span class="number">4</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//1.创建网络端点</span></span><br><span class="line">sockfd=<span class="built_in">socket</span>(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(sockfd==<span class="number">-1</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Failed to create %d socket.The last sockfd is %d.\n&quot;</span>,i,lastsockfd);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">lastsockfd=sockfd;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(argc==<span class="number">5</span>)&#123;<span class="comment">// get &amp; set SO_SNDBUF,SO_RCVBUF</span></span><br><span class="line"><span class="keyword">int</span> size;</span><br><span class="line"><span class="keyword">socklen_t</span> size2=<span class="built_in"><span class="keyword">sizeof</span></span>(size);</span><br><span class="line"><span class="keyword">if</span>((<span class="built_in">getsockopt</span>(sockfd,SOL_SOCKET,SO_SNDBUF,&amp;size,&amp;size2))&lt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;getsockopt failed\n&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//printf(&quot;SND buff is %d\n&quot;,size);</span></span><br><span class="line"><span class="keyword">if</span>((<span class="built_in">getsockopt</span>(sockfd,SOL_SOCKET,SO_RCVBUF,&amp;size,&amp;size2))&lt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;getsockopt failed\n&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//printf(&quot;RCV buff is %d\n&quot;,size);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>((<span class="built_in">setsockopt</span>(sockfd,SOL_SOCKET,SO_SNDBUF,&amp;sizeSND,<span class="built_in"><span class="keyword">sizeof</span></span>(sizeSND)))&lt;<span class="number">0</span> </span><br><span class="line">|| (<span class="built_in">setsockopt</span>(sockfd,SOL_SOCKET,SO_RCVBUF,&amp;sizeRCV,<span class="built_in"><span class="keyword">sizeof</span></span>(sizeRCV)))&lt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;setsockopt failed.\n&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//printf(&quot;New SND and RCV buff are %d and %d.\n&quot;,sizeSND,sizeRCV);</span></span><br><span class="line"><span class="comment">//exit(0);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//填充地址</span></span><br><span class="line"><span class="built_in">bzero</span>(&amp;srvaddr,<span class="built_in"><span class="keyword">sizeof</span></span>(srvaddr));</span><br><span class="line">srvaddr.sin_family=AF_INET;</span><br><span class="line">srvaddr.sin_port=<span class="built_in">htons</span>(minport+i);</span><br><span class="line">srvaddr.sin_addr.s_addr=<span class="built_in">htonl</span>(INADDR_ANY);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.绑定服务器地址和端口</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">bind</span>(sockfd,(struct sockaddr *)&amp;srvaddr,<span class="built_in"><span class="keyword">sizeof</span></span>(struct sockaddr))==<span class="number">-1</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;bind error\n&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3. 监听端口</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">listen</span>(sockfd,BACKLOG)==<span class="number">-1</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;listen error\n&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Finished.The last sockfd is %d.\n&quot;</span>,sockfd);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="统计自由端口数量"><a href="#统计自由端口数量" class="headerlink" title="统计自由端口数量"></a>统计自由端口数量</h2><p>具体实现是客户端尝试进行充分多次的套接字连接请求，服务器端每次根据发送方的IP地址更新最大最小值，这样就能知道自由端口所在的区间。.</p><p><del>大概自由端口保证是连续的</del></p><h3 id="client-port-c"><a href="#client-port-c" class="headerlink" title="client_port.c"></a>client_port.c</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXDATASIZE 128</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PORT 3000</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">addr_conv</span><span class="params">(<span class="keyword">char</span> *address,struct in_addr *inaddr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> **argv)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> sockfd,nbytes,i,j;</span><br><span class="line"><span class="keyword">char</span> buf[MAXDATASIZE];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">srvaddr</span>;</span></span><br><span class="line"><span class="keyword">if</span>(argc!=<span class="number">2</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;usage:./client hostname|ip\n&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">bzero</span>(&amp;srvaddr,<span class="built_in"><span class="keyword">sizeof</span></span>(srvaddr));</span><br><span class="line">srvaddr.sin_family=AF_INET;</span><br><span class="line">srvaddr.sin_port=<span class="built_in">htons</span>(PORT);</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">addr_conv</span>(argv[<span class="number">1</span>],&amp;srvaddr.sin_addr)==<span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">perror</span>(<span class="built_in">strerror</span>(errno));</span><br><span class="line">   <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">100</span>;j++)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10000</span>;i++)</span><br><span class="line">   &#123;</span><br><span class="line">      sockfd=<span class="built_in">socket</span>(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">      <span class="keyword">if</span>(sockfd==<span class="number">-1</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;can;t create socket\n&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">connect</span>(sockfd,(struct sockaddr *)&amp;srvaddr,<span class="built_in"><span class="keyword">sizeof</span></span>(struct sockaddr))==<span class="number">-1</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;connect error\n&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">sprintf</span>(buf,<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">      <span class="built_in">write</span>(sockfd,buf,<span class="built_in">strlen</span>(buf));</span><br><span class="line">      <span class="keyword">if</span>((nbytes=<span class="built_in">read</span>(sockfd,buf,MAXDATASIZE))==<span class="number">-1</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;read error\n&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">close</span>(sockfd);</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;srv respons 10k times:%d\n&quot;</span>,j);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="server-port-c"><a href="#server-port-c" class="headerlink" title="server_port.c"></a>server_port.c</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXDATASIZE 128</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PORT 3000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BACKLOG 5</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> **argv)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> sockfd, new_fd, nbytes, sin_size;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> port, minport, maxport;</span><br><span class="line"><span class="keyword">char</span> buf[MAXDATASIZE];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">srvaddr</span>,<span class="title">clientaddr</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.创建网络端点</span></span><br><span class="line">sockfd=<span class="built_in">socket</span>(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(sockfd==<span class="number">-1</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;can;t create socket\n&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(argc==<span class="number">2</span>)&#123;</span><br><span class="line"><span class="keyword">int</span> on=<span class="number">1</span>;</span><br><span class="line"><span class="built_in">setsockopt</span>(sockfd,SOL_SOCKET,SO_REUSEADDR,&amp;on,<span class="built_in"><span class="keyword">sizeof</span></span>(on));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;reuse addr\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//填充地址</span></span><br><span class="line"><span class="built_in">bzero</span>(&amp;srvaddr,<span class="built_in"><span class="keyword">sizeof</span></span>(srvaddr));</span><br><span class="line">srvaddr.sin_family=AF_INET;</span><br><span class="line">srvaddr.sin_port=<span class="built_in">htons</span>(PORT);</span><br><span class="line">srvaddr.sin_addr.s_addr=<span class="built_in">htonl</span>(INADDR_ANY);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.绑定服务器地址和端口</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">bind</span>(sockfd,(struct sockaddr *)&amp;srvaddr,<span class="built_in"><span class="keyword">sizeof</span></span>(struct sockaddr))==<span class="number">-1</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;bind error\n&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3. 监听端口</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">listen</span>(sockfd,BACKLOG)==<span class="number">-1</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;listen error\n&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;在执行 make  之</span><br><span class="line"></span><br><span class="line">minport=<span class="number">65535</span>;</span><br><span class="line">maxport=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Listening......\n&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(;;)&#123;</span><br><span class="line"><span class="comment">//4.接受客户端连接</span></span><br><span class="line">sin_size=<span class="built_in"><span class="keyword">sizeof</span></span>(struct sockaddr_in);</span><br><span class="line"><span class="keyword">if</span>((new_fd=<span class="built_in">accept</span>(sockfd,(struct sockaddr *)&amp;clientaddr,&amp;sin_size))==<span class="number">-1</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;accept error\n&quot;</span>);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">port=(<span class="keyword">unsigned</span> <span class="keyword">int</span>)<span class="built_in">ntohs</span>(clientaddr.sin_port);</span><br><span class="line"><span class="keyword">if</span>(port&lt;minport || port&gt;maxport)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">if</span>(port&lt;minport)</span><br><span class="line">      minport=port;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span>(port&gt;maxport)</span><br><span class="line">      maxport=port;</span><br><span class="line">   </span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;minport is: %d\t&quot;</span>,minport);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;maxport is: %d\n&quot;</span>,maxport);</span><br><span class="line">&#125;</span><br><span class="line">nbytes=<span class="built_in">read</span>(new_fd,buf,MAXDATASIZE);</span><br><span class="line"><span class="built_in">write</span>(new_fd,buf,<span class="built_in">strlen</span>(buf));</span><br><span class="line"><span class="built_in">close</span>(new_fd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">close</span>(sockfd);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="star-客户端发送整数，服务器计算平均值后返回"><a href="#star-客户端发送整数，服务器计算平均值后返回" class="headerlink" title=":star: 客户端发送整数，服务器计算平均值后返回"></a>:star: 客户端发送整数，服务器计算平均值后返回</h2><h3 id="header"><a href="#header" class="headerlink" title="header"></a>header</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;termio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> itn int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> whlie while</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fro for</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pritnf printf</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">termios</span> <span class="title">tmtemp</span>, <span class="title">tm</span>;</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">getch</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">0</span>, fd = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取当前的终端属性设置，并保存到tm结构体中</span></span><br><span class="line">    <span class="keyword">if</span>(tcgetattr(fd,&amp;tm) != <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    tmtemp=tm;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将tetemp初始化为终端原始模式的属性设置</span></span><br><span class="line">    cfmakeraw(&amp;tmtemp);     </span><br><span class="line"></span><br><span class="line">    <span class="comment">//终端设置为原始模式的设置</span></span><br><span class="line">    <span class="keyword">if</span>(tcsetattr(fd,TCSANOW,&amp;tmtemp) != <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">    c=getchar();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(tcsetattr(fd,TCSANOW,&amp;tm) != <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">char</span>)c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myprintf</span><span class="params">(<span class="keyword">char</span> *format, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">termios</span> <span class="title">now</span>;</span></span><br><span class="line">    <span class="keyword">if</span>(tcgetattr(<span class="number">0</span>, &amp;now) != <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(tcsetattr(<span class="number">0</span>,TCSANOW,&amp;tm) != <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    va_list args;</span><br><span class="line">    va_start(args, format);</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="built_in">vprintf</span>(format, args);</span><br><span class="line">    va_end(args);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(tcsetattr(<span class="number">0</span>,TCSANOW,&amp;now) != <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="client"><a href="#client" class="headerlink" title="client"></a>client</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  SERVER_PORT 8086</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, buf[<span class="number">1024</span>], msg[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">(<span class="keyword">char</span> *ip)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sockfd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>;</span></span><br><span class="line">    sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(sockfd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Socket error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bzero(&amp;servaddr, <span class="keyword">sizeof</span> servaddr);</span><br><span class="line">    servaddr.sin_family = AF_INET;</span><br><span class="line">    servaddr.sin_port = htons(SERVER_PORT);</span><br><span class="line">    <span class="keyword">if</span>(inet_aton(ip, &amp;servaddr.sin_addr) == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;Inet_aton error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(connect(sockfd, (struct sockaddr*)&amp;servaddr, <span class="keyword">sizeof</span> servaddr) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;Connect error\n&quot;</span>);</span><br><span class="line">        close(sockfd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    msg[<span class="number">0</span>] = htonl(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) msg[i + <span class="number">1</span>] = htonl(buf[i]);  msg[n + <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    write(sockfd, msg, (n + <span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="keyword">int</span>)); </span><br><span class="line"></span><br><span class="line">    n = (<span class="keyword">int</span>)read(sockfd, msg, <span class="number">1024</span>);</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Read error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;服务器返回平均值为%d\n&quot;</span>, ntohl(msg[<span class="number">0</span>]));</span><br><span class="line">    close(sockfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc != <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;请输入一个参数表示服务器IP地址!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    srand((<span class="keyword">int</span>)time(<span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line">    n = <span class="number">255</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) buf[i] = rand() % <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;总共产生%d个数字:\n&quot;</span>, n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, buf[i]); <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    fun(argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="server"><a href="#server" class="headerlink" title="server"></a>server</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;rqdmap.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  SERVER_PORT 8086</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  BACKLOG    5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> op;</span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">thread</span><span class="params">(<span class="keyword">void</span> * listenfd)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(op != <span class="string">&#x27;q&#x27;</span>)&#123;</span><br><span class="line">        fflush(<span class="built_in">stdin</span>);</span><br><span class="line">        op = getch();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;receive %d\n&quot;</span>, op);</span><br><span class="line">    &#125;</span><br><span class="line">    close(*(<span class="keyword">int</span> *)listenfd);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> buf[<span class="number">1030</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> connfd)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = (<span class="keyword">int</span>)read(connfd, (<span class="keyword">char</span>*)buf, <span class="number">1100</span>);</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;Read error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    n = ntohl(buf[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// for(int i = 0; i &lt; n; i++) printf(&quot;%d &quot;, ntohl(buf[i + 1]));</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) sum += ntohl(buf[i]);</span><br><span class="line">    sum /= n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(myprintf(<span class="string">&quot;服务器输出 %d \n&quot;</span>, sum) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Print error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    buf[<span class="number">0</span>] = htonl(sum); buf[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    write(connfd, buf, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> listenfd, connfd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>;</span></span><br><span class="line">    </span><br><span class="line">    listenfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;产生套接字 %d\n&quot;</span>, listenfd);</span><br><span class="line">    <span class="keyword">if</span>(listenfd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Socket error\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> on = <span class="number">1</span>;</span><br><span class="line">    setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;on, <span class="keyword">sizeof</span>(on));</span><br><span class="line">    </span><br><span class="line">    bzero(&amp;servaddr, <span class="keyword">sizeof</span> servaddr);</span><br><span class="line">    servaddr.sin_family = AF_INET;</span><br><span class="line">    servaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    servaddr.sin_port=htons(SERVER_PORT);</span><br><span class="line">    <span class="keyword">if</span>(bind(listenfd, (struct sockaddr*)&amp;servaddr, <span class="keyword">sizeof</span> (struct sockaddr)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;Bind error\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">if</span>(listen(listenfd, <span class="number">5</span>) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;Listen error\n&quot;</span>);</span><br><span class="line">        close(listenfd);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">pthread_t</span> pid;</span><br><span class="line">    <span class="keyword">if</span>(pthread_create(&amp;pid, <span class="literal">NULL</span>, thread, &amp;listenfd) != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Create pthread error!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        connfd = accept(listenfd, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span>(connfd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;Accept error\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(fun(connfd) != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;fun error\n&quot;</span>);</span><br><span class="line">            op = <span class="string">&#x27;q&#x27;</span>; <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        close(connfd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_join(pid, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="实战记录"><a href="#实战记录" class="headerlink" title="实战记录"></a>实战记录</h3><p>遇到了非常多的坑点…弄了很久</p><p>利用socket套接字进行数据通信最关键的地方其实在于<font color = "#dd0000"> 通信格式</font>的设计，这样接收方才能够正确无误地解读发送方的比特串。</p><p>而在其中非常重要的一个细节就是<font color = "#dd0000"> 字节顺序</font>，发送方和接收方应该使用匹配的<code>htonl</code>或<code>htons</code>，每次想要通过socket进行传输信息都应该进行编码和解码。</p><p>接收方接受数据时，如何正确地遍历不同格式的缓冲区也非常重要，需要注意到read函数返回的是接收到的字节(8位)的个数！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> buf[];</span><br><span class="line"><span class="keyword">int</span> n = read(connfd, (<span class="keyword">char</span>*)buf, <span class="number">1024</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i * <span class="number">4</span> &lt; n; i++)&#123;</span><br><span class="line">   <span class="comment">//do something on buf[]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了使得服务器不仅能够接受不断地监听套接字提供服务，还能够通过键盘的键入来退出死循环、回收资源终止服务，上述程序还夹杂了非常多的私活。</p><ul><li><p>为了实现上述两个<font color="#dd00000"> 不间断的</font>服务，我们使用多线程。除去main函数中对套接字不断地监听，我们再开一个thread进行键盘的读入。</p><p>起初不充分的设想是通过thread读取键盘，将输入的字符存储到全局变量op中，main函数在循环中不断地检查op是否为q.</p><p>然而事实上listen会由于没有客户机的访问而一直堵塞，因而会卡在一次循环中无法得到op已经被修改的信息。</p><p>那么考虑到这两个线程其实不存在必要的通信要求，只要thread读取到q就应该将套接字服务资源全部回收，终止进程，所以最终的实现就是在thread中回收资源并且终止进程，主函数不断地循环即可。</p><p><del>不过之后由于main函数的循环监听中有可能有函数出错而终止服务，所以还是利用了op向thread传达信息</del></p></li><li><p>听闻有函数getch可以读入键盘的输入，不需要按回车也不会在控制台回显，非常适合作为退出死循环的方法。然而好像getch不是标准库的函数，在linux下并没有实现，所以便自己实现了一个<font color="#dd0000">不回显、不需要空格</font> 的键盘读入。基本原理是将控制台调整为<strong>原始模式</strong>，在原始模式下，所有的数据输入以字节为单位进行处理，当一个字节被输入后，便触发输入有效。那么将控制台设置为原始模式，完成getchar()后将终端模式恢复到原先的状态即可。具体实现参见header。</p></li><li><p>上述的多线程函数带来了若干的问题。由上述分析可知，运行getch()后，当前终端会一直保持原始模式，那么如果此时main函数希望进行IO操作，输出的格式就会出现非常奇怪的问题（大概类似于阶梯状，不是很懂为什么）。所以我们还多写了一个自定义的printf函数，这个printf函数在输出前会先将终端设置为getch调用前的状态，输出完成后再将其到原始模式。因为一台机子上模拟CS不太会同时操作两个终端，所以这样基本能完成任务。但是这样实现仍然是非常朴素的，真正在设计网络服务器的时候<strong>一定要重新考虑</strong>！</p></li></ul><h1 id="Unit-03"><a href="#Unit-03" class="headerlink" title="Unit 03"></a>Unit 03</h1><h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><h3 id="struct-hostent"><a href="#struct-hostent" class="headerlink" title="struct hostent"></a>struct hostent</h3><p>hostent是host entry的缩写，该结构记录主机的相关信息。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hostent</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> * h_name;</span><br><span class="line">    <span class="keyword">char</span> ** h_aliases;</span><br><span class="line">    <span class="keyword">short</span> h_addrtype;</span><br><span class="line">    <span class="keyword">short</span> h_length;</span><br><span class="line">    <span class="keyword">char</span> ** h_addr_list;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> h_addr h_addr_list[0];</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="域名-lt-gt-IP地址"><a href="#域名-lt-gt-IP地址" class="headerlink" title="域名&lt;-&gt;IP地址"></a>域名&lt;-&gt;IP地址</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct hostent* <span class="title">gethostbyname</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span></span><br><span class="line"><span class="function">struct hostent *<span class="title">gethostbyaddr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *addr, <span class="keyword">size_t</span> len, <span class="keyword">int</span> family)</span></span></span><br></pre></td></tr></table></figure><p>注意，通过IP获取主机信息时传入的参数addr不是IP字符串，而是经过inet_aton转化过的32位的网络序列地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_aton</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="built_in">string</span>, struct in_addr*addr)</span></span>;</span><br></pre></td></tr></table></figure><p>函数成功返回非零，失败返回0</p><h2 id="recv与send"><a href="#recv与send" class="headerlink" title="recv与send"></a>recv与send</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">recv</span><span class="params">(<span class="keyword">int</span> sockfd,<span class="keyword">void</span>* buf,<span class="keyword">int</span> len, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">send</span><span class="params">(<span class="keyword">int</span> sockfd,<span class="keyword">void</span>* buf,<span class="keyword">int</span> len, <span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure><p>len为发送/接受数据的长度</p><p>flags中可以填写一些参数</p><ul><li>0：相当于write和read</li><li>MSG_DONTROUTE：发送数据不查找路由表</li><li>MSG_OOB：发送、接受带外数据</li><li>MSG_PEEK：接受数据时不从缓冲区移走数据，其他进程仍然可以read到数据</li><li>MSG_WAITALL：数据量不够时，读操作等待</li></ul><h2 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown"></a>shutdown</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shutdown</span><span class="params">(<span class="keyword">int</span> sockfd,<span class="keyword">int</span> howto)</span></span>; </span><br></pre></td></tr></table></figure><p>参数howto指定关闭操作的类型：</p><ul><li>howto = 0， 关闭读通道；丢弃尚未读取的数据，对后来接收到的数据返回确认后丢弃。</li><li>howto = 1， 关闭写通道；继续发送未发送完成的数据，然后发送FIN字段关闭写通道。</li><li>howto = 2， 关闭读写通道；任何进程都不能再操作这个socktet</li></ul><h3 id="shutdown与close的区别"><a href="#shutdown与close的区别" class="headerlink" title="shutdown与close的区别"></a>shutdown与close的区别</h3><p>close关闭当前进程与套接字的联系，其他进程仍然可能使用这个套接字。</p><p>shutdown直接在tcp层上操作该套接字，不管有多少个进程引用该套接字，当套接字关闭后试图读的进程会读到EOF，试图写的进程会检测到SIGPIPE信号。</p><h2 id="readv与writev"><a href="#readv与writev" class="headerlink" title="readv与writev"></a>readv与writev</h2><p>readv为<strong>散布读</strong>，将文件中若干连续的数据块读入内存分散的缓冲区中。</p><p>writev为<strong>聚集写</strong>，即收集内存中分散的若干缓冲区中的数据写至文件的连续区域中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iovec</span>&#123;</span></span><br><span class="line">  <span class="keyword">void</span> *  iov_base; <span class="comment">/* 数据区的起始地址 */</span></span><br><span class="line">  <span class="keyword">size_t</span>  iov_len;  <span class="comment">/*   数据区的大小  */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">readv</span><span class="params">(<span class="keyword">int</span> fildes, <span class="keyword">const</span> struct iovec *iov, <span class="keyword">int</span> iovcnt)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">writev</span><span class="params">(<span class="keyword">int</span> fildes, <span class="keyword">const</span> struct iovec *iov, <span class="keyword">int</span> iovcnt)</span></span>;</span><br></pre></td></tr></table></figure><p>参数iovcnt指出数组iov的元素个数，元素个数至多不超过IOV_MAX。linux中定义IOV_MAX的值为1024。</p><p>给出一个示例代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//发送</span></span><br><span class="line"><span class="keyword">char</span> *name = <span class="string">&quot; Wang Jin-pyng&quot;</span>;</span><br><span class="line"><span class="keyword">char</span> *occupation = <span class="string">&quot;Head of the legislative body&quot;</span>;</span><br><span class="line"><span class="keyword">int</span> len[<span class="number">2</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iov</span>[3];</span></span><br><span class="line"><span class="keyword">int</span> iovcnt;</span><br><span class="line"></span><br><span class="line">len[<span class="number">0</span>]=<span class="built_in">strlen</span>(name);</span><br><span class="line">len[<span class="number">1</span>]=<span class="built_in">strlen</span>(occupation);</span><br><span class="line"></span><br><span class="line">iov[<span class="number">1</span>].iov_base=name;关闭后</span><br><span class="line">iov[<span class="number">1</span>].iov_len=len[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">iov[<span class="number">2</span>].iov_base=occupation;</span><br><span class="line">iov[<span class="number">2</span>].iov_len=len[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">len[<span class="number">0</span>]=htonl(len[<span class="number">0</span>]);</span><br><span class="line">len[<span class="number">1</span>]=htonl(len[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">iov[<span class="number">0</span>].iov_base=len;</span><br><span class="line">iov[<span class="number">0</span>].iov_len=<span class="number">2</span>*<span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line"></span><br><span class="line">writev(sockfd,iov,<span class="number">3</span>);</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="comment">//接收</span></span><br><span class="line"><span class="keyword">char</span> name[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">char</span> occupation[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">int</span> len[<span class="number">2</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iov</span>[2];</span></span><br><span class="line"><span class="keyword">int</span> iovlen;</span><br><span class="line"></span><br><span class="line">......<span class="comment">//</span></span><br><span class="line">read(sockfd,len,<span class="number">2</span>*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"></span><br><span class="line">len[<span class="number">0</span>]=ntohl(len[<span class="number">0</span>]);</span><br><span class="line">len[<span class="number">1</span>]=ntohl(len[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">iov[<span class="number">0</span>].iov_base=name;</span><br><span class="line">iov[<span class="number">0</span>].iov_len=len[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">iov[<span class="number">1</span>].iov_base=occupation;</span><br><span class="line">iov[<span class="number">1</span>].iov_len=len[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">readv(sockfd,iov,<span class="number">2</span>);</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="comment">//Note：通常还需要调用函数</span></span><br><span class="line"><span class="comment">//ioctl(fd,FIONREAD,nbyte),以确定接收缓存区内有多少个字节可读。</span></span><br></pre></td></tr></table></figure><h3 id="参考博客-1"><a href="#参考博客-1" class="headerlink" title="参考博客"></a>参考博客</h3><p> <a href="https://blog.csdn.net/qq_39642794/article/details/108080722">readv()和writev()函数</a></p><h2 id="recvmsg与sendmsg"><a href="#recvmsg与sendmsg" class="headerlink" title="recvmsg与sendmsg"></a>recvmsg与sendmsg</h2><p>这两个函数是最底层的函数，其余所有的IO均通过转化为该函数来进行。</p><p>具体参数不了解。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">recvmsg</span><span class="params">(<span class="keyword">int</span> sockfd,struct msghdr* msg,<span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sendmsg</span><span class="params">(<span class="keyword">int</span> sockfd,struct msghdr* msg,<span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span>&#123;</span></span><br><span class="line">  <span class="keyword">void</span> *msg_name;  </span><br><span class="line">  <span class="keyword">int</span> msg_namelen;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span>* <span class="title">msg_iov</span>;</span></span><br><span class="line">  <span class="keyword">int</span> msg_iovlen;</span><br><span class="line">  <span class="keyword">void</span>* msg_control;</span><br><span class="line">  <span class="keyword">int</span> msg_controllen;</span><br><span class="line">  <span class="keyword">int</span> msg_flags;  <span class="comment">//同recv、send</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多路复用select"><a href="#多路复用select" class="headerlink" title="多路复用select"></a>多路复用select</h2><p>检查多个文件描述符（socket描述符）是否就绪，当某一个描述符就绪（可读、可写或发生异常）时函数返回。可以实现输入输出多路复用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> maxfd, fd_set *rdset, fd_set *wrest, fd_set *exset, struct timeval *timeout)</span></span>;</span><br></pre></td></tr></table></figure><p>返回值：有描述符就绪则返回就绪的描述符个数；超时时间内没有描述符就绪返回0；执行失败返回-1。</p><p>参数：</p><ul><li><p>maxfd－需要测试的描述符的最大值，实际测试的描述符从0－maxfd-1  </p></li><li><p>rdset－需要测试是否可读的描述符集合（包括处于listen状态的socket接收到连接请求） </p></li><li><p>wrset－需要测试是否可写的描述符集合（包括以非阻塞方式调用connect是否成功）  </p></li><li><p>exset－需要测试是否异常的描述符集合（包括接收带外数据的socket有带外数据到达）   </p></li><li><p>timeout－指定测试超时的时间</p><ul><li>timeval结构</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span>&#123;</span></span><br><span class="line"><span class="keyword">long</span> tv_sec;  <span class="comment">//秒</span></span><br><span class="line"><span class="keyword">long</span> tv_usec; <span class="comment">//毫秒</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><ul><li>timeout=NULL，select将永远阻塞直到有一个描述符就绪，或者出现错误（接收到信号）。</li><li>timeout&gt;0，在timeout时间内如果有描述符就绪则返回，否则在timeout时间后返回0；如果将3个描述符集合都设定为NULL则select相当于sleep函数，只是时间可以精确到毫秒  </li><li>timeout=0，select检查完描述符集合后立即返回 </li></ul></li></ul><p>操作描述符集合：</p><ul><li>FD_ZERO(fd_set *fdset)－清空描述符集合 </li><li>FD_SET(int fd, fd_set *fdset)－将一个描述符添加到描述符集合 </li><li>FD_CLR(int fd, fd_set *fdset)－将一个描述符从描述符集合中清除 </li><li>FD_ISSET(int fd, fd_set *fdset)－检测一个描述符是否就绪 </li></ul><p>在设置描述符集合前应该先调用FD_ZERO将集合清空，每次调用select函数前应该重新设置这3个集合 </p><p>三个集合中的描述符可以交叉 </p><p><del>不过现在的服务器一般不使用select，select本质好像是On地查询，效率不高，一般使用poll等函数方法</del></p><h2 id="socket选项"><a href="#socket选项" class="headerlink" title="socket选项"></a>socket选项</h2><p>获取或设置socket选项</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsockopt</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> level, <span class="keyword">int</span> optname, <span class="keyword">void</span> *optval,sock_len *optlen)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setsockopt</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> level, <span class="keyword">int</span> optname, <span class="keyword">void</span> *optval,sock_len optlen)</span></span>;</span><br></pre></td></tr></table></figure><p>返回值： 0成功，-1失败</p><p>参数：</p><ul><li><p>level 选项级别</p><ul><li>SOL_SOCKET —通用socket选项 </li><li>IPPROTO_IP—IP选项 </li><li>IPPROTO_TCP—TCP选项 </li></ul></li><li><p>optname 选项名称</p><ul><li><p>一般通用socket选项</p><ul><li><p>SO_KEEPALIVE</p><p>设置该选项后，2小时内没有数据交换时，TCP协议将自动发送探测数据包，检查网络连接</p></li><li><p>SO_RCVBUF和SO_SNDBUF</p><p>设置发送和接收数据缓冲区的大小（在连接建立以前设置）</p></li><li><p>SO_RCVTIMEO和SO_SNDTIMEO</p><p>设置发送和接收超时，当指定时间内数据没有成功接收或发送，发送和接收函数将返回。</p></li><li><p>SO_REUSEADDR</p><p>快速重启服务器程序</p><p>启动服务器程序的多个实例（绑定本地IP地址的多个别名）</p></li></ul></li><li><p>IP选项</p><p>IP_HDRINCL：是否需要自己建立IP数据包首部，适用于原始socket</p></li><li><p>TCP选项</p><ul><li>TCP_MAXSEG－TCP协议最大数据段长度</li><li>TCP_NODELAY－小数据包是否延迟发送（<strong>Nagle算法</strong>）</li></ul></li></ul></li><li><p>optal选项值</p></li><li><p>opelen选项长度/存放选项长度的指针</p></li></ul><h2 id="fcntl"><a href="#fcntl" class="headerlink" title="fcntl"></a>fcntl</h2><p>修改文件的属性。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fcntl</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">int</span> cmd,…)</span></span></span><br></pre></td></tr></table></figure><p>返回值： 非负成功，-1失败</p><p>操作类型:</p><div class="table-container"><table><thead><tr><th style="text-align:center">Cmd</th><th style="text-align:center">参数</th><th style="text-align:center">返回值</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">F_GETFL</td><td style="text-align:center">0</td><td style="text-align:center">fd</td><td style="text-align:center">获取描述符标志</td></tr><tr><td style="text-align:center">F_SETFL</td><td style="text-align:center">O_NONBLOCK</td><td style="text-align:center">0, -1</td><td style="text-align:center">设置套接字为非阻塞式</td></tr><tr><td style="text-align:center">F_GETOWN</td><td style="text-align:center">int*</td><td style="text-align:center">0, -1</td><td style="text-align:center">取得套接字的所有者</td></tr><tr><td style="text-align:center">F_SETOWN</td><td style="text-align:center">int</td><td style="text-align:center">0, -1</td><td style="text-align:center">设置套接字的所有者</td></tr></tbody></table></div><h3 id="套接字的阻塞方式"><a href="#套接字的阻塞方式" class="headerlink" title="套接字的阻塞方式"></a>套接字的阻塞方式</h3><p>设置socket为阻塞方式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> flags;</span><br><span class="line">flags=fcntl(fd,F_GETFL,<span class="number">0</span>);</span><br><span class="line">flags|=O_NONBLOCK;</span><br><span class="line">fcntl(fd,F_SETFL,flags);</span><br></pre></td></tr></table></figure><p>设置socket为非阻塞方式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> flags;</span><br><span class="line">flags=fcntl(fd,F_GETFL,<span class="number">0</span>);</span><br><span class="line">flags&amp;=~O_NONBLOCK;</span><br><span class="line">fcntl(fd,F_SETFL,flags); </span><br></pre></td></tr></table></figure><p>一般情况下，socket<strong>默认</strong>是阻塞方式的，也就是说套接字会阻塞，直到客户机发送信息为止。</p><p>在非阻塞方式下，如果没有接收到消息套接字也会返回，那么主程序为了不断监听信息就得<strong>一直轮询</strong>套接字，占用大量的CPU资源。</p><p>而在多套接字情况下，由于阻塞方式的存在，多套接字可能不能很好的同时监听。</p><p>有一些解决方案</p><ul><li>多线程。但是线程需要占用资源，linux大概能开小几百的套接字线程。</li><li>IO多路复用：select、poll、epoll等，同时检测多个套接字是否就绪。</li></ul><h4 id="参考博客-2"><a href="#参考博客-2" class="headerlink" title="参考博客"></a>参考博客</h4><p><a href="https://blog.csdn.net/wxlfreewind/article/details/108274842">为什么网络socket编程是阻塞的？因为非阻塞轮询占CPU，用多线程和IO复用</a></p><h2 id="ioctl"><a href="#ioctl" class="headerlink" title="ioctl"></a>ioctl</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ioctl</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">int</span> req,…)</span></span>;</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th style="text-align:center">req</th><th style="text-align:center">参数</th><th style="text-align:center">返回值</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">SIOCATMARK</td><td style="text-align:center">int*</td><td style="text-align:center">0, -1</td><td style="text-align:center">是否到达带外标记</td></tr><tr><td style="text-align:center">FIOASYNC</td><td style="text-align:center">int*</td><td style="text-align:center">0, -1</td><td style="text-align:center">异步I/O标志</td></tr><tr><td style="text-align:center">FIONREAD</td><td style="text-align:center">int*</td><td style="text-align:center">0, -1</td><td style="text-align:center">缓存区中有多少字节数据可读</td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> Socket </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>gym-102956</title>
      <link href="/2021/02/21/gym-102956/"/>
      <url>/2021/02/21/gym-102956/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><span id="more"></span><p><strong><a href="[2020-2021 Winter Petrozavodsk Camp, Belarusian SU Contest (XXI Open Cup, Grand Prix of Belarus">题目链接</a>](<a href="https://codeforces.ml/gym/102956">https://codeforces.ml/gym/102956</a>))</strong></p><h2 id="G-prufer-amp-amp-树上组合计数问题"><a href="#G-prufer-amp-amp-树上组合计数问题" class="headerlink" title="G. prufer &amp;&amp; 树上组合计数问题"></a>G. prufer &amp;&amp; 树上组合计数问题</h2><p>当n为奇数时显然为0.</p><p>当n为偶数时，首先将n个点分组成两个两个，有$\frac {n!}{(\frac n 2)!2^{\frac n2}}$种 （先排列起来，然后除去n/2组交换顺序的情况，再除去组内的两种组合情况）</p><p>上述分式化简结果为$(n-1)!!$ </p><p><del>没有想到怎么样直接地化简得来，只能用数学归纳法证明结论的正确性。</del></p><p>另一方面，由凯莱公式可以知道，n/2个节点的带标号完全图生成树有$(\frac n 2) ^ {\frac n 2 -2}$个</p><p>而这n/2个”节点”都是由一对真实的单点组成的，所以n/2树上的任意一条边，都是由2个点对组合构成的，共有4种可能的结果。</p><p>那么当n/2个点对已经被指定后，该树可能的形态就有$(\frac n 2) ^ {\frac n 2 -2} * 4^{\frac n 2 -1}$种</p><p>所以综上考虑，总的方案数就是$(n-1)!! <em> (\frac n 2) ^ {\frac n 2 -2} </em> 4^{\frac n 2 -1}$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">5e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> par[maxn], prufer[maxn], du[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">encode</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ptr = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">if</span>(ptr == <span class="number">-1</span> &amp;&amp; du[i] == <span class="number">1</span>) ptr = i;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> leaf = ptr;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">2</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> next = prufer[i] = par[leaf];</span><br><span class="line">        <span class="keyword">if</span>(--du[next] == <span class="number">1</span> &amp;&amp; next &lt; ptr) leaf = next;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            ptr++;</span><br><span class="line">            <span class="keyword">while</span>(du[ptr] != <span class="number">1</span>) ptr++;</span><br><span class="line">            leaf = ptr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rebuild</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ptr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(du[ptr] != <span class="number">1</span>) ptr++;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> leaf = ptr;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">2</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> next = par[leaf] = prufer[i];</span><br><span class="line">        <span class="keyword">if</span>(--du[next] == <span class="number">1</span> &amp;&amp; next &lt; ptr) leaf = next;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            ptr++;</span><br><span class="line">            <span class="keyword">while</span>(du[ptr] != <span class="number">1</span>) ptr++;</span><br><span class="line">            leaf = ptr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    par[leaf] = n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hsh</span><span class="params">(<span class="keyword">int</span> a[maxn], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) ans ^= (i + <span class="number">1</span>) * <span class="number">1ll</span> * a[i];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//    Fastin;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> op;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;op);</span><br><span class="line">    <span class="keyword">if</span>(op == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, par + i);</span><br><span class="line">            du[par[i]]++; du[i]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">encode</span>();</span><br><span class="line">        <span class="built_in">hsh</span>(prufer, n - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) du[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">2</span>; i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, prufer + i);</span><br><span class="line">            du[prufer[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">rebuild</span>();</span><br><span class="line">        <span class="built_in">hsh</span>(par + <span class="number">1</span>, n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 组合计数 </tag>
            
            <tag> 树 </tag>
            
            <tag> Prufer序列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线段树扩展</title>
      <link href="/2021/02/18/%E7%BA%BF%E6%AE%B5%E6%A0%91%E6%89%A9%E5%B1%95/"/>
      <url>/2021/02/18/%E7%BA%BF%E6%AE%B5%E6%A0%91%E6%89%A9%E5%B1%95/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><span id="more"></span><h2 id="CF-1083C-线段树二分-查询树上拥有最大MEX值的简单路径"><a href="#CF-1083C-线段树二分-查询树上拥有最大MEX值的简单路径" class="headerlink" title="CF 1083C 线段树二分 - 查询树上拥有最大MEX值的简单路径"></a><a href="https://codeforces.ml/contest/1083/problem/C">CF 1083C</a> 线段树二分 - 查询树上拥有最大MEX值的简单路径</h2><p>给出一棵树，树上所有点的点权是<code>[0, n - 1]</code>的一个排列</p><p>进行Q次操作：</p><ul><li>交换某两个点之间的点权</li><li>查询树上拥有最大MEX值的简单路径，输出MEX值</li></ul><p>维护一个线段树，线段树上区间[l, r]记录着数值[l, r]是否在一条简单路径内，如果是的话同时记录简单路径的两个端点</p><p>相比于一般的线段树比较不同的是up函数的设置，算法中采用了这样的办法：已经两条简单路径各自的两个端点，从这4个点中枚举2个点尝试作为新路径的端点，分别检查剩余两个点到这两个端点的距离之和是否等于路径本身的距离。</p><p>因为要查询两点的距离，所以掏出前阵子的点分树中O1 ST表</p><p>接下来在线段树上做二分，查询出最长的连续的前缀即可</p><p>复杂度$O(nlogn)$ 写的很挫 常数巨大 </p><p>在merge中及时的<code>break</code>和<code>return</code>、以及修改<code>vector&lt;int&gt; vec</code>为 <code>int vec[4]</code>才算卡过去</p><p><del>果然nlognlogn是不太可能通过 二分加线段树查询的算法不可行</del></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls (p &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs ((p &lt;&lt; 1) | 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mid ((l + r) &gt;&gt; 1)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-8</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, w[manx];</span><br><span class="line"><span class="keyword">int</span> head[manx], par[maxn], top = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span><span class="keyword">int</span> to, next;&#125;edge[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    edge[top].to = v;</span><br><span class="line">    edge[top].next = head[u];</span><br><span class="line">    par[v] = u;</span><br><span class="line">    haed[u] = top++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dfn[maxn &lt;&lt; <span class="number">1</span>], pos[manx], cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> dep[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> par)</span></span>&#123;</span><br><span class="line">    dfn[cnt] = now; pos[now] = cnt; cnt++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[now]; ~i; i = edge[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> to = edge[i].to; <span class="keyword">if</span>(to == par) <span class="keyword">continue</span>;</span><br><span class="line">        dep[to] = dep[now] + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(to, now);</span><br><span class="line">        dfn[cnt++] = now;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> TEMP&#123;</span><br><span class="line">    <span class="keyword">int</span> st[maxn &lt;&lt; <span class="number">1</span>][N];</span><br><span class="line">    <span class="comment">//通过深度数组获取st表, st维护区间中深度最小的节点标号</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getst</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt; i++) st[i][<span class="number">0</span>] = dfn[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; N; j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt; i++)&#123;</span><br><span class="line">                <span class="keyword">int</span> nxt = i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>));</span><br><span class="line">                <span class="keyword">if</span>(nxt &gt;= cnt) st[i][j] = st[i][j - <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(dep[st[i][j - <span class="number">1</span>]] &lt; dep[st[nxt][j - <span class="number">1</span>]]) st[i][j] = st[i][j - <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">else</span> st[i][j] = st[nxt][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//O1获取两点之间的距离</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getdis</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x == y) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="built_in">min</span>(pos[x], pos[y]), r = <span class="built_in">max</span>(pos[x], pos[y]);</span><br><span class="line">    <span class="keyword">int</span> k = (<span class="keyword">int</span>)(<span class="built_in">log2</span>(r - l) + eps);</span><br><span class="line">    <span class="keyword">int</span> lca = TEMP::st[l][k];</span><br><span class="line">    <span class="keyword">if</span>(dep[lca] &gt; dep[TEMP::st[r - (<span class="number">1</span> &lt;&lt; k) + <span class="number">1</span>][k]]) lca = TEMP::st[r - (<span class="number">1</span> &lt;&lt; k) + <span class="number">1</span>][k];</span><br><span class="line">    <span class="keyword">return</span> dep[x] + dep[y] - <span class="number">2</span> * dep[lca];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线段树st上区间[l, r]表示数值[l, r]是否在一条简单路径上，同时维护简单路径的两个端点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NODE</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">    <span class="built_in">NODE</span>()&#123;l = r = <span class="number">-1</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">NODE st[maxn &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> vec[<span class="number">4</span>];</span><br><span class="line"><span class="comment">//检查a和b所代表的两个简单路径是否能被一个新的简单路径包含</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dis = <span class="built_in">getdis</span>(vec[i], vec[j]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++) <span class="keyword">if</span>(k != i &amp;&amp; k != j)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">getdis</span>(vec[k], vec[i]) + <span class="built_in">getdis</span>(vec[k], vec[j]) != dis) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">NODE <span class="title">merge</span><span class="params">(NODE &amp;a, NODE &amp;b)</span></span>&#123;</span><br><span class="line">    NODE temp;</span><br><span class="line">    <span class="keyword">if</span>(a.l == <span class="number">-1</span> || b.l == <span class="number">-1</span>) <span class="keyword">return</span> temp;</span><br><span class="line">    vec[<span class="number">0</span>] = a.l; vec[<span class="number">1</span>] = a.r; vec[<span class="number">2</span>] = b.l; vec[<span class="number">3</span>] = b.r;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; <span class="number">4</span>; j++) <span class="keyword">if</span>(<span class="built_in">check</span>(i, j))&#123;</span><br><span class="line">        temp.l = vec[i];</span><br><span class="line">        temp.r = vec[j];</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//k值现在处在节点x的位置</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r &amp;&amp; l == k)&#123;</span><br><span class="line">        st[p].l = st[p].r = x;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(k &lt;= mid) <span class="built_in">update</span>(ls, l, mid, k, x);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">update</span>(rs, mid + <span class="number">1</span>, r, k, x);</span><br><span class="line">    st[p] = <span class="built_in">merge</span>(st[ls], st[rs]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据ans.first尝试缀上某个前缀</span></span><br><span class="line">pair&lt;<span class="keyword">int</span>, NODE&gt; ans;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(st[p].l != <span class="number">-1</span> &amp;&amp; ans.first + <span class="number">1</span> == l)&#123;</span><br><span class="line">        NODE temp;</span><br><span class="line">        <span class="keyword">if</span>(ans.first == <span class="number">-1</span>)&#123;</span><br><span class="line">            ans.first = r;</span><br><span class="line">            ans.second = st[p];</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> temp = <span class="built_in">merge</span>(ans.second, st[p]);</span><br><span class="line">        <span class="keyword">if</span>(temp.l != <span class="number">-1</span>)&#123;</span><br><span class="line">            ans.first = r;</span><br><span class="line">            ans.second = temp;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">query</span>(ls, l, mid);</span><br><span class="line">    <span class="keyword">if</span>(ans.first == mid) <span class="built_in">query</span>(rs, mid + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//    Fastin;</span></span><br><span class="line">    <span class="built_in">scnaf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="built_in">clr</span>(head, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, w + i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x; <span class="built_in">scnaf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">        <span class="built_in">add</span>(x, i);</span><br><span class="line">    &#125;</span><br><span class="line">    TEMP::<span class="built_in">getst</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">update</span>(<span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>, w[i], i);</span><br><span class="line">    <span class="keyword">int</span> q; <span class="built_in">scnaf</span>(<span class="string">&quot;%d&quot;</span>, &amp;q);</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="keyword">int</span> op; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;op);</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> x, y; <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">            <span class="built_in">update</span>(<span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>, w[y], x);</span><br><span class="line">            <span class="built_in">update</span>(<span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>, w[x], y);</span><br><span class="line">            <span class="built_in">swap</span>(w[x], w[y]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            ans.first = <span class="number">-1</span>;</span><br><span class="line">            <span class="built_in">query</span>(<span class="number">1</span>, <span class="number">0</span>, n <span class="number">-1</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans.first + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="bzoj3073-线段树优化建图"><a href="#bzoj3073-线段树优化建图" class="headerlink" title="bzoj3073 线段树优化建图"></a><a href="https://darkbzoj.tk/problem/3073">bzoj3073</a> 线段树优化建图</h2><p>给出n个节点、m种边。</p><p>对于某一种边而言，有4个参数：a, b, c, d，表示对于所有的$a \leq x \leq b, c \leq y \leq d$都有一条无向边$<x, y>$相连。</p><p>询问对于某个指定点p而言，到其他所有点的最短距离</p><p>数据范围 $n \leq 5e5, m \leq 1e5$</p><h3 id="线段树优化建图"><a href="#线段树优化建图" class="headerlink" title="线段树优化建图"></a>线段树优化建图</h3><p>朴素的做法是对每一种边都用<strong>虚点</strong>刻画相连关系，即将所有的[a, b]连向虚点u，再将u连向所有的[c, d]。时空复杂度为$O(mn^2)$</p><p>线段树优化建图则利用了线段树的分治特性，不再暴力地将所有的[a, b]或[c, d]节点与虚点相连，而是将线段树上对应的区间节点与虚点相连，这样可以保证对于任意一段区间，都只有$logn$个节点与虚点相连，空间复杂度$O(m*log^2n)$。</p><p>具体的实现如下：</p><p>建立两棵<strong>线段树结构</strong>的树形结构，第一棵从父亲节点向儿子节点连边，称为树A，第二棵从儿子节点向父亲节点连边，称为树B。A树的所有叶子相应地连向B中所有的叶子。</p><p>接下来每读入一组abcd, 将将B树中对应[a, b]区间的节点连向虚点，再将该虚点连向A树中[c, d]区间对应的节点。反过来再对[c, d]和[a, b]进行同样的连接。为了使得权值总为1，可以不妨使得入边权为1，出边权为0。</p><p>这样，便利用了线段树的结构完成了较为高效的图的建立。</p><h3 id="01-BFS"><a href="#01-BFS" class="headerlink" title="01 BFS"></a>01 BFS</h3><p>由于该图边权仅为0或1，所以考虑使用01BFS完成最短路的求解。</p><p>具体实现如下（使用双端队列）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(队列非空)&#123;</span><br><span class="line">  取出队首元素<span class="function">now</span></span><br><span class="line"><span class="function">  <span class="title">for</span><span class="params">(now的相邻节点)</span></span>&#123;</span><br><span class="line">    更新距离</span><br><span class="line">    <span class="keyword">if</span>(边权为<span class="number">0</span>) 添加到队首</span><br><span class="line">    <span class="keyword">else</span> 添加到队尾</span><br><span class="line">  &#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><p>在开设A、B两棵树、添加有向边的时候可以精心选择偏移量等数值，使得快速获取想要的下标。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mid ((l + r) &gt;&gt; 1)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">5e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxe = <span class="number">4e7</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> M;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, p;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span><span class="keyword">int</span> to, next, w;&#125;edge[maxe];</span><br><span class="line"><span class="keyword">int</span> head[maxe], top = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    edge[top].to = v;</span><br><span class="line">    edge[top].w = w;</span><br><span class="line">    edge[top].next = head[u];</span><br><span class="line">    head[u] = top++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>, pos[maxn], ls[maxn &lt;&lt; <span class="number">3</span>], rs[maxn &lt;&lt; <span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> now = cnt++;</span><br><span class="line">    <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">        <span class="built_in">add</span>(now, now + M, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> pos[l] = now;</span><br><span class="line">    &#125;</span><br><span class="line">    ls[now] = <span class="built_in">build</span>(l, mid);</span><br><span class="line">    <span class="built_in">add</span>(now, ls[now], <span class="number">0</span>); <span class="built_in">add</span>(ls[now] + M, now + M, <span class="number">0</span>);</span><br><span class="line">    rs[now] = <span class="built_in">build</span>(mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="built_in">add</span>(now, rs[now], <span class="number">0</span>); <span class="built_in">add</span>(rs[now] + M, now + M, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> now;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> u, <span class="keyword">int</span> type)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R)&#123;</span><br><span class="line">        <span class="keyword">if</span>(type) <span class="built_in">add</span>(p + M, u, <span class="number">1</span>); <span class="keyword">else</span> <span class="built_in">add</span>(u, p, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= mid) <span class="built_in">update</span>(ls[p], l, mid, L, R, u, type);</span><br><span class="line">    <span class="keyword">if</span>(R &gt; mid) <span class="built_in">update</span>(rs[p], mid + <span class="number">1</span>, r, L, R, u, type);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dis[<span class="number">5000000</span>];</span><br><span class="line">deque&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">clr</span>(dis, <span class="number">0x3f</span>);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) q.<span class="built_in">pop_back</span>();</span><br><span class="line">    </span><br><span class="line">    dis[pos[p]] = <span class="number">0</span>; q.<span class="built_in">push_back</span>(pos[p]);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">int</span> now = q.<span class="built_in">front</span>(); q.<span class="built_in">pop_front</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = head[now]; ~i; i = edge[i].next)&#123;</span><br><span class="line">            <span class="keyword">int</span> to = edge[i].to; <span class="keyword">if</span>(dis[to] != <span class="number">0x3f3f3f3f</span>) <span class="keyword">continue</span>;</span><br><span class="line">            dis[to] = dis[now] + edge[i].w;</span><br><span class="line">            <span class="keyword">if</span>(edge[i].w) q.<span class="built_in">push_back</span>(to);</span><br><span class="line">            <span class="keyword">else</span> q.<span class="built_in">push_front</span>(to);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//    Fastin;</span></span><br><span class="line">    <span class="built_in">clr</span>(head, <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;n, &amp;m, &amp;p);</span><br><span class="line">    M = n &lt;&lt; <span class="number">2</span>; <span class="built_in">build</span>(<span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> a, b, c, d; <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d %d&quot;</span>, &amp;a, &amp;b, &amp;c, &amp;d);</span><br><span class="line">        <span class="comment">//加入虚点i + 2M与i + 1 + 2M;</span></span><br><span class="line">        <span class="built_in">update</span>(<span class="number">0</span>, <span class="number">1</span>, n, a, b, <span class="number">2</span> * i + <span class="number">2</span> * M, <span class="number">1</span>); <span class="built_in">update</span>(<span class="number">0</span>, <span class="number">1</span>, n, c, d, <span class="number">2</span> * i + <span class="number">2</span> * M, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">update</span>(<span class="number">0</span>, <span class="number">1</span>, n, c, d, <span class="number">2</span> * i + <span class="number">2</span> * M + <span class="number">1</span>, <span class="number">1</span>); <span class="built_in">update</span>(<span class="number">0</span>, <span class="number">1</span>, n, a, b, <span class="number">2</span> * i + <span class="number">2</span> * M + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">bfs</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, dis[pos[i]]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="线段树合并"><a href="#线段树合并" class="headerlink" title="线段树合并"></a>线段树合并</h2><p>线段树合并是这样的一种操作：</p><p>当构造规则指定、左右边界确定后，任意两棵线段树的结构一定相同，所以我们可以据此将两颗边界相同的线段树进行合并。</p><h3 id="CF-600E-子树最多出现次数颜色和的查询"><a href="#CF-600E-子树最多出现次数颜色和的查询" class="headerlink" title="CF 600E 子树最多出现次数颜色和的查询"></a><a href="https://codeforces.ml/problemset/problem/600/E">CF 600E</a> 子树最多出现次数颜色和的查询</h3><p>给出一棵n节点的树，每个节点具有一个颜色。</p><p>输出在以1为根时，每个节点及其子树上所有节点中最多数量的颜色的和。</p><p>$n \leq 1e5, c_i \leq n$</p><p>每插入一个节点，会产生logn个新节点，因而总共至多产生nlogn个新节点。</p><p>而在每一次merge时，会合并掉一个节点，合并的复杂度是$O(1)$，所以至多进行nlogn次合并。</p><p>因而线段树合并的总体复杂度是$O(nlogn)$</p><p>相比于$O(nlog^2n)$的启发式合并复杂度更小，更好写。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 动态开点线段树：</span></span><br><span class="line"><span class="comment">    - 插入一个节点</span></span><br><span class="line"><span class="comment">    - 合并两棵树</span></span><br><span class="line"><span class="comment"> 维护出现最多的次数的颜色的和，记录两个值(出现次数，颜色和)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mid ((l + r) &gt;&gt; 1)</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1e5</span> * <span class="number">20</span> * <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> haed[maxn], top = <span class="number">0</span>, root[maxn];</span><br><span class="line">star edge[maxn &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    edge[top].to = v;</span><br><span class="line">    edge[top].next = head[u];</span><br><span class="line">    head[u] = top++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NODE</span>&#123;</span><span class="keyword">int</span> mx; ll sum;&#125;;</span><br><span class="line">NODE st[M];</span><br><span class="line"><span class="keyword">int</span> ls[M], rs[M], cnt = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//cnt必须从1开始！这是由merge的实现所决定的！</span></span><br><span class="line"><span class="comment">//加入一个单点作为初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> &amp;p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!p) p = cnt++;</span><br><span class="line">    <span class="keyword">if</span>(l == r &amp;&amp; l == k)&#123;</span><br><span class="line">        st[p].mx = <span class="number">1</span>; st[p].sum = k;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(k &lt;= mid)&#123;</span><br><span class="line">        <span class="built_in">update</span>(ls[p], l, mid, k);</span><br><span class="line">        st[p] = st[ls[p]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">update</span>(rs[p], mid + <span class="number">1</span>, r, k);</span><br><span class="line">        st[p] = st[rs[p]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(st[ls[p]].mx &gt; st[rs[p]].mx) st[p] = st[ls[p]];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(st[ls[p]].mx &lt; st[rs[p]].mx) st[p] = st[rs[p]];</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        st[p].mx = st[ls[p]].mx;</span><br><span class="line">        st[p].sum = st[ls[p]].sum + st[rs[p]].sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将r1与r2对应的两棵结构相同的线段树进行合并，返回值为合并后的树的标号</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> r1, <span class="keyword">int</span> r2, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!r1) <span class="keyword">return</span> r2;</span><br><span class="line">    <span class="keyword">if</span>(!r2) <span class="keyword">return</span> r1;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">        st[r1].mx += st[r2].mx;</span><br><span class="line">        <span class="keyword">return</span> r1;</span><br><span class="line">    &#125;</span><br><span class="line">    ls[r1] = <span class="built_in">merge</span>(ls[r1], ls[r2], l, mid);</span><br><span class="line">    rs[r1] = <span class="built_in">merge</span>(rs[r1], rs[r2], mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="built_in">up</span>(r1);</span><br><span class="line">    <span class="keyword">return</span> r1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll ans[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> par)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[now]; ~i; i = edge[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> to = edge[i].to; <span class="keyword">if</span>(to == par) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(to, now);</span><br><span class="line">        root[now] = <span class="built_in">merge</span>(root[now], root[to], <span class="number">1</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">    ans[now] = st[root[now]].sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//    Fastin;</span></span><br><span class="line">    <span class="built_in">clr</span>(head, <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> c; <span class="built_in">scnaf</span>(<span class="string">&quot;%d&quot;</span>, &amp;c);</span><br><span class="line">        <span class="built_in">udpate</span>(root[i], <span class="number">1</span>, n, c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> u, v; <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">        <span class="built_in">add</span>(u, v); <span class="built_in">add</span>(v, u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">prt</span>(ans + <span class="number">1</span>, n);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="更多的例题-（未补"><a href="#更多的例题-（未补" class="headerlink" title="更多的例题 （未补"></a>更多的例题 （未补</h3><p><a href="https://www.luogu.com.cn/blog/styx-ferryman/xian-duan-shu-ge-bing-zong-ru-men-dao-fang-qi">https://www.luogu.com.cn/blog/styx-ferryman/xian-duan-shu-ge-bing-zong-ru-men-dao-fang-qi</a></p><h2 id="线段树分裂"><a href="#线段树分裂" class="headerlink" title="线段树分裂"></a>线段树分裂</h2><h2 id="区间最值操作与历史最值操作"><a href="#区间最值操作与历史最值操作" class="headerlink" title="区间最值操作与历史最值操作"></a>区间最值操作与历史最值操作</h2>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>edu-104-div2</title>
      <link href="/2021/02/16/edu-104-div2/"/>
      <url>/2021/02/16/edu-104-div2/</url>
      
        <content type="html"><![CDATA[<p>被set爆锤的一场</p><p>如果自定义了比较符，那么应该要仔细的审查<strong>比较符的定义</strong>是否符合预期！特别是<strong>两个对象相等</strong>的情况！</p><p>不然在进行set.erase()/set.insert()时会出现头de烂都看不出来的的bug</p>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CF-699-div2</title>
      <link href="/2021/02/06/CF-699-div2/"/>
      <url>/2021/02/06/CF-699-div2/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><span id="more"></span><h2 id="A-签到"><a href="#A-签到" class="headerlink" title="A 签到"></a>A 签到</h2><p>拉垮的第一题 得写半天</p><h2 id="B-模拟暴力"><a href="#B-模拟暴力" class="headerlink" title="B 模拟暴力"></a>B 模拟暴力</h2><p>发现有效的范围比较小后就很好写了</p><h2 id="C-模拟"><a href="#C-模拟" class="headerlink" title="C 模拟"></a>C 模拟</h2><p>倒序处理，没啥意思，但是自己写起来还是写的很丑</p><h2 id="D-构造"><a href="#D-构造" class="headerlink" title="D 构造"></a>D 构造</h2><p>如果出现一对标号相同的边那么随意构造；不然的话检查m的奇偶性，如果m是奇数的话反复横跳，如果m是偶数的话还得继续考虑m/2的奇偶性，这样分类才算完全。</p><h2 id="E-DP-（补题"><a href="#E-DP-（补题" class="headerlink" title="E DP （补题"></a>E DP （补题</h2><p>场上用了残余的二十来分钟考虑了一阵子，妄想用一些神秘的可持久化权值线段树云云，但是好像复杂度也是n2级别的样子</p><p>正确的做法是dp</p><p>考虑这样的dp数组：dp[i]表示使得a[i..n]符合约束的最多的不需要移动的元素数量</p><p>再开设一些辅助数组：l[i]表示颜色i出现的最左边的位置，r[i]表示颜色i出现的最右边的位置，cnt[i]表示颜色i出现的次数，now[i]表示目前转移状态下颜色i出现的次数</p><p>那么从后往前转移，假设当前考虑下标i所在的位置。</p><p>如果认为a[i]不移动：</p><ul><li>$i == l[a[i]]$，即i位置的颜色是最后一次出现，则$dp[i] = dp[r[a[i]] + 1] + cnt[a[i]]$</li><li>else，dp[i] = now[a[i]]</li></ul><p>这是因为当i处元素还不是最左边的元素时，$r[a[i]] + 1$及以后的元素也都需要往后挪动一次，不然$l[a[i]]$没有办法和剩余的$a[i]$汇合；而当i已经是最左边的元素时，$r[a[i]] + 1$及其以后的元素不一定都要挪动一次，他们不需要为更多的$a[i]$腾出空间</p><p>如果认为a[i]移动，显然$dp[i] = dp[i +1]$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> itn maxn = <span class="number">5e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> a[maxn], l[maxn], r[maxn], cnt[maxn], now[maxn], dp[manx];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// Fastin;</span></span><br><span class="line">    <span class="built_in">scnaf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scnaf</span>(<span class="string">&quot;%d&quot;</span>, a + i);</span><br><span class="line">    <span class="keyword">for</span>(itn i = <span class="number">0</span>; i &lt; n; i++) r[a[i]] = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        l[a[i]] = i; cnt[a[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dp[n] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        now[a[i]]++;</span><br><span class="line">        <span class="keyword">if</span>(l[a[i]] == i) dp[i] = dp[r[a[i]] + <span class="number">1</span>] + cnt[a[i]];</span><br><span class="line">        <span class="keyword">else</span> dp[i] = now[a[i]];</span><br><span class="line">        dp[i] = <span class="built_in">max</span>(dp[i], dp[i + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// prt(dp, n);</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, n - dp[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>点分树</title>
      <link href="/2021/02/05/%E7%82%B9%E5%88%86%E6%A0%91/"/>
      <url>/2021/02/05/%E7%82%B9%E5%88%86%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p><strong><a href="https://www.luogu.com.cn/problem/P6329">P6329 点分树模版 震波</a></strong></p><span id="more"></span><p>给出n个节点的树，树上节点有点权$w_i$</p><p>进行q次强制在线操作：</p><ul><li>操作0: 查询距离节点x距离小于等于y的所有节点的点权和</li><li>操作1: 将节点x的值修改为y</li></ul><p>该题主要关心节点之间的距离，所以一定程度上与树本身的拓扑结构无关，因而考虑将原树重构为结构优秀的点分树，该树的高度不超过$logn$。重构后对每个点开桶，tong[i]记录该节点所有与之距离为i的孩子的点权和。因为点分树结构优秀，所以空间消耗仅为$O(nlogn)$。</p><p>这样，类似于点分治，对某个节点x的查询就相当于分治地查询x的所有祖先作出的贡献。</p><p>但同样类似于点分治，对某节点u的父亲par[u]进行统计时，有可能会出现和节点u贡献重复的部分，因而对父亲节点进行统计前应该将当前节点可能算重的贡献减去，这样才能不重复地计算点权和。而由于<strong>点分树完全破坏了原树的拓扑结构</strong>，因而仅仅知道u节点所有孩子对u的贡献(即上述的tong)是不能够通过<code>距离+1</code>等简单的手段知道u节点所有孩子对par[u]的贡献的，所以对每个节点我们应该开两个桶，一个记录对自身的贡献，一个记录对父亲的贡献。而该题要求能单点修改桶中权值，区间查询桶的前缀和，因而该桶至少应该是bit，而由于本人太菜不擅长bit，就使用动态开点的线段树完成动态的修改、查询。当修改时，不断向上爬，根据距离不断地修改两棵线段树；当查询时，不断地向上爬，去除重复的部分，求和统计。</p><p>此外，为了快速求原树中两点的距离，我们花费$O(nlogn)$的时间、空间在dfn序上建立st表，$O(1)$地完成每次的查询。</p><p>总体时间复杂度大概是$O(nlog^2n)$</p><p>树套树难写的一比，春节前写到自闭，昨天晚上重新写写到半夜总算过了。</p><p><del>码力实在太挫了</del></p><p>有一些坑点放在<a href="http://rqdmap.top/2020/06/17/template/">template</a>里进行注解。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mid ((l + r) &gt;&gt; 1)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> manx = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="comment">//根据dfn数组的长度决定N(即N = log2(cnt), cnt = maxn &lt;&lt; 1)</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, q;</span><br><span class="line"><span class="keyword">int</span> w[manx];</span><br><span class="line"><span class="comment">//动态开点的单点修改、区间求和线段树</span></span><br><span class="line"><span class="comment">//维护两个st，一个是u子树对u的贡献，另一个是u子树对par[u]的贡献（如果有的话）</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = maxn * N * <span class="number">4</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SEG</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> root[maxn];</span><br><span class="line">    <span class="keyword">int</span> st[M], ls[M], rs[M], top = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> now = top++;</span><br><span class="line">        <span class="keyword">if</span>(l == r) <span class="keyword">return</span> now;</span><br><span class="line">        ls[now] = <span class="built_in">build</span>(l, mid);</span><br><span class="line">        rs[now] = <span class="built_in">build</span>(mid + <span class="number">1</span>, r);</span><br><span class="line">        <span class="keyword">return</span> now;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;st[p] = st[ls[p]] + st[rs[p]];&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>(k &gt;= l &amp;&amp; k &lt;= r);</span><br><span class="line">        <span class="keyword">if</span>(l == r &amp;&amp; l == k)&#123;</span><br><span class="line">            st[p] += x;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(k &lt;= mid) <span class="built_in">add</span>(ls[p], l, mid, k, x);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">add</span>(rs[p], mid + <span class="number">1</span>, r, k, x);</span><br><span class="line">        <span class="built_in">up</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(R &lt; L) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R) <span class="keyword">return</span> st[p];</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(L &lt;= mid) ans += <span class="built_in">query</span>(ls[p], l, mid, L, R);</span><br><span class="line">        <span class="keyword">if</span>(R &gt; mid) ans += <span class="built_in">query</span>(rs[p], mid + <span class="number">1</span>, r, L, R);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;seg[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; E;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TREE</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> head[maxn], par[manx], top = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">star</span>&#123;</span><span class="keyword">int</span> to, next;&#125;;</span><br><span class="line">    star edge[maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">TREE</span>()&#123;<span class="built_in">clr</span>(head, <span class="number">-1</span>); top = <span class="number">0</span>;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">        edge[top].to = v;</span><br><span class="line">        edge[top].next = head[u];</span><br><span class="line">        head[u] = top++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; &amp;E)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> e: E)&#123;</span><br><span class="line">            <span class="built_in">add</span>(e.first, e.second);</span><br><span class="line">            par[e.second] = e.first;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mx[maxn], sze[maxn], vis[maxn], root = <span class="number">0</span>, S;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getroot</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> par)</span></span>&#123;</span><br><span class="line">        sze[now] = <span class="number">1</span>; mx[now] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = head[now]; ~i; i = edge[i].next)&#123;</span><br><span class="line">            <span class="keyword">int</span> to = edge[i].to; <span class="keyword">if</span>(to == par || vis[to]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">getroot</span>(to, now);</span><br><span class="line">            sze[now] += sze[to];</span><br><span class="line">            mx[now] = <span class="built_in">max</span>(mx[now], sze[to]);</span><br><span class="line">        &#125;</span><br><span class="line">        mx[now] = <span class="built_in">max</span>(mx[now], S - sze[now]);</span><br><span class="line">        <span class="keyword">if</span>(mx[root] &gt; mx[now]) root = now;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当前分治中心为now，封锁住通往par的路径，函数返回重心</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> par)</span></span>&#123;</span><br><span class="line">        root = <span class="number">0</span>; <span class="built_in">getroot</span>(now, par);</span><br><span class="line">        <span class="keyword">int</span> rt = root; vis[rt] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = head[rt]; ~i; i = edge[i].next)&#123;</span><br><span class="line">            <span class="keyword">int</span> to = edge[i].to; <span class="keyword">if</span>(to == par || vis[to]) <span class="keyword">continue</span>;</span><br><span class="line">            S = sze[to];</span><br><span class="line">            E.<span class="built_in">push_back</span>(&#123;rt, <span class="built_in">divide</span>(to, rt)&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将树重构为点分树，点分数的边存放在E中，供tree[1].add调用；返回重构树的根</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rebuild</span><span class="params">()</span></span>&#123;</span><br><span class="line">        S = mx[<span class="number">0</span>] = n;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">divide</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//初始化dfn、pos数组，得到每个节点的深度dep</span></span><br><span class="line">    <span class="keyword">int</span> dfn[maxn &lt;&lt; <span class="number">1</span>], pos[manx], cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> dep[maxn];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> par)</span></span>&#123;</span><br><span class="line">        dfn[cnt] = now; pos[now] = cnt; cnt++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = head[now]; ~i; i = edge[i].next)&#123;</span><br><span class="line">            <span class="keyword">int</span> to = edge[i].to; <span class="keyword">if</span>(to == par) <span class="keyword">continue</span>;</span><br><span class="line">            dep[to] = dep[now] + <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(to, now);</span><br><span class="line">            dfn[cnt++] = now;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> st[maxn &lt;&lt; <span class="number">1</span>][N];</span><br><span class="line">    <span class="comment">//通过深度数组获取st表, st维护区间中深度最小的节点标号</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getst</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt; i++) st[i][<span class="number">0</span>] = dfn[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; N; j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt; i++)&#123;</span><br><span class="line">                <span class="keyword">int</span> nxt = i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>));</span><br><span class="line">                <span class="keyword">if</span>(nxt &gt;= cnt) st[i][j] = st[i][j - <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(dep[st[i][j - <span class="number">1</span>]] &lt; dep[st[nxt][j - <span class="number">1</span>]]) st[i][j] = st[i][j - <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">else</span> st[i][j] = st[nxt][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//O1获取两点之间的距离</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getdis</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == y) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="built_in">min</span>(pos[x], pos[y]), r = <span class="built_in">max</span>(pos[x], pos[y]);</span><br><span class="line">        <span class="keyword">int</span> k = (<span class="keyword">int</span>)(<span class="built_in">log2</span>(r - l) + eps);</span><br><span class="line">        <span class="keyword">int</span> lca = st[l][k];</span><br><span class="line">        <span class="keyword">if</span>(dep[lca] &gt; dep[st[r - (<span class="number">1</span> &lt;&lt; k) + <span class="number">1</span>][k]]) lca = st[r - (<span class="number">1</span> &lt;&lt; k) + <span class="number">1</span>][k];</span><br><span class="line">        <span class="keyword">return</span> dep[x] + dep[y] - <span class="number">2</span> * dep[lca];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取子树大小并初始化线段树</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ini</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> par)</span></span>&#123;</span><br><span class="line">        sze[now] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = head[now]; ~i; i = edge[i].next)&#123;</span><br><span class="line">            <span class="keyword">int</span> to = edge[i].to; <span class="keyword">if</span>(to == par) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">ini</span>(to, now);</span><br><span class="line">            sze[now] += sze[to];</span><br><span class="line">        &#125;</span><br><span class="line">        seg[<span class="number">0</span>].root[now] = seg[<span class="number">0</span>].<span class="built_in">build</span>(<span class="number">0</span>, sze[now]);</span><br><span class="line">        seg[<span class="number">1</span>].root[now] = seg[<span class="number">1</span>].<span class="built_in">build</span>(<span class="number">0</span>, sze[now] + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;tree[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//第k个城市上发生x的增量，当前处理到now节点，保证now节点一定是k的祖先</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> k, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dis = tree[<span class="number">0</span>].<span class="built_in">getdis</span>(now, k);</span><br><span class="line">    seg[<span class="number">0</span>].<span class="built_in">add</span>(seg[<span class="number">0</span>].root[now], <span class="number">0</span>, tree[<span class="number">1</span>].sze[now], dis, x);</span><br><span class="line">    <span class="keyword">if</span>(tree[<span class="number">1</span>].par[now])&#123;</span><br><span class="line">        dis = tree[<span class="number">0</span>].<span class="built_in">getdis</span>(tree[<span class="number">1</span>].par[now], k);</span><br><span class="line">        seg[<span class="number">1</span>].<span class="built_in">add</span>(seg[<span class="number">1</span>].root[now], <span class="number">0</span>, tree[<span class="number">1</span>].sze[now] + <span class="number">1</span>, dis, x);</span><br><span class="line">        <span class="built_in">add</span>(tree[<span class="number">1</span>].par[now], k, x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查询距离k城市距离小于等于x的价值和，当前处理到now</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> k, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> d = tree[<span class="number">0</span>].<span class="built_in">getdis</span>(now, k);</span><br><span class="line">    ans += seg[<span class="number">0</span>].<span class="built_in">query</span>(seg[<span class="number">0</span>].root[now], <span class="number">0</span>, tree[<span class="number">1</span>].sze[now], <span class="number">0</span>, x - d);</span><br><span class="line">    <span class="keyword">if</span>(tree[<span class="number">1</span>].par[now])&#123;</span><br><span class="line">        <span class="keyword">int</span> D = tree[<span class="number">0</span>].<span class="built_in">getdis</span>(tree[<span class="number">1</span>].par[now], k);</span><br><span class="line">        ans -= seg[<span class="number">1</span>].<span class="built_in">query</span>(seg[<span class="number">1</span>].root[now], <span class="number">0</span>, tree[<span class="number">1</span>].sze[now] + <span class="number">1</span>, <span class="number">0</span>, x - D);</span><br><span class="line">        ans += <span class="built_in">query</span>(tree[<span class="number">1</span>].par[now], k, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//     Fastin;</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, w + i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> u, v; <span class="built_in">scnaf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">        tree[<span class="number">0</span>].<span class="built_in">add</span>(u, v); tree[<span class="number">0</span>].<span class="built_in">add</span>(v, u);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    tree[<span class="number">0</span>].<span class="built_in">getst</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> root = tree[<span class="number">0</span>].<span class="built_in">rebuild</span>();</span><br><span class="line">    tree[<span class="number">1</span>].<span class="built_in">add</span>(E);</span><br><span class="line"></span><br><span class="line">    tree[<span class="number">1</span>].<span class="built_in">ini</span>(root, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">add</span>(i, i, w[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">whlie</span>(q--)&#123;</span><br><span class="line">        <span class="keyword">int</span> op, x, y; <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;op, &amp;x, &amp;y);</span><br><span class="line">        x ^= ans; y ^= ans;</span><br><span class="line">        <span class="keyword">if</span>(op)&#123;</span><br><span class="line">            <span class="built_in">add</span>(x, x, y - w[x]);</span><br><span class="line">            w[x] = y;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans = <span class="built_in">query</span>(x, x, y));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树 </tag>
            
            <tag> 点分树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>点分治</title>
      <link href="/2021/02/01/%E7%82%B9%E5%88%86%E6%B2%BB/"/>
      <url>/2021/02/01/%E7%82%B9%E5%88%86%E6%B2%BB/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><span id="more"></span><h2 id="洛谷-P3806"><a href="#洛谷-P3806" class="headerlink" title="洛谷 P3806"></a><a href="https://www.luogu.com.cn/problem/P3806">洛谷 P3806</a></h2><p>从一道经典的点分治问题入门</p><p>给出n个节点的树，树上的边有边权，进行m次查询，每次查询一个值k，询问是否存在一条两点间的路径使得路径上权值和为k</p><p>$n &lt;=10^4,m&lt;=10^2,k&lt;=10^7, w_i&lt;=10^4$</p><p>因为该题有多组查询，可以考虑一次点分后同时对m次查询进行处理，也可以考虑每次查询都进行一次点分。时间复杂度同为$O(nmlogn)$，但是后者因为会进行若干次点分，所以常数更大。</p><p>此外，为了能够$O(nlogn)$地进行统计，需要开设桶来加速统计结果。如果没有采用桶，而使用二分序列等方法，那么会多上一个log，应该是无法通过3806这题的，但是对于一些查询的k更大的题目，二分仍然有可取之处。故这里也贴上一份不能AC3806但是可能仍有用武之处的$O(nmlog^2n)$的代码（能顺利AC所有非TLE的点，但是正确性仍需更强的检验，使用时应更加谨慎）</p><h3 id="O-nmlog-2n-代码-不开桶"><a href="#O-nmlog-2n-代码-不开桶" class="headerlink" title="$O(nmlog^2n)$代码 不开桶"></a>$O(nmlog^2n)$代码 不开桶</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e4</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, k;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">star</span>&#123;</span><span class="keyword">int</span> to, next, w;&#125;;</span><br><span class="line"><span class="keyword">int</span> head[maxn], top = <span class="number">0</span>;</span><br><span class="line">star edge[maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    edge[top].to = v;</span><br><span class="line">    edge[top].next = head[u];</span><br><span class="line">    edge[top].w = w;</span><br><span class="line">    head[u] = top++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用getroot前应该初始化S！！！</span></span><br><span class="line"><span class="keyword">int</span> root = <span class="number">0</span>, S;</span><br><span class="line"><span class="keyword">int</span> vis[maxn], sze[maxn], mx[maxn];;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getroot</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> par)</span></span>&#123;</span><br><span class="line">    sze[u] = <span class="number">1</span>; mx[u] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = haed[u]; ~i; i = edge[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> to = edge[i].to; <span class="keyword">if</span>(vis[to] || to == par) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">getroot</span>(to, u);</span><br><span class="line">        sze[u] += sze[to];</span><br><span class="line">        mx[u] = <span class="built_in">max</span>(mx[u], sze[to]);</span><br><span class="line">    &#125;</span><br><span class="line">    mx[u] = <span class="built_in">max</span>(mx[u], S - sze[u]);</span><br><span class="line">    <span class="keyword">if</span>(mx[u] &lt; mx[root]) root = u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;ll&gt; dis;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> par, ll d)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; ~i; i = edge[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> to = edge[i].to; <span class="keyword">if</span>(vis[to] || to == par) <span class="keyword">continue</span>;</span><br><span class="line">        dis.<span class="built_in">push_back</span>(&#123;d + edge[i].w&#125;);</span><br><span class="line">        <span class="built_in">dfs</span>(to, u, d + edge[i].w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getcnt</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>)(<span class="built_in">upper_bound</span>(dis.<span class="built_in">begin</span>(), dis.<span class="built_in">end</span>(), x) - <span class="built_in">lower_bound</span>(dis.<span class="built_in">begin</span>(), dis.<span class="built_in">end</span>(), x));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取经过u的答案，路径长度有基础偏移值d</span></span><br><span class="line"><span class="function">ll <span class="title">fun</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    dis.<span class="built_in">clear</span>(); dis.<span class="built_in">push_back</span>(d); <span class="built_in">dfs</span>(u, <span class="number">0</span>, d);</span><br><span class="line">    <span class="built_in">sort</span>(dis.<span class="built_in">begin</span>(), dis.<span class="built_in">end</span>());</span><br><span class="line">    <span class="comment">//两条长度相同的路径和k</span></span><br><span class="line">    <span class="keyword">if</span>(k % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">        ll temp = <span class="built_in">getcnt</span>(k / <span class="number">2</span>);</span><br><span class="line">        ans += temp * (temp - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="comment">//两条长度不同的路径和为k</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>)dis.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(dis[i] + dis[i] &gt;= k) <span class="keyword">break</span>;</span><br><span class="line">        ans += <span class="built_in">getcnt</span>(k - dis[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//u是重心，考察以经过u的路径长度</span></span><br><span class="line"><span class="function">ll <span class="title">sove</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="comment">//封锁u节点，分治地寻找子树.</span></span><br><span class="line">    vis[u] = <span class="number">1</span>; ll ans = <span class="built_in">fun</span>(u, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; ~i; i = edge[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> to = edge[i].to; <span class="keyword">if</span>(vis[to]) <span class="keyword">continue</span>;</span><br><span class="line">        ans -= <span class="built_in">fun</span>(to, edge[i].w);</span><br><span class="line"></span><br><span class="line">        S = sze[to]; root = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">getroot</span>(to, u);</span><br><span class="line">        ans += <span class="built_in">sove</span>(root);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//    Fastin;</span></span><br><span class="line">    <span class="built_in">clr</span>(head, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n, m; <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> u, v, w; <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line">        <span class="built_in">add</span>(u, v, w); <span class="built_in">add</span>(v, u, w);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    mx[<span class="number">0</span>] = n; root = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;k);</span><br><span class="line">        S = n; <span class="built_in">clr</span>(vis, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">getroot</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        ll ans = <span class="built_in">sove</span>(root);</span><br><span class="line">        <span class="built_in">puts</span>(ans? <span class="string">&quot;AYE&quot;</span>: <span class="string">&quot;NAY&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="O-nmlogn-进行m次点分治-开桶-常数较大"><a href="#O-nmlogn-进行m次点分治-开桶-常数较大" class="headerlink" title="$O(nmlogn)$ 进行m次点分治 开桶 常数较大"></a>$O(nmlogn)$ 进行m次点分治 开桶 常数较大</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e4</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, k;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">star</span>&#123;</span><span class="keyword">int</span> to, next, w;&#125;;</span><br><span class="line"><span class="keyword">int</span> head[maxn], top = <span class="number">0</span>;</span><br><span class="line">star edge[maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    edge[top].to = v;</span><br><span class="line">    edge[top].next = head[u];</span><br><span class="line">    edge[top].w = w;</span><br><span class="line">    head[u] = top++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用getroot前应该初始化S！！！</span></span><br><span class="line"><span class="keyword">int</span> root = <span class="number">0</span>, S;</span><br><span class="line"><span class="keyword">int</span> vis[maxn], sze[maxn], mx[maxn];;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getroot</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> par)</span></span>&#123;</span><br><span class="line">    sze[u] = <span class="number">1</span>; mx[u] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = haed[u]; ~i; i = edge[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> to = edge[i].to; <span class="keyword">if</span>(vis[to] || to == par) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">getroot</span>(to, u);</span><br><span class="line">        sze[u] += sze[to];</span><br><span class="line">        mx[u] = <span class="built_in">max</span>(mx[u], sze[to]);</span><br><span class="line">    &#125;</span><br><span class="line">    mx[u] = <span class="built_in">max</span>(mx[u], S - sze[u]);</span><br><span class="line">    <span class="keyword">if</span>(mx[u] &lt; mx[root]) root = u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; dis;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> par, <span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(d &gt; k) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; ~i; i = edge[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> to = edge[i].to; <span class="keyword">if</span>(vis[to] || to == par) <span class="keyword">continue</span>;</span><br><span class="line">        dis.<span class="built_in">push_back</span>(d + edge[i].w);</span><br><span class="line">        <span class="built_in">dfs</span>(to, u, d + edge[i].w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据题目的数据范围进行修改！</span></span><br><span class="line"><span class="keyword">int</span> tong[<span class="number">10000010</span>];</span><br><span class="line"><span class="comment">//获取经过u的答案，路径长度有基础偏移值d</span></span><br><span class="line"><span class="function">ll <span class="title">fun</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    dis.<span class="built_in">clear</span>(); dis.<span class="built_in">push_back</span>(d); <span class="built_in">dfs</span>(u, <span class="number">0</span>, d);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>)dis.<span class="built_in">size</span>(); i++) <span class="keyword">if</span>(dis[i] &lt;= k) tong[dis[i]]++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>)dis.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(dis[i] + dis[i] &lt; k) ans += tong[k - dis[i]];</span><br><span class="line">        <span class="keyword">if</span>(dis[i] + dis[i] == k) ans += tong[dis[i]] - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>)dis.<span class="built_in">size</span>(); i++) <span class="keyword">if</span>(dis[i] &lt;= k) tong[dis[i]]--;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//u是重心，考察以经过u的路径长度</span></span><br><span class="line"><span class="function">ll <span class="title">sove</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="comment">//封锁u节点，分治地寻找子树.</span></span><br><span class="line">    vis[u] = <span class="number">1</span>; ll ans = <span class="built_in">fun</span>(u, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; ~i; i = edge[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> to = edge[i].to; <span class="keyword">if</span>(vis[to]) <span class="keyword">continue</span>;</span><br><span class="line">        ans -= <span class="built_in">fun</span>(to, edge[i].w);</span><br><span class="line"></span><br><span class="line">        S = sze[to]; root = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">getroot</span>(to, u);</span><br><span class="line">        ans += <span class="built_in">sove</span>(root);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//    Fastin;</span></span><br><span class="line">    <span class="built_in">clr</span>(head, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n, m; <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> u, v, w; <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line">        <span class="built_in">add</span>(u, v, w); <span class="built_in">add</span>(v, u, w);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    mx[<span class="number">0</span>] = n; root = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;k);</span><br><span class="line">        S = n; <span class="built_in">clr</span>(vis, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">getroot</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        ll ans = <span class="built_in">sove</span>(root);</span><br><span class="line">        <span class="built_in">puts</span>(ans? <span class="string">&quot;AYE&quot;</span>: <span class="string">&quot;NAY&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="O-nmlogn-一次点分治-同时处理m次询问-开桶-常数较小-AC"><a href="#O-nmlogn-一次点分治-同时处理m次询问-开桶-常数较小-AC" class="headerlink" title="$O(nmlogn)$ 一次点分治 同时处理m次询问 开桶 常数较小 (AC)"></a>$O(nmlogn)$ 一次点分治 同时处理m次询问 开桶 常数较小 (AC)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e4</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">star</span>&#123;</span><span class="keyword">int</span> to, next, w;&#125;;</span><br><span class="line"><span class="keyword">int</span> head[maxn], top = <span class="number">0</span>;</span><br><span class="line">star edge[maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    edge[top].to = v;</span><br><span class="line">    edge[top].next = head[u];</span><br><span class="line">    edge[top].w = w;</span><br><span class="line">    head[u] = top++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用getroot前应该初始化S！！！</span></span><br><span class="line"><span class="keyword">int</span> root = <span class="number">0</span>, S;</span><br><span class="line"><span class="keyword">int</span> vis[maxn], sze[maxn], mx[maxn];;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getroot</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> par)</span></span>&#123;</span><br><span class="line">    sze[u] = <span class="number">1</span>; mx[u] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = haed[u]; ~i; i = edge[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> to = edge[i].to; <span class="keyword">if</span>(vis[to] || to == par) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">getroot</span>(to, u);</span><br><span class="line">        sze[u] += sze[to];</span><br><span class="line">        mx[u] = <span class="built_in">max</span>(mx[u], sze[to]);</span><br><span class="line">    &#125;</span><br><span class="line">    mx[u] = <span class="built_in">max</span>(mx[u], S - sze[u]);</span><br><span class="line">    <span class="keyword">if</span>(mx[u] &lt; mx[root]) root = u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; dis;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> par, <span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(d &gt; <span class="number">10000000</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; ~i; i = edge[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> to = edge[i].to; <span class="keyword">if</span>(vis[to] || to == par) <span class="keyword">continue</span>;</span><br><span class="line">        dis.<span class="built_in">push_back</span>(d + edge[i].w);</span><br><span class="line">        <span class="built_in">dfs</span>(to, u, d + edge[i].w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> tong[<span class="number">10000010</span>];</span><br><span class="line"><span class="keyword">int</span> k[maxn], ans[maxn];</span><br><span class="line"><span class="comment">//获取经过u的答案，路径长度有基础偏移值d</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> d, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    dis.<span class="built_in">clear</span>(); dis.<span class="built_in">push_back</span>(d); <span class="built_in">dfs</span>(u, <span class="number">0</span>, d);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>)dis.<span class="built_in">size</span>(); i++) <span class="keyword">if</span>(dis[i] &lt;= <span class="number">10000000</span>) tong[dis[i]]++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>)dis.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dis[i] + dis[i] &lt; k[j]) ans[j] += (tong[k[j] - dis[i]]) * x;</span><br><span class="line">            <span class="keyword">if</span>(dis[i] + dis[i] == k[j]) ans[j] += (tong[dis[i]] - <span class="number">1</span>) * x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>)dis.<span class="built_in">size</span>(); i++) <span class="keyword">if</span>(dis[i] &lt;= <span class="number">10000000</span>) tong[dis[i]]--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//u是重心，考察以经过u的路径长度</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sove</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="comment">//封锁u节点，分治地寻找子树.</span></span><br><span class="line">    vis[u] = <span class="number">1</span>; <span class="built_in">fun</span>(u, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; ~i; i = edge[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> to = edge[i].to; <span class="keyword">if</span>(vis[to]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">fun</span>(to, edge[i].w, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        S = sze[to]; root = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">getroot</span>(to, u);</span><br><span class="line">        <span class="built_in">sove</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//    Fastin;</span></span><br><span class="line">    <span class="built_in">clr</span>(head, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> u, v, w; <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line">        <span class="built_in">add</span>(u, v, w); <span class="built_in">add</span>(v, u, w);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, k + i);</span><br><span class="line"></span><br><span class="line">    mx[<span class="number">0</span>] = n; root = <span class="number">0</span>;</span><br><span class="line">    S = n; <span class="built_in">clr</span>(vis, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">getroot</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">sove</span>(root);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) <span class="built_in">puts</span>(ans[i]? <span class="string">&quot;AYE&quot;</span>: <span class="string">&quot;NAY&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>本地测试洛谷提供的最大的数据跑了1s，而之前的m次点分治跑了3s；而在oj上则从371ms加速到48ms</p><p><del>还说不卡常！还说不卡常！</del></p><h2 id="VK-Cup-2012-Round-1-D"><a href="#VK-Cup-2012-Round-1-D" class="headerlink" title="VK Cup 2012 Round 1 D"></a><a href="http://codeforces.com/problemset/problem/161/D">VK Cup 2012 Round 1 D</a></h2><p>查询树上经过边数恰为k的两点路径数量，$<u, v>$与$<v, u>$计数时视为同一对点。</p><p>稍微改一下洛谷的板子即可。注意桶的范围，点数maxn</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">5e4</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">star</span>&#123;</span><span class="keyword">int</span> to, next;&#125;;</span><br><span class="line"><span class="keyword">int</span> head[maxn], top = <span class="number">0</span>;</span><br><span class="line">star edge[maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    edge[top].to = v;</span><br><span class="line">    edge[top].next = head[u];</span><br><span class="line">    head[u] = top++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用getroot前应该初始化S！！！</span></span><br><span class="line"><span class="keyword">int</span> root = <span class="number">0</span>, S;</span><br><span class="line"><span class="keyword">int</span> vis[maxn], sze[maxn], mx[maxn];;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getroot</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> par)</span></span>&#123;</span><br><span class="line">    sze[u] = <span class="number">1</span>; mx[u] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = haed[u]; ~i; i = edge[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> to = edge[i].to; <span class="keyword">if</span>(vis[to] || to == par) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">getroot</span>(to, u);</span><br><span class="line">        sze[u] += sze[to];</span><br><span class="line">        mx[u] = <span class="built_in">max</span>(mx[u], sze[to]);</span><br><span class="line">    &#125;</span><br><span class="line">    mx[u] = <span class="built_in">max</span>(mx[u], S - sze[u]);</span><br><span class="line">    <span class="keyword">if</span>(mx[u] &lt; mx[root]) root = u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; dis;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> par, <span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(d &gt; k) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; ~i; i = edge[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> to = edge[i].to; <span class="keyword">if</span>(vis[to] || to == par) <span class="keyword">continue</span>;</span><br><span class="line">        dis.<span class="built_in">push_back</span>(d + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">dfs</span>(to, u, d + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据题目的数据范围进行修改！</span></span><br><span class="line"><span class="keyword">int</span> tong[<span class="number">50010</span>];</span><br><span class="line"><span class="comment">//获取经过u的答案，路径长度有基础偏移值d</span></span><br><span class="line"><span class="function">ll <span class="title">fun</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    dis.<span class="built_in">clear</span>(); dis.<span class="built_in">push_back</span>(d); <span class="built_in">dfs</span>(u, <span class="number">0</span>, d);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>)dis.<span class="built_in">size</span>(); i++) <span class="keyword">if</span>(dis[i] &lt;= k) tong[dis[i]]++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>)dis.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(dis[i] + dis[i] &lt; k) ans += tong[k - dis[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(k % <span class="number">2</span> == <span class="number">0</span> &amp;&amp; tong[k / <span class="number">2</span>]) ans += tong[k / <span class="number">2</span>] * <span class="number">1ll</span> * (tong[k / <span class="number">2</span>] - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>)dis.<span class="built_in">size</span>(); i++) <span class="keyword">if</span>(dis[i] &lt;= k) tong[dis[i]]--;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//u是重心，考察以经过u的路径长度</span></span><br><span class="line"><span class="function">ll <span class="title">sove</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="comment">//封锁u节点，分治地寻找子树.</span></span><br><span class="line">    vis[u] = <span class="number">1</span>; ll ans = <span class="built_in">fun</span>(u, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; ~i; i = edge[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> to = edge[i].to; <span class="keyword">if</span>(vis[to]) <span class="keyword">continue</span>;</span><br><span class="line">        ans -= <span class="built_in">fun</span>(to, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        S = sze[to]; root = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">getroot</span>(to, u);</span><br><span class="line">        ans += <span class="built_in">sove</span>(root);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//    Fastin;</span></span><br><span class="line">    <span class="built_in">clr</span>(head, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> u, v; <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">        <span class="built_in">add</span>(u, v); <span class="built_in">add</span>(v, u);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    mx[<span class="number">0</span>] = n; root = <span class="number">0</span>;</span><br><span class="line">    S = n; <span class="built_in">clr</span>(vis, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">getroot</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    ll ans = <span class="built_in">sove</span>(root);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="P2634"><a href="#P2634" class="headerlink" title="P2634"></a>P2634</h2><p>查询路径长度为三的倍数的数量</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e4</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">star</span>&#123;</span><span class="keyword">int</span> to, next, w;&#125;;</span><br><span class="line"><span class="keyword">int</span> head[maxn], top = <span class="number">0</span>;</span><br><span class="line">star edge[maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, itn w)</span></span>&#123;</span><br><span class="line">    edge[top].to = v;</span><br><span class="line">    edge[top].next = head[u];</span><br><span class="line">    edge[top].w = w;</span><br><span class="line">    head[u] = top++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用getroot前应该初始化S！！！</span></span><br><span class="line"><span class="keyword">int</span> root = <span class="number">0</span>, S;</span><br><span class="line"><span class="keyword">int</span> vis[maxn], sze[maxn], mx[maxn];;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getroot</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> par)</span></span>&#123;</span><br><span class="line">    sze[u] = <span class="number">1</span>; mx[u] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = haed[u]; ~i; i = edge[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> to = edge[i].to; <span class="keyword">if</span>(vis[to] || to == par) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">getroot</span>(to, u);</span><br><span class="line">        sze[u] += sze[to];</span><br><span class="line">        mx[u] = <span class="built_in">max</span>(mx[u], sze[to]);</span><br><span class="line">    &#125;</span><br><span class="line">    mx[u] = <span class="built_in">max</span>(mx[u], S - sze[u]);</span><br><span class="line">    <span class="keyword">if</span>(mx[u] &lt; mx[root]) root = u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据需要的是边数还是边权修改1/edge[i].w</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; dis;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> par, <span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; ~i; i = edge[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> to = edge[i].to; <span class="keyword">if</span>(vis[to] || to == par) <span class="keyword">continue</span>;</span><br><span class="line">        dis.<span class="built_in">push_back</span>(d + edge[i].w);</span><br><span class="line">        <span class="built_in">dfs</span>(to, u, d + edge[i].w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据题目的数据范围进行修改！</span></span><br><span class="line"><span class="keyword">int</span> tong[<span class="number">3</span>];</span><br><span class="line"><span class="comment">//获取经过u的答案，路径长度有基础偏移值d</span></span><br><span class="line"><span class="function">ll <span class="title">fun</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    dis.<span class="built_in">clear</span>(); dis.<span class="built_in">push_back</span>(d); <span class="built_in">dfs</span>(u, <span class="number">0</span>, d);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>)dis.<span class="built_in">size</span>(); i++) tong[dis[i] % <span class="number">3</span>]++;</span><br><span class="line">    </span><br><span class="line">    ans += tong[<span class="number">0</span>] * <span class="number">1ll</span> * tong[<span class="number">0</span>] + tong[<span class="number">1</span>] * tong[<span class="number">2</span>] * <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">clr</span>(tong, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//u是重心，考察以经过u的路径长度</span></span><br><span class="line"><span class="function">ll <span class="title">sove</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="comment">//封锁u节点，分治地寻找子树.</span></span><br><span class="line">    vis[u] = <span class="number">1</span>; ll ans = <span class="built_in">fun</span>(u, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; ~i; i = edge[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> to = edge[i].to; <span class="keyword">if</span>(vis[to]) <span class="keyword">continue</span>;</span><br><span class="line">        ans -= <span class="built_in">fun</span>(to, edge[i].w % <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        S = sze[to]; root = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">getroot</span>(to, u);</span><br><span class="line">        ans += <span class="built_in">sove</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//    Fastin;</span></span><br><span class="line">    <span class="built_in">clr</span>(head, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> u, v, w; <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line">        <span class="built_in">add</span>(u, v, w); <span class="built_in">add</span>(v, u, w);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    mx[<span class="number">0</span>] = n; root = <span class="number">0</span>;</span><br><span class="line">    S = n; <span class="built_in">clr</span>(vis, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">getroot</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    ll ans = <span class="built_in">sove</span>(root);</span><br><span class="line">    ll d = <span class="built_in">gcd</span>(ans, n * <span class="number">1ll</span> * n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld/%lld\n&quot;</span>, ans / d, n * <span class="number">1ll</span> * n / d);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>当处理一些与子树有关的问题时，可以采用点分治，比较典型的问题就是对树上满足特定限制的路径的计数。</p><p>在点分治时，每次通过选取子树的重心将当前子树进行划分，从而可以在子树之间进行复杂度较为优秀的一系列操作。</p><h2 id="小问题"><a href="#小问题" class="headerlink" title="小问题"></a>小问题</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(sze[to] &lt; sze[u]) S = sze[to];</span><br><span class="line"><span class="keyword">else</span> S = sze[to] - sze[u];</span><br></pre></td></tr></table></figure><p>在更新子树大小的时候按道理应该这样才对？？</p><p>为何洛谷上千篇一律的是直接<code>S=sze[to]</code>？莫非对总的时间复杂度没有过多的影响？</p><p>修改这一处后再次提交仍是TLE的TLE、AC的AC…非常的神秘</p>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树 </tag>
            
            <tag> 点分治 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cdq初步</title>
      <link href="/2021/02/01/cdq%E5%88%9D%E6%AD%A5/"/>
      <url>/2021/02/01/cdq%E5%88%9D%E6%AD%A5/</url>
      
        <content type="html"><![CDATA[<p>cdq分治 三维偏序问题</p><span id="more"></span><p><a href="http://rqdmap.top/2021/01/28/2020-2021Brazil-Subregional-Programming-Contest/#more">起因 动态的区间重叠查询</a></p><p>在分享题目的时候听闻有同学说cdq分治，之后便去研究了一番，发现cdq分治的思想与之前这道动态的区间重叠查询有着异曲同工之妙。</p><p>以经典的<a href="https://www.luogu.com.cn/problem/P3810">三维偏序</a>为例。</p><p>对三个值按照第一、第二、第三优先级的顺序进行升序排序，在排好序的新序列上进行<strong>“归并”</strong>，假设当前对区间$[l, r]$进行归并。那么由于我们的<strong>良好的排序规则</strong>，可以保证$[mid + 1, r]$中的三元组一定不会对区间$[l, mid]$中的三元组产生贡献。换言之，可能产生贡献的三元组们要么同时存在于某个子区间内，要么是左区间对右区间产生贡献。因而我们进行双指针归并排序，排序时不断比较的是三元组的$y$属性，而插入三元组时维护一颗以三元组的$z$属性构成的支持<code>区间加，区间清零，区间查询和</code>的权值线段树，通过在权值线段树上不断地更新、查询来维护最终的答案。</p><p>有两个值的注意的点：</p><ul><li>可能会出现重复元素，因而我们要对原始三元组序列去重，给重复的三元组加一个权值，最后在计算答案的时候分别对相同的三元组之间和不同的三元组之间统计答案。</li><li><strong>“良好的排序规则”是很重要的</strong>。最开始按照个人的理解仅仅按照三元组的$x$属性进行排序，但是这样就无法保证归并时右儿子一定不对左儿子做贡献，从而使cdq分治失去了根本的理论保证。</li></ul><p>** 虽然借此知道了对所有分量都维护顺序的序列是很有必要的，但是回头再去看区间重叠的问题，仍然不甚理解出现在那题中的问题。因为在那题中不需要考虑左右儿子彼此的贡献，而仅仅只需要一个顺序来建树而已。qaq神秘</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls (p &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs ((p &lt;&lt; 1) | 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mid ((l + r) &gt;&gt; 1)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="comment">//权值线段树: 单点置值，区间查询</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ST</span>&#123;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> st[maxn &lt;&lt; <span class="number">2</span>];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l == r &amp;&amp; l == k)&#123;</span><br><span class="line">            st[p] += x; <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(k &lt;= mid) <span class="built_in">add</span>(ls, l, mid, k, x);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">add</span>(rs, mid + <span class="number">1</span>, r, k, x);</span><br><span class="line">        st[p] = st[ls] + st[rs];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l == r &amp;&amp; l == k)&#123;</span><br><span class="line">            st[p] = <span class="number">0</span>; <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(k &lt;= mid) <span class="built_in">clear</span>(ls, l, mid, k);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">clear</span>(rs, mid + <span class="number">1</span>, r, k);</span><br><span class="line">        st[p] = st[ls] + st[rs];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R) <span class="keyword">return</span> st[p];</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(L &lt;= mid) ans += <span class="built_in">query</span>(ls, l, mid, L, R);</span><br><span class="line">        <span class="keyword">if</span>(R &gt; mid) ans += <span class="built_in">query</span>(rs, mid + <span class="number">1</span>, r, L, R);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;st;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NODE</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y, z, w;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> NODE&amp; b)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x != b.x) <span class="keyword">return</span> x &lt; b.x;</span><br><span class="line">        <span class="keyword">if</span>(y != b.y) <span class="keyword">return</span> y &lt; b.y;</span><br><span class="line">        <span class="keyword">return</span> z &lt; b.z;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> == (<span class="keyword">const</span> NODE &amp;b)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x == b.x &amp;&amp; y == b.y &amp;&amp; z == b.z;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span>&#123;<span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;x, &amp;y, &amp;z); w = <span class="number">1</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">prt</span><span class="params">()</span></span>&#123;<span class="built_in">printf</span>(<span class="string">&quot;(%d %d %d) : %d\n&quot;</span>, x, y, z, w);&#125;</span><br><span class="line">&#125;;</span><br><span class="line">NODE temp[maxn], node[maxn];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[maxn];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; vec[maxn &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;<span class="keyword">return</span> node[i].y &lt; node[j].y;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sove</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">        vec[p].<span class="built_in">push_back</span>(l);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sove</span>(ls, l, mid);</span><br><span class="line">    <span class="built_in">sove</span>(rs, mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; mid - l + <span class="number">1</span> &amp;&amp; j &lt; r - mid)&#123;</span><br><span class="line">        <span class="keyword">if</span>(node[vec[ls][i]].y &lt;= node[vec[rs][j]].y)&#123;</span><br><span class="line">            st.<span class="built_in">add</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">200000</span>, node[vec[ls][i]].z, node[vec[ls][i]].w);</span><br><span class="line">            vec[p].<span class="built_in">push_back</span>(vec[ls][i]);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            f[vec[rs][j]] += st.<span class="built_in">query</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">200000</span>, <span class="number">1</span>, node[vec[rs][j]].z);</span><br><span class="line">            vec[p].<span class="built_in">push_back</span>(vec[rs][j]);</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; mid - l + <span class="number">1</span>)&#123;</span><br><span class="line">        st.<span class="built_in">add</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">200000</span>, node[vec[ls][i]].z, node[vec[ls][i]].w);</span><br><span class="line">        vec[p].<span class="built_in">push_back</span>(vec[ls][i]);</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(j &lt; r - mid)&#123;</span><br><span class="line">        f[vec[rs][j]] += st.<span class="built_in">query</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">200000</span>, <span class="number">1</span>, node[vec[rs][j]].z);</span><br><span class="line">        vec[p].<span class="built_in">push_back</span>(vec[rs][j]);</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x: vec[p]) st.<span class="built_in">clear</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">200000</span>, node[x].z);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//    Fastin;</span></span><br><span class="line">    <span class="keyword">int</span> n, d; <span class="built_in">scnaf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;d);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) temp[i].<span class="built_in">read</span>();</span><br><span class="line">    <span class="built_in">sort</span>(temp + <span class="number">1</span>, tmep + <span class="number">1</span> + n);</span><br><span class="line">    <span class="keyword">int</span> m = <span class="number">0</span>;</span><br><span class="line">    node[++m] = temp[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(temp[i] == temp[i - <span class="number">1</span>]) node[m].w++;</span><br><span class="line">        <span class="keyword">else</span> node[++m] = temp[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sove</span>(<span class="number">1</span>, <span class="number">1</span>, m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) f[i] += node[i].w - <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">fro</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) ans[f[i]] += node[i].w;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分治 </tag>
            
            <tag> cdq分治 </tag>
            
            <tag> 三维偏序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020-2021Brazil-Subregional-Programming-Contest</title>
      <link href="/2021/01/28/2020-2021Brazil-Subregional-Programming-Contest/"/>
      <url>/2021/01/28/2020-2021Brazil-Subregional-Programming-Contest/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><span id="more"></span><h2 id="M-线段树-amp-二分-处理平面上的一类投影问题"><a href="#M-线段树-amp-二分-处理平面上的一类投影问题" class="headerlink" title="M 线段树 &amp; 二分 处理平面上的一类投影问题"></a>M 线段树 &amp; 二分 处理平面上的一类投影问题</h2><p><a href="http://202.182.108.237/WT03-B-rand-rqdmap.pdf">题解</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> itn M = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n, q;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SEG</span>&#123;</span></span><br><span class="line">    ll x, y;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> SEG &amp;b) <span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> y &lt; b.y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">SEG seg[maxn];</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls (p &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs ((p &lt;&lt; 1) | 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mid ((l + r) &gt;&gt; 1)</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NODE</span>&#123;</span></span><br><span class="line">    ll x; <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> NODE &amp;b) <span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x &gt; b.x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;NODE&gt; st[maxn &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">        st[p].<span class="built_in">push_back</span>(&#123;seg[l].x, seg[l].id&#125;);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">build</span>(ls, l, mid); <span class="built_in">build</span>(rs, mid + <span class="number">1</span>, r);</span><br><span class="line">    st[p].<span class="built_in">resize</span>(r - l + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">merge</span>(st[ls].<span class="built_in">begin</span>(), st[ls].<span class="built_in">end</span>(), st[rs].<span class="built_in">begin</span>(), st[rs].<span class="built_in">end</span>(), st[p].<span class="built_in">begin</span>());</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//在seg[l] - seg[r]中查询那些：序号至少为lim, 且有可能有交集的所有线段</span></span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> lim, ll y0)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(r &lt; lim) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="comment">//如果这一段区间全部满足（意味着右端点一定 &gt; y0)</span></span><br><span class="line">    <span class="keyword">if</span>(l &gt;= lim)&#123;</span><br><span class="line">        <span class="keyword">int</span> top = (<span class="keyword">int</span>)st[p].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = top - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(st[p][i].x &gt; y0) <span class="keyword">break</span>;</span><br><span class="line">            res.<span class="built_in">push_back</span>(st[p][i].id);</span><br><span class="line">            cnt++;</span><br><span class="line">            <span class="built_in">assert</span>(cnt &lt;= <span class="number">2000000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">query</span>(ls, l, mid, lim, y0);</span><br><span class="line">    <span class="built_in">query</span>(rs, mid + <span class="number">1</span>, r, lim, y0);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//    Fastin;</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        ll x, y; <span class="built_in">scanf</span>(<span class="string">&quot;%lld %lld &quot;</span>, &amp;x, &amp;y); y *= <span class="number">2</span>;</span><br><span class="line">        seg[i].x = y - x; seg[i].y = y + x; seg[i].id = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(seg + <span class="number">1</span>, seg + n + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> e = <span class="number">5782344</span>; ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; q; i++)&#123;</span><br><span class="line">        ll a, b; <span class="built_in">scanf</span>(<span class="string">&quot;%lld %lld&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">        ll x, y;</span><br><span class="line">        x = <span class="number">-1</span> - ((ans + a) % M);</span><br><span class="line">        y = (ans + b) % M; y *= <span class="number">2</span>;</span><br><span class="line">        SEG temp; temp.x = <span class="number">1ll</span> &lt;&lt; <span class="number">60</span>; temp.y = y +x; tmep.id = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> lim = (<span class="keyword">int</span>)(<span class="built_in">lower_bound</span>(seg + <span class="number">1</span>, seg + n + <span class="number">1</span>, temp) - seg);</span><br><span class="line">        </span><br><span class="line">        res.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="built_in">query</span>(<span class="number">1</span>, <span class="number">1</span>, n, lim, y - x);</span><br><span class="line">        <span class="built_in">sort</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>(), greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x: res) ans = (ans * e % M + x) % M;</span><br><span class="line">         </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有一个神秘的地方，按照L8的排序方法可以AC，但是如果改动成</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> SEG &amp;b) <span class="keyword">const</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(y != b.y) <span class="keyword">return</span> y &lt; b.y;</span><br><span class="line">  <span class="keyword">return</span> x &lt; b.x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就会离奇TLE，经过assert检查是查出来的敌军总数超过题目的限制，从而TLE。</p><p>按照道理来说，如果仅仅比较y都能够AC，那么再加上第二优先级比较x也应该能够AC，毕竟加上第二优先级只是仅仅比较y的一种特殊情况，然而却居然发生了这样的事情，至今不解。</p><p>link to <a href="http://rqdmap.top/2021/02/01/cdq初步/">cdq分治</a></p>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线段树 </tag>
            
            <tag> 二分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>poj-1222</title>
      <link href="/2021/01/18/poj-1222/"/>
      <url>/2021/01/18/poj-1222/</url>
      
        <content type="html"><![CDATA[<p>给出一个5*6的01矩阵，每按一个格点就会将该格点及其4个方向上的格点（如果有的话）数值翻转，试给出一个方案使得最终所有格点均为0.</p><span id="more"></span><p>高斯消元经典例题，拿来测试一下自己的模版是否正确。</p><p>这题比较精妙的地方在于建方程：变元有30个，分别代表5*6矩阵中是否按下每一个按钮。而所有操作完成后每个格点的状态显然可以用这30个变元进行线性表示。不过这里的加法应该映射为异或+，稍微修改一下板子并且注意多组数据即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">使用指南：</span></span><br><span class="line"><span class="comment">    读入&quot;整形&quot;增广矩阵a，修改行列信息equ、var。</span></span><br><span class="line"><span class="comment">    从零开始编号，则行为[0, equ - 1], 列为[0, var];</span></span><br><span class="line"><span class="comment">    返回值：</span></span><br><span class="line"><span class="comment">        返回0说明有整数解，结果存放在x数组中</span></span><br><span class="line"><span class="comment">        返回-2说明有浮点解，需要修改数据类型再运算</span></span><br><span class="line"><span class="comment">        返回-1时无解</span></span><br><span class="line"><span class="comment">        返回正数k时说明有k个自由变元，自由变元存放在flag中；</span></span><br><span class="line"><span class="comment">Tips:</span></span><br><span class="line"><span class="comment">    处理过程可能爆int</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e2</span>;</span><br><span class="line"><span class="comment">//有equ个等式，var个变量，那么增广矩阵有equ行，var + 1列；模版中从0开始标号。</span></span><br><span class="line"><span class="keyword">int</span> equ, var;</span><br><span class="line"><span class="keyword">int</span> a[maxn][maxn];</span><br><span class="line"><span class="comment">//x是解集，flag标记是否自由</span></span><br><span class="line"><span class="keyword">int</span> x[maxn], flag[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gauss</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; equ &amp;&amp; j &lt; var; i++, j++)&#123;</span><br><span class="line">        <span class="keyword">int</span> l = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = i + <span class="number">1</span>; k &lt; equ; k++) <span class="keyword">if</span>(<span class="built_in">abs</span>(a[k][j] &gt; a[l][j])) l = k;</span><br><span class="line">        <span class="keyword">if</span>(l != i) <span class="built_in">swap</span>(a[l], a[i]);</span><br><span class="line">        <span class="comment">//i行及以下的该列全为0，转而处理下一列。</span></span><br><span class="line">        <span class="keyword">if</span>(a[i][j] == <span class="number">0</span>)&#123;</span><br><span class="line">            i--; <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = i + <span class="number">1</span>; k &lt; equ; k++) <span class="keyword">if</span>(a[k][j])&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> col = j; col &lt;= var; col++) a[k][col] = a[k][col] ^ a[i][col];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//循环完成后，i是有效行数，也就是秩（？）；</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//(I)存在(0, 0, ... ,0, k!=0)的结构存在，即无解,返回-1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = i; k &lt; equ; k++) <span class="keyword">if</span>(a[k][var] != <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//(II)存在自由变元，返回变元数量，并且在flag数组中标记出所有的自由变元。</span></span><br><span class="line">    <span class="keyword">if</span>(j &lt; var)&#123;</span><br><span class="line">        <span class="comment">//i是秩，[0, i - 1]均为非全零的行</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = i - <span class="number">1</span>; k &gt;= <span class="number">0</span>; k--)&#123;</span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="number">0</span>, free_id = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; var; col++) <span class="keyword">if</span>(a[k][col] &amp;&amp; flag[col])&#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                free_id = col;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//一定存在至少一个自由变元，不然一定会被向下过程消去。</span></span><br><span class="line">            <span class="built_in">assert</span>(free_id != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//有两个及以上变元，那么无法确定这些变元</span></span><br><span class="line">            <span class="keyword">if</span>(cnt &gt;= <span class="number">2</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 注释原因:求解变元会涉及到小数？故注释掉，实际操作时根据具体情况处理</span></span><br><span class="line">            <span class="comment">// //只剩一个变元free_id，可以求解出来。</span></span><br><span class="line">            <span class="comment">// int temp = a[k][var];</span></span><br><span class="line">            <span class="comment">// for(int col = 0; col &lt; var; col++) if(a[k][col] &amp;&amp; col != free_id) temp -= a[k][col] * x[col];</span></span><br><span class="line">            <span class="comment">// x[free_id] = tmep / a[k][free_id];</span></span><br><span class="line"></span><br><span class="line">            flag[free_id] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> var - i;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//(III)求解方程，此时保证有唯一解:如果全部为正整数解，返回0，如果出现浮点数解，返回-2；</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = var - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="keyword">int</span> tmep = a[i][var];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; var; j++) <span class="keyword">if</span>(a[i][j]) tmep ^= a[i][j] * x[j];</span><br><span class="line">        x[i] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dx[] = &#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> dy[] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">valid</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &gt;= <span class="number">0</span> &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; x &lt; <span class="number">5</span> &amp;&amp; y &lt; <span class="number">6</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) &#123;</span><br><span class="line">        a[i][i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> x = i / <span class="number">6</span>, y = i % <span class="number">6</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> nx = x + dx[j], ny = y + dy[j];</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">valid</span>(nx, ny))&#123;</span><br><span class="line">                a[nx * <span class="number">6</span> + ny][i] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Fastin;</span></span><br><span class="line">    equ = var = <span class="number">30</span>;</span><br><span class="line">    TTT&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;PUZZLE #%d\n&quot;</span>, _);</span><br><span class="line">        <span class="keyword">int</span> top = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">clr</span>(a, <span class="number">0</span>); <span class="built_in">fun</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) <span class="built_in">scnaf</span>(<span class="string">&quot;%d&quot;</span>, a[top++] + <span class="number">30</span>);</span><br><span class="line">        <span class="built_in">assert</span>(<span class="built_in">gauss</span>() == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        top = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">6</span>; j++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, x[top++]);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 线性代数 </tag>
            
            <tag> 高斯消元 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021-XDU-寒假训练</title>
      <link href="/2021/01/17/2021-XDU-%E5%AF%92%E5%81%87%E8%AE%AD%E7%BB%83/"/>
      <url>/2021/01/17/2021-XDU-%E5%AF%92%E5%81%87%E8%AE%AD%E7%BB%83/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><span id="more"></span><h1 id="（一）"><a href="#（一）" class="headerlink" title="（一）"></a>（一）</h1><h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><h2 id="B"><a href="#B" class="headerlink" title="B"></a>B</h2><p>字符串上做快速幂优化的dp</p><h2 id="C-三维平面上求最长的基底长度"><a href="#C-三维平面上求最长的基底长度" class="headerlink" title="C 三维平面上求最长的基底长度"></a>C 三维平面上求最长的基底长度</h2><h3 id="弱化：二维平面上求最长的基底长度"><a href="#弱化：二维平面上求最长的基底长度" class="headerlink" title="弱化：二维平面上求最长的基底长度"></a>弱化：二维平面上求最长的基底长度</h3><p><a href="https://codeforces.ml/gym/100959">K题</a></p><p>如何说明gcd欧几里得算法的正确性？等价于说明$gcd(a, b) = gcd(b, a \% b)$：</p><p>只要说明(a, b)的公因子一定是a%b的因子，(b, a % b)的公因子一定是a的因子。这样，双方的公因子全体必然相同，进而gcd相等。</p><p>那么，在一般的欧几里得算法中，必须要证明上述的式子，即$fun(a, b) = fun(b, a\%b)$</p><p>高斯整数是实部与虚部均为整数的复数。首先如下地定义高斯整数的唯一带余除法表示：</p><p>设$\frac{a}{b} = x + iy$, 一定存在唯一的整数$m, n$使得$m - 1/2 &lt; x &lt;=m + 1/2, n-1/2 &lt; y &lt;=n + 1/2$.</p><p>那么带余除法$a = bq +r, q =m+in$.</p><p>实际在运算时，对两个复数做除法，将实部虚部四舍五入，就得到了倍数q。</p><p>接下来尝试说明上述的除法满足欧几里得算法的条件：</p><p>仍然认为这里的$fun$函数是找二者最大的公因子。</p><p>由于$<C, +, *>$是环，乘法对加法可分配，运算满足封闭性，很容易证明两边的因子全体相同。</p><p>（<del>手算证明a、b的因子一定是a%b的因子，大概利用了上述的几个性质，不知道是否正确</del>）</p><p>那么通过欧几里得不断辗转相除就可以得到给出的所有向量的最大公因子。</p><p>得出的这个”Gcd”因子，就是我们要求的最终的基底向量。无需考虑转化为平面坐标上的基底，直接利用这个向量就可以得知需要几个向量才能构成一个题目要求的”正方形”：将给出的所有向量除以该基底，按道理可以得到标准的<strong>高斯整数</strong>，实部可以看作是为了表示这个向量，实轴基底所需要的数量，虚部可以看作是虚轴基底所需要的数量。不断地用横纵坐标更新最大最小值，最后在这个矩形区域中最长的边（即长方形的长），这就是为了表示所有的复数所需要的最少的基底数量，也就是题目要求中的K。显然，因为基底最大，相应的K就会最小。</p><p>此外，因为题目还允许变化基础偏移值$(a, b)$，所以给出的n个复数不需要全部使用，可以认为某一个为原点，考虑剩余$n-1$个对它的相对坐标，使用相对坐标完成上述讨论的gcd等操作即可。</p><p><del>因为看到了一份代码，在gcd中有四舍五入，而在将向量除以标准基底后得到的商上也进行了四舍五入，让人不禁怀疑这一坨四舍五入到底都是什么。事实上，gcd的四舍五入是高斯整数除法所内在要求的，而商上的四舍五入是为了防止double复数除法的精度问题。</del></p><p>此时不禁赞叹这一份优美的自定义高斯整数结构的<a href="https://codeforces.ml/gym/100959/submission/30276053">代码</a>。（可能需要coach才能查看）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">GaussianInteger</span>&#123;</span></span><br><span class="line">    ll x, y;</span><br><span class="line">    <span class="function">ll <span class="title">norm</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> x * x + y * y;&#125;</span><br><span class="line">    GaussianInteger <span class="keyword">operator</span> + (<span class="keyword">const</span> GaussianInteger &amp;b)&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;x + b.x, y + b.y&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    GaussianInteger <span class="keyword">operator</span> - (<span class="keyword">const</span> GaussianInteger &amp;b)&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;x - b.x, y - b.y&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    GaussianInteger <span class="keyword">operator</span> * (<span class="keyword">const</span> GaussianInteger &amp;b)&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;x * b.x - y * b.y, x * b.y + y * b.x&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//(专用! 因为此处b保证大于0)四舍五入除法</span></span><br><span class="line">    <span class="comment">//高斯整数商的实部虚部在某个整数的**(-1/2, 1/2]**区间中。</span></span><br><span class="line">    <span class="function">ll <span class="title">D</span><span class="params">(ll a, ll b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a &gt;= <span class="number">0</span>) <span class="keyword">return</span> (a % b) * <span class="number">2</span> &lt; b? a / b: a / b + <span class="number">1</span>;</span><br><span class="line">        a = -a; <span class="keyword">return</span> -((a % b) * <span class="number">2</span> &lt;= b? a / b: a / b + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    GaussianInteger <span class="keyword">operator</span> / (<span class="keyword">const</span> GaussianInteger &amp;b)&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="built_in">D</span>(x * b.x + y * b.y, x * b.x + y * b.y), <span class="built_in">D</span>(y * b.x - x * b.y, x * b.x + y * b.y)&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    GaussianInteger <span class="keyword">operator</span> % (<span class="keyword">const</span> GaussianInteger &amp;b)&#123;</span><br><span class="line">        GaussianInteger a = &#123;x, y&#125;;</span><br><span class="line">        <span class="keyword">return</span> a - a / b * b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> GaussianInteger NODE;</span><br><span class="line"><span class="function">NODE <span class="title">gcd</span><span class="params">(NODE a, NODE b)</span></span>&#123;<span class="keyword">return</span> !b.<span class="built_in">norm</span>()? a: <span class="built_in">gcd</span>(b, a % b);&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line">NODE node[maxn];</span><br><span class="line"></span><br><span class="line">ll xmi, xmx, ymi, ymx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   Fastin;</span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scnaf</span>(<span class="string">&quot;%lld %lld&quot;</span>, &amp;node[i].x, &amp;node[i].y);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) node[i] = node[i] - node[<span class="number">0</span>];</span><br><span class="line">    NODE d = node[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++) d = <span class="built_in">gcd</span>(d, node[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">        NODE p = node[i] / d;</span><br><span class="line">        xmi = <span class="built_in">min</span>(xmi, p.x); xmx = <span class="built_in">max</span>(xmx, p.x);</span><br><span class="line">        ymi = <span class="built_in">min</span>(ymi, p.y); ymx = <span class="built_in">max</span>(ymx, p.y);</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans = <span class="built_in">max</span>(ymx - ymi + <span class="number">1</span>, xmx - xmi + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans - n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="三维空间上利用四元数（留坑）"><a href="#三维空间上利用四元数（留坑）" class="headerlink" title="三维空间上利用四元数（留坑）"></a>三维空间上利用四元数（留坑）</h3><p><del>暂时不太愿意花费太多时间去研究四元数的若干表示形式 因而留坑待补（弃坑（bushi</del></p><h2 id="D-无向图生成树计数-amp-允许旋转置换"><a href="#D-无向图生成树计数-amp-允许旋转置换" class="headerlink" title="D 无向图生成树计数 &amp; 允许旋转置换"></a>D 无向图生成树计数 &amp; 允许旋转置换</h2><h3 id="无向图矩阵树定理"><a href="#无向图矩阵树定理" class="headerlink" title="无向图矩阵树定理"></a>无向图矩阵树定理</h3><p>图中不允许自环，允许重边。</p><p>定理基尔霍夫矩阵$L(G) = D(G)-A(G)$，度数矩阵$D_{ii}(G) =deg(i),D_{ij}=0,i≠j$，邻接矩阵$A_{ij}(G)=A_{ji}(G)=#e(ij), i≠j$。</p><p>那么$L(G)$的所有代数余子式均相同，且等于G的生成树数量。</p><h3 id="Burnside与Polya定理"><a href="#Burnside与Polya定理" class="headerlink" title="Burnside与Polya定理"></a>Burnside与Polya定理</h3><p><strong>burnside</strong>：G是X的置换群，C是X中满足如下条件的着色集合：对于G中所有的f和C中所有的c都有$f*c$仍在C中，则C中非等价的着色数$N(G,C)=\frac{1}{|G|}\sum _{f∈G}|C(f)|$，其中$C(f)$是在f作用下使得着色c保持不变的所有着色的集合。</p><p><strong>polya</strong>: 如果一个置换$f$有$σ_f$个循环，那么可以根据循环具体地计算出不动点的数量，从而得到等价类的数量: $\frac 1 {|G|}\sum_ {f∈G}m^{σ_f}$，其中m是可选颜色的数量。</p><p>polya练习题-&gt; <a href="https://www.cnblogs.com/hankers/archive/2012/08/03/2622231.html">这里</a></p><h2 id="E-杨表-amp-LIS"><a href="#E-杨表-amp-LIS" class="headerlink" title="E 杨表 &amp; LIS"></a>E 杨表 &amp; LIS</h2><h3 id="Diworth定理"><a href="#Diworth定理" class="headerlink" title="Diworth定理"></a>Diworth定理</h3><blockquote><p><strong>一个序列中下降子序列的最少划分数个数等于最长上升子序列的长度。</strong></p><p><strong>一个序列中上升子序列的最少划分数个数等于最长下降子序列的长度。</strong></p><p><strong>每句中的前后两者互为偏序关系。</strong></p></blockquote><h3 id="杨表"><a href="#杨表" class="headerlink" title="杨表"></a>杨表</h3><p>标准杨表从左向右、从上到下格子中的元素大小均是递增的。</p><p><del>大概长阶梯状，但是博客比较垃圾不太能上传图所以从略</del></p><p>$1-n$构成杨表个数为$f(1) = 1, f(2)=2, f(n) = f(n-1)+(n-1)*f(n-2),n &gt;2$</p><p>定义某个方格的勾长为<code>该方格正右方方格数+正下方方格数+1</code>，那么如果给定杨表的形状，用$1-n$填充杨表的所有方式有$\frac {n!}{\prod _{x是杨表格子}hook(x)}$，这被称为勾长公式。</p><p>杨表的对行插入：设要插入x，从第一行开始，在当前行中找第一个大于x的位置，如果找到了就用x替换该元素y，并尝试在下一行插入y，反复不断进行；如果找不到这样的位置，就将当前的值放在行末，算法结束。</p><p>杨表的删除：假设要删除$(x, y)$，保证$(x, y)$是边角。设x = $S_{xy}$，如果x在第一行，删除x算法结束；不然，找出最大的小于x的位置，用x替换该位置上的元素y，再尝试在上一行中删除y，反复进行。</p><p><strong>杨表$P_x$与LIS、LDS：</strong></p><p>$P_x$中第一行的长度就是排列$X$的LIS的长度，第一列的长度是其LDS的长度</p><p>事实上，定义k-LIS序列为LIS长度不超过k的序列，类似地定义k-LDS序列。那么杨表前k列的长度就是最长的k-LIS长度。</p><h3 id=""><a href="#" class="headerlink" title=" "></a> </h3><h3 id="本题"><a href="#本题" class="headerlink" title="本题"></a>本题</h3><p>给定长度n，要求找出满足如下条件的长为n的排列：存在两个长度相同且无相交元素的LIS，答案对998244353取模。</p><p>由于diworth定理，可以得知就是要找包含一个总长为2L，LDS=2，LIS=L的子序列的序列的个数，这也就是说要找长度为n、2_LDS=2L、LIS=L的序列的个数。转换到杨表上来，杨表大小为n，前两行总共应有2L个元素，第一行必须有 L个元素，从而第二行也就必须有L个元素。将整数n进行拆分后用钩子公式即可得知当前形状的杨表的合法数量。又由于一对杨表唯一的确定一个排列，那么最终的排列数则是所有杨表合法数量的平方之和。</p><ol><li>没有仔细研读2019国家集训队论文集，偷了几个结论就跑了</li><li>不是特别明白利用diworth定理和杨表相关性质对题目进行的转化</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">onst <span class="keyword">int</span> M = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">const</span> itn maxn = <span class="number">1e2</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n, l;</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line">ll ans = <span class="number">0</span>, pre[maxn], inv[maxn];</span><br><span class="line"><span class="function">ll <span class="title">fun</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !x? inv[y]: inv[y] * pre[x - <span class="number">1</span>] % M;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将要放第k层,上限为x，剩余sum个格子</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> x, <span class="keyword">int</span> sum)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(sum == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//对第i层而言，显然有i-1个上方的格子，右边的格子分别为0,1,...,a[i] - 1</span></span><br><span class="line">        <span class="comment">//i * (i + 1) * ... * (i + a[i] - 1)</span></span><br><span class="line">        ll res = pre[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)&#123;</span><br><span class="line">            res *= <span class="built_in">fun</span>(i, i + a[i] - <span class="number">1</span>);</span><br><span class="line">            res %= M;</span><br><span class="line">        &#125;</span><br><span class="line">        ans += res; asn %= M;</span><br><span class="line">        <span class="built_in">prt</span>(a, k, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= sum &amp;&amp; i &lt;= x; i++)&#123;</span><br><span class="line">        a[k] = i;</span><br><span class="line">        <span class="built_in">dfs</span>(k + <span class="number">1</span>, i, sum - i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// Fastin;</span></span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    pre[<span class="number">0</span>] = <span class="number">1</span>; inv[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">100</span>; i++)&#123;</span><br><span class="line">        pre[i] = pre[i - <span class="number">1</span>] * <span class="number">1ll</span> * i % M;</span><br><span class="line">        inv[i] = <span class="built_in">qp</span>(pre[i], M - <span class="number">2</span>, M);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i + i &lt;= n; i++)&#123;</span><br><span class="line">        a[<span class="number">0</span>] = a[<span class="number">1</span>] = i; l = i;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">2</span>, i, n - <span class="number">2</span> * i);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="K-可持久化01线段树"><a href="#K-可持久化01线段树" class="headerlink" title="K 可持久化01线段树"></a>K 可持久化01线段树</h2><p>支持区间翻转，单点置值。每次操作完后输出整个序列中1的个数。</p><p><del>貌似可持久化线段树不是很能支持直接的区间操作？</del></p><p>在这道题中，如果出现区间翻转的操作，那么将所有有关的小线段都打上tag（实际是异或加1），并将他们的结果都用$r - l + 1 - st[p]$来代替本身；而如果出现了单点置值的情况，检查一路上遇到的所有的线段的tag，将将要置的值x不断地异或上这些tag，以最终的结果作为最终要置的值。这是因为，在一个已经翻转过的线段上置值（然而此时只是对这个大线段打了tag，没有实际地修改子线段，不然会T）等价于将要置的值先翻转，不断往下走，置好后再将$st[ls] + st[rs]$的值翻转一遍后置回本身。</p><p>需要注意的是，<strong>这里的翻转tag必须要在相邻的版本之间进行继承</strong>！不然就会发生翻转信息遗漏的问题。</p><p>对于01串的区间翻转问题，这种将要置的值翻转的手段好像是一个比较通用的手法？值得学习。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mid ((l + r) &gt;&gt; 1)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e7</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, q;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> root[<span class="number">100010</span>], version = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> st[manx], tag[maxn];</span><br><span class="line"><span class="keyword">int</span> ls[maxn], rs[maxn], top = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> now = top++;</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span> now;</span><br><span class="line">    ls[now] = <span class="built_in">build</span>(l, mid);</span><br><span class="line">    rs[now] = <span class="built_in">build</span>(mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="keyword">return</span> now;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    st[p] = st[ls[p]] + st[rs[p]];</span><br><span class="line">    <span class="keyword">if</span>(tag[p]) st[p] = r - l + <span class="number">1</span> - st[p];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> now = top++;</span><br><span class="line">    tag[now] = tag[p];</span><br><span class="line">    <span class="keyword">if</span>(l == r &amp;&amp; l == k)&#123;</span><br><span class="line">        st[now] = x;</span><br><span class="line">        <span class="keyword">return</span> now;</span><br><span class="line">    &#125;</span><br><span class="line">    x ^= tag[p];</span><br><span class="line">    ls[now] = ls[p]; rs[now] = rs[p];</span><br><span class="line">    <span class="keyword">if</span>(k &lt;= mid) ls[now] = <span class="built_in">set</span>(ls[p], l, mid, k, x);</span><br><span class="line">    <span class="keyword">else</span> rs[now] = <span class="built_in">set</span>(rs[p], mid + <span class="number">1</span>, r, k, x);</span><br><span class="line">    <span class="built_in">up</span>(now, l, r);</span><br><span class="line">    <span class="keyword">return</span> now;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> now = top++;</span><br><span class="line">    ls[now] = ls[p]; rs[now] = rs[p];</span><br><span class="line">    tag[now] = tag[p];</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R)&#123;</span><br><span class="line">        st[now] = r - l + <span class="number">1</span> - st[p];</span><br><span class="line">        tag[now] ^= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> now;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= mid) ls[now] = <span class="built_in">update</span>(ls[p], l, mid, L, R);</span><br><span class="line">    <span class="keyword">if</span>(R &gt; mid) rs[now] = <span class="built_in">update</span>(rs[p], mid + <span class="number">1</span>, r, L, R);</span><br><span class="line">    <span class="built_in">up</span>(now, l, r);</span><br><span class="line">    <span class="keyword">return</span> now;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//    Fastin;</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;n, &amp;m, &amp;q);</span><br><span class="line">    root[version++] = <span class="built_in">build</span>(<span class="number">0</span>, n * m - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; q; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> op; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;op);</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> i, j; <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;i, &amp;j); i--; j--;</span><br><span class="line">            root[version] = <span class="built_in">set</span>(root[version - <span class="number">1</span>], <span class="number">0</span>, n * m - <span class="number">1</span>, i * m + j, <span class="number">1</span>);</span><br><span class="line">            version++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> i, j; <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;i, &amp;j); i--; j--;</span><br><span class="line">            root[version] = <span class="built_in">set</span>(root[version - <span class="number">1</span>], <span class="number">0</span>, n * m - <span class="number">1</span>, i * m + j, <span class="number">0</span>);</span><br><span class="line">            version++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="number">3</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> i; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;i);</span><br><span class="line">            root[version] = <span class="built_in">update</span>(root[version - <span class="number">1</span>], <span class="number">0</span>, n * m - <span class="number">1</span>, (i - <span class="number">1</span>) * m, i * m - <span class="number">1</span>);</span><br><span class="line">            version++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">            root[version] = root[x];</span><br><span class="line">            version++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, st[root[version - <span class="number">1</span>]]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="（二）"><a href="#（二）" class="headerlink" title="（二）"></a>（二）</h1><h2 id="-1"><a href="#-1" class="headerlink" title=" "></a> </h2>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>块状DS</title>
      <link href="/2021/01/16/%E5%9D%97%E7%8A%B6DS/"/>
      <url>/2021/01/16/%E5%9D%97%E7%8A%B6DS/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><span id="more"></span><h1 id="分块思想"><a href="#分块思想" class="headerlink" title="分块思想"></a>分块思想</h1><h2 id="uva-12003-区间查询数量-amp-单点修改"><a href="#uva-12003-区间查询数量-amp-单点修改" class="headerlink" title="uva 12003 区间查询数量 &amp; 单点修改"></a><a href="https://onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=3154">uva 12003</a> 区间查询数量 &amp; 单点修改</h2><p>给出序列，再给出若干次操作<code>&lt;l, r, x, u&gt;</code>，记当前序列在<code>[l, r]</code>中的值严格小于x的数量为cnt，置值<code>a[u] = k * cnt / (r - l + 1)</code>，其中k是一个提前给出的常数。</p><p>问若干次操作后的序列。</p><p><del>甚至没有想到什么常规的数据结构可以解决？可能bit套可持久化主席🌲可以。</del></p><p>然后决定莽一发$O(m<em>S</em>logS)$，对每一块维护一个有序序列，查询时$O(n/S *logS)$地对每一块二分的进行查找，修改时$O(SlogS)$地重排序块。取S为$sqrt(n)$即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">3e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, k;</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"></span><br><span class="line"><span class="comment">//块大小为S，有cnt个块</span></span><br><span class="line"><span class="keyword">int</span> S, cnt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">blk_begin</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> x / S * S;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">blk_end</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> (x / S + <span class="number">1</span>) * S;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">blk_cnt</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> x / S;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NODE</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> id; <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> NODE &amp;b)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(value != b.value) <span class="keyword">return</span> value &lt; b.value;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> id &lt; b.id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vector&lt;NODE&gt;::iterator it;</span><br><span class="line">vector&lt;NODE&gt; vec[<span class="number">1000</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ini_block</span><span class="params">()</span></span>&#123;</span><br><span class="line">    S = (<span class="keyword">int</span>)<span class="built_in">sqrt</span>(n); cnt = <span class="built_in">ceil</span>(n, S);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        vec[i / S].<span class="built_in">push_back</span>(&#123;i, a[i]&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt; i++) <span class="built_in">sort</span>(vec[i].<span class="built_in">begin</span>(), vec[i].<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查询区间l， r中有多少个数字严格小于x</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = l, j = <span class="built_in">blk_end</span>(l); i &lt; j; i++) <span class="keyword">if</span>(a[i] &lt; x) res++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="built_in">blk_begin</span>(r); i &lt;= r; i++) <span class="keyword">if</span>(a[i] &lt; x) res++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="built_in">blk_cnt</span>(l) + <span class="number">1</span>; i &lt; <span class="built_in">blk_cnt</span>(r); i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = (<span class="keyword">int</span>)vec[i].<span class="built_in">size</span>() - <span class="number">1</span>, middle;</span><br><span class="line">        <span class="keyword">if</span>(vec[i][right].value &lt; x) res += (<span class="keyword">int</span>)vec[i].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">whlie</span>(left &lt; right)&#123;</span><br><span class="line">                middle = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(vec[i][middle].value &gt;= x) right = middle;</span><br><span class="line">                <span class="keyword">else</span> left = middle + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res += left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//    Fastin;</span></span><br><span class="line">    <span class="built_in">scnaf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;n, &amp;m, &amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, a + i);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ini_block</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> l, r, x, u; <span class="built_in">scnaf</span>(<span class="string">&quot;%d %d %d %d&quot;</span>, &amp;l, &amp;r, &amp;x, &amp;u);</span><br><span class="line">        l--; r--; u--;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="built_in">fun</span>(l, r, x);</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="built_in">blk_cnt</span>(u);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;node: vec[tmep]) <span class="keyword">if</span>(node.id == u) a[u] = node.value = k * <span class="number">1ll</span> * res / (r - l + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">sort</span>(vec[temp].<span class="built_in">begin</span>(), vec[temp].<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="uva-11990-动态删除排列元素并不断询问逆序对数量"><a href="#uva-11990-动态删除排列元素并不断询问逆序对数量" class="headerlink" title="uva 11990 动态删除排列元素并不断询问逆序对数量"></a><a href="https://onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;category=0&amp;problem=3141&amp;mosmsg=Submission+received+with+ID+25956183">uva 11990</a> 动态删除排列元素并不断询问逆序对数量</h2><p>给出一个排列，并给出若干次删除操作，每次操作都删去排列中的一个数，并要求输出每次操作后的逆序对数量。</p><p>有了分块思想的指导<del>以及前一题高复杂度却AC的经验</del> 这题很容易就可以写出来分块的代码</p><p>但首先得用一些手段求出序列的逆序对个数，然后就是一些细节的注意。</p><p><strong>需要注意当可能遍历到最后一个块时需要注意不能越界！</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> a[maxn], pos[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> st[maxn &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls (p &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs ((p &lt;&lt; 1) | 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mid ((l + r) &gt;&gt; 1)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;st[p] = st[ls] + st[rs];&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r &amp;&amp; l == k) &#123;st[p] = <span class="number">1</span>; <span class="keyword">return</span>; &#125;</span><br><span class="line">    <span class="keyword">if</span>(k &lt;= mid) <span class="built_in">update</span>(ls, l, mid, k);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">update</span>(rs, mid + <span class="number">1</span>, r, k);</span><br><span class="line">    <span class="built_in">up</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R) <span class="keyword">return</span> st[p];</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= mid) ans += <span class="built_in">query</span>(ls, l, mid, L, R);</span><br><span class="line">    <span class="keyword">if</span>(R &gt; mid) ans += <span class="built_in">query</span>(rs, mid + <span class="number">1</span>, r, L, R);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">invPairs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] + <span class="number">1</span> &lt;= n) ans += <span class="built_in">query</span>(<span class="number">1</span>, <span class="number">1</span>, n, a[i] + <span class="number">1</span>, n);</span><br><span class="line">        <span class="built_in">update</span>(<span class="number">1</span>, <span class="number">1</span>, n, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//块大小为S，有cnt个块</span></span><br><span class="line"><span class="keyword">int</span> S, cnt;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; vec[<span class="number">1000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ini_block</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) vec[i].<span class="built_in">clear</span>();</span><br><span class="line">    S = (<span class="keyword">int</span>)<span class="built_in">sqrt</span>(n); cnt = <span class="built_in">ceil</span>(n, S);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        vec[i / S].<span class="built_in">push_back</span>(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt; i++) <span class="built_in">sort</span>(vec[i].<span class="built_in">begin</span>(), vec[i].<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> flag[maxn];</span><br><span class="line"><span class="comment">//删除a[pos]元素后，返回因而变化的逆序对的数量</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> blk = pos / S;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = blk * S, j = (blk + <span class="number">1</span>) * S; i &lt; j &amp;&amp; i &lt; n; i++) <span class="keyword">if</span>(!flag[i])&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; pos &amp;&amp; a[i] &gt; a[pos]) ans++;</span><br><span class="line">        <span class="keyword">if</span>(i &gt; pos &amp;&amp; a[i] &lt; a[pos]) ans++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; blk; i++) <span class="keyword">if</span>(!vec[i].<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = (<span class="keyword">int</span>)vec[i].<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(vec[i][left] &gt; a[pos]) ans += right + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> middle;</span><br><span class="line">            <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">                middle = (right + left + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(vec[i][middle] &lt; a[pos]) left = middle;</span><br><span class="line">                <span class="keyword">else</span> right = middle - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ans += (<span class="keyword">int</span>)vec[i].<span class="built_in">size</span>() - <span class="number">1</span> - left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = blk + <span class="number">1</span>; i &lt; cnt; i++) <span class="keyword">if</span>(!vec[i].<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = (<span class="keyword">int</span>)vec[i].<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(vec[i][right] &lt; a[pos]) ans += right + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> middle;</span><br><span class="line">            <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">                middle = (right + left) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(vec[i][middle] &lt; a[pos]) left = middle + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> right = middle;</span><br><span class="line">            &#125;</span><br><span class="line">            ans += left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//    Fastin;</span></span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scnaf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m))&#123;</span><br><span class="line">        <span class="built_in">clr</span>(st, <span class="number">0</span>); <span class="built_in">clr</span>(flag, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, a + i);</span><br><span class="line">            pos[a[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">ini_block</span>();</span><br><span class="line">        ll ans = <span class="built_in">invPairs</span>(), temp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            ans -= tmep;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">            temp = <span class="built_in">fun</span>(pos[x]);</span><br><span class="line">            <span class="keyword">for</span>(it = vec[pos[x] / S].<span class="built_in">begin</span>(); it != vec[pos[x] / S].<span class="built_in">end</span>(); it++) <span class="keyword">if</span>(*it == x) <span class="keyword">break</span>;</span><br><span class="line">            <span class="built_in">assert</span>(it != vec[pos[x]/ S].<span class="built_in">end</span>());</span><br><span class="line">            vec[pos[x] / S].<span class="built_in">erase</span>(it);</span><br><span class="line">            flag[pos[x]] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="sqrt-tree"><a href="#sqrt-tree" class="headerlink" title="sqrt tree"></a>sqrt tree</h1><p>给出一个序列$\{a_n\}$与一个满足结合律的运算$<em>$，如果要对区间$[l,r]$询问计算$a_l </em> a_{l+1}<em>…</em>a_r$时，sqrt tree可以在$O(nloglogn)$的时间与处理，$O1$的时间内回答。</p><p>这棵树大概是对每一个块都不断地分块，最终到达只有一个元素的叶子块。因为网上只有寥寥几篇博文以及<a href="https://oi-wiki.org/ds/sqrt-tree/">oiwiki</a>上的介绍，感觉不是特别有用的知识点（<del>大概可能用于卡常或者处理毒瘤题等</del>），故暂时弃坑。</p><h1 id="「分块」数列分块入门1-–-9-by-hzwer"><a href="#「分块」数列分块入门1-–-9-by-hzwer" class="headerlink" title="「分块」数列分块入门1 – 9 by hzwer"></a><a href="http://hzwer.com/8053.html">「分块」数列分块入门1 – 9 by hzwer</a></h1>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分块 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020数据库实验</title>
      <link href="/2021/01/15/2020%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9E%E9%AA%8C/"/>
      <url>/2021/01/15/2020%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9E%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<p>前端使用html，后台使用mysql数据库，使用php处理数据库，完成数据库课程的学籍管理系统大作业。</p><span id="more"></span><p>特此记录，有机会的话还是希望学习一番全栈的内容。</p><p><del>别的班好像做的都绘声绘色的，我们班验收者则寥寥，我太菜了</del></p><p>[toc]</p><h1 id="前台html服务"><a href="#前台html服务" class="headerlink" title="前台html服务"></a>前台html服务</h1><p>写的非常丑陋，很多冗余的代码，自己确实完全是个门外汉qaq</p><p><del>没有css 我不会</del></p><h2 id="mysql-html"><a href="#mysql-html" class="headerlink" title="mysql.html"></a>mysql.html</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span> 数据库大作业<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">center</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span> 学籍管理系统<span class="tag">&lt;/<span class="name">h1</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;fun0.html&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">h3</span>&gt;</span> admin<span class="tag">&lt;/<span class="name">h3</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;fun1.html&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">h3</span>&gt;</span> 功能1: 录入学生基本信息  <span class="tag">&lt;/<span class="name">h3</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;fun2.html&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">h3</span>&gt;</span> 功能2: 录入学生课程成绩<span class="tag">&lt;/<span class="name">h3</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;fun3.html&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">h3</span>&gt;</span> 功能3: 三种方式查询学生基本信息<span class="tag">&lt;/<span class="name">h3</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;fun4.html&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">h3</span>&gt;</span> 功能4: 查询学生课程信息<span class="tag">&lt;/<span class="name">h3</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;fun5.html&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">h3</span>&gt;</span> 功能5: 查询学生被哪些老师教过课<span class="tag">&lt;/<span class="name">h3</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;fun6.html&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">h3</span>&gt;</span> 功能6: 查询快要被开除的学生<span class="tag">&lt;/<span class="name">h3</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">center</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="fun0-html"><a href="#fun0-html" class="headerlink" title="fun0.html"></a>fun0.html</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span> 数据库大作业<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- &lt;script type=&quot;text/javascript&quot; src=&quot;../db.js&quot;&gt;&lt;/script&gt; --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">center</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;mysql.html&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">h1</span>&gt;</span> 学籍管理系统<span class="tag">&lt;/<span class="name">h1</span>&gt;</span> <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">center</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span> <span class="attr">style</span>=<span class="string">&quot;margin-left: 2em&quot;</span>&gt;</span> 显示所有表的信息:  <span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">style</span>=<span class="string">&quot;margin-left: 4em&quot;</span> <span class="attr">action</span>=<span class="string">&quot;mysql.php&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">value</span>=<span class="string">&quot;QUERY&quot;</span> <span class="attr">name</span>=<span class="string">&quot;op&quot;</span>&gt;</span>   </span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Query!&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span> <span class="attr">style</span>=<span class="string">&quot;margin-left: 2em&quot;</span>&gt;</span> 执行一堆sql语句  <span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">style</span>=<span class="string">&quot;margin-left: 4em&quot;</span> <span class="attr">action</span>=<span class="string">&quot;mysql.php&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">value</span>=<span class="string">&quot;DO&quot;</span> <span class="attr">name</span>=<span class="string">&quot;op&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">style</span>=<span class="string">&quot;height: 10em; width: 50em&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sql&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Submit!&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="fun1-html"><a href="#fun1-html" class="headerlink" title="fun1.html"></a>fun1.html</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span> 数据库大作业<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- &lt;script type=&quot;text/javascript&quot; src=&quot;../db.js&quot;&gt;&lt;/script&gt; --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">center</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;mysql.html&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">h1</span>&gt;</span> 学籍管理系统<span class="tag">&lt;/<span class="name">h1</span>&gt;</span> <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">center</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span> <span class="attr">style</span>=<span class="string">&quot;margin-left: 2em&quot;</span>&gt;</span> 功能1: 录入学生基本信息  <span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">style</span>=<span class="string">&quot;margin-left: 4em&quot;</span> <span class="attr">action</span>=<span class="string">&quot;mysql.php&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span> <span class="attr">name</span>=<span class="string">&quot;op&quot;</span>&gt;</span></span><br><span class="line">    姓名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>= <span class="string">&quot;sname&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    学号：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>= <span class="string">&quot;sno&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    性别：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;ssex&quot;</span> <span class="attr">value</span>=<span class="string">&quot;male&quot;</span>&gt;</span>男 <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;ssex&quot;</span> <span class="attr">value</span>=<span class="string">&quot;femail&quot;</span>&gt;</span>女<span class="tag">&lt;<span class="name">br</span>&gt;</span> </span><br><span class="line">    出生年月：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sbirthyear&quot;</span>&gt;</span>年<span class="tag">&lt;<span class="name">space</span>&gt;</span><span class="tag">&lt;/<span class="name">space</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sbirthmonth&quot;</span>&gt;</span>月<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    班级：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>= <span class="string">&quot;class&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Submit&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="fun2-html"><a href="#fun2-html" class="headerlink" title="fun2.html"></a>fun2.html</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span> 数据库大作业<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- &lt;script type=&quot;text/javascript&quot; src=&quot;../db.js&quot;&gt;&lt;/script&gt; --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">center</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;mysql.html&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">h1</span>&gt;</span> 学籍管理系统<span class="tag">&lt;/<span class="name">h1</span>&gt;</span> <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">center</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span> <span class="attr">style</span>=<span class="string">&quot;margin-left: 2em&quot;</span>&gt;</span> 功能2: 录入学生课程成绩  <span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">style</span>=<span class="string">&quot;margin-left: 4em&quot;</span> <span class="attr">action</span>=<span class="string">&quot;mysql.php&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">value</span>=<span class="string">&quot;2&quot;</span> <span class="attr">name</span>=<span class="string">&quot;op&quot;</span>&gt;</span>   </span><br><span class="line">    学号：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>= <span class="string">&quot;sno&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    课程名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>= <span class="string">&quot;cname&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    成绩：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>= <span class="string">&quot;grade&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    是否是补考？是<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;flag&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>&gt;</span> 否 <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;flag&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0&quot;</span> <span class="attr">checked</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="fun3-html"><a href="#fun3-html" class="headerlink" title="fun3.html"></a>fun3.html</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span> 数据库大作业<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- &lt;script type=&quot;text/javascript&quot; src=&quot;../db.js&quot;&gt;&lt;/script&gt; --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">center</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;mysql.html&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">h1</span>&gt;</span> 学籍管理系统<span class="tag">&lt;/<span class="name">h1</span>&gt;</span> <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">center</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span> <span class="attr">style</span>=<span class="string">&quot;margin-left: 2em&quot;</span>&gt;</span> 功能3.1: 按照学号查询学生信息  <span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">style</span>=<span class="string">&quot;margin-left: 4em&quot;</span> <span class="attr">action</span>=<span class="string">&quot;mysql.php&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">value</span>=<span class="string">&quot;31&quot;</span> <span class="attr">name</span>=<span class="string">&quot;op&quot;</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sno&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span> <span class="attr">style</span>=<span class="string">&quot;margin-left: 2em&quot;</span>&gt;</span> 功能3.2: 按照姓名查询学生信息  <span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">style</span>=<span class="string">&quot;margin-left: 4em&quot;</span> <span class="attr">action</span>=<span class="string">&quot;mysql.php&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">value</span>=<span class="string">&quot;32&quot;</span> <span class="attr">name</span>=<span class="string">&quot;op&quot;</span>&gt;</span>   </span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sname&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span> <span class="attr">style</span>=<span class="string">&quot;margin-left: 2em&quot;</span>&gt;</span> 功能3.3: 按照专业查询学生信息  <span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">style</span>=<span class="string">&quot;margin-left: 4em&quot;</span> <span class="attr">action</span>=<span class="string">&quot;mysql.php&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">value</span>=<span class="string">&quot;33&quot;</span> <span class="attr">name</span>=<span class="string">&quot;op&quot;</span>&gt;</span>   </span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;major&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="fun4-html"><a href="#fun4-html" class="headerlink" title="fun4.html"></a>fun4.html</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span> 数据库大作业<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- &lt;script type=&quot;text/javascript&quot; src=&quot;../db.js&quot;&gt;&lt;/script&gt; --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">center</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;mysql.html&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">h1</span>&gt;</span> 学籍管理系统<span class="tag">&lt;/<span class="name">h1</span>&gt;</span> <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">center</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span> <span class="attr">style</span>=<span class="string">&quot;margin-left: 2em&quot;</span>&gt;</span> 功能4: 查询学生课程成绩  <span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">style</span>=<span class="string">&quot;margin-left: 4em&quot;</span> <span class="attr">action</span>=<span class="string">&quot;mysql.php&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">value</span>=<span class="string">&quot;4&quot;</span> <span class="attr">name</span>=<span class="string">&quot;op&quot;</span>&gt;</span>   </span><br><span class="line">    学号：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>= <span class="string">&quot;sno&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Submit&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="fun5-html"><a href="#fun5-html" class="headerlink" title="fun5.html"></a>fun5.html</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span> 数据库大作业<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- &lt;script type=&quot;text/javascript&quot; src=&quot;../db.js&quot;&gt;&lt;/script&gt; --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">center</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;mysql.html&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">h1</span>&gt;</span> 学籍管理系统<span class="tag">&lt;/<span class="name">h1</span>&gt;</span> <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">center</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span> <span class="attr">style</span>=<span class="string">&quot;margin-left: 2em&quot;</span>&gt;</span> 功能5: 查询学生被哪些老师教过课  <span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">style</span>=<span class="string">&quot;margin-left: 4em&quot;</span> <span class="attr">action</span>=<span class="string">&quot;mysql.php&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">value</span>=<span class="string">&quot;5&quot;</span> <span class="attr">name</span>=<span class="string">&quot;op&quot;</span>&gt;</span>   </span><br><span class="line">    学号：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>= <span class="string">&quot;sno&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="fun6-html"><a href="#fun6-html" class="headerlink" title="fun6.html"></a>fun6.html</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span> 数据库大作业<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- &lt;script type=&quot;text/javascript&quot; src=&quot;../db.js&quot;&gt;&lt;/script&gt; --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">center</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;mysql.html&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">h1</span>&gt;</span> 学籍管理系统<span class="tag">&lt;/<span class="name">h1</span>&gt;</span> <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">center</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span> <span class="attr">style</span>=<span class="string">&quot;margin-left: 2em&quot;</span>&gt;</span> 功能6: 查询所有将要/已经被开除的学生信息  <span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">style</span>=<span class="string">&quot;margin-left: 4em&quot;</span> <span class="attr">action</span>=<span class="string">&quot;mysql.php&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">value</span>=<span class="string">&quot;6&quot;</span> <span class="attr">name</span>=<span class="string">&quot;op&quot;</span>&gt;</span>   </span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;查询&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="后台php服务"><a href="#后台php服务" class="headerlink" title="后台php服务"></a>后台php服务</h1><p><del>会被sql注入，容易遭到恶意攻击，安全性为零。</del></p><p>特地写了cpp程序来生成插入、查询、绘表等操作指令。</p><p>不知道有没有别的什么办法来弄的简洁漂亮一些orz</p><p>自己对于后端也是啥也不懂qaq</p><h2 id="mysql-php"><a href="#mysql-php" class="headerlink" title="mysql.php"></a>mysql.php</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;center&gt; &lt;a href=\&quot;mysql.html\&quot;&gt;&lt;h1&gt; 学籍管理系统&lt;/h1&gt; &lt;/a&gt;&lt;/center&gt;&lt;br&gt;&lt;br&gt;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$conn</span> = mysqli_connect(<span class="string">&quot;localhost:3306&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;xxxx&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(!<span class="variable">$conn</span>) <span class="keyword">die</span>(<span class="string">&quot;连接数据库失败: &quot;</span> . mysqli_error(<span class="variable">$conn</span>));</span><br><span class="line"><span class="keyword">if</span>(!mysqli_query(<span class="variable">$conn</span>, <span class="string">&quot;use db&quot;</span>)) <span class="keyword">die</span>(<span class="string">&quot;选择数据库失败: &quot;</span> . mysqli_error(<span class="variable">$conn</span>));</span><br><span class="line"></span><br><span class="line"><span class="variable">$op</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;op&#x27;</span>];</span><br><span class="line"><span class="comment">//查询所有表的所有信息。</span></span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$op</span> == <span class="string">&#x27;QUERY&#x27;</span>)&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;&lt;center&gt;&#x27;</span>;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;&lt;h2&gt; 查询结果如下所示: &lt;br&gt;&lt;br&gt;&lt;/h2&gt;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="variable">$res</span> = mysqli_query(<span class="variable">$conn</span>, <span class="string">&quot;select * from classinfo&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(!<span class="variable">$res</span>) <span class="keyword">die</span>(<span class="string">&quot;无法读取数据: &quot;</span> . mysqli_error(<span class="variable">$conn</span>));</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;&lt;h4&gt; 班级--专业表classinfo&lt;br&gt;&lt;/h4&gt;&#x27;</span>;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;&lt;table border=&quot;1&quot;&gt;&lt;tr&gt;&lt;td&gt;class&lt;/td&gt;&lt;td&gt;major&lt;/td&gt;&lt;/tr&gt;&#x27;</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="variable">$row</span> = mysqli_fetch_array(<span class="variable">$res</span>, MYSQLI_ASSOC))&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;&lt;tr&gt;&lt;td&gt;<span class="subst">&#123;$row[&#x27;class&#x27;]&#125;</span>&lt;/td&gt;&lt;td&gt;<span class="subst">&#123;$row[&#x27;major&#x27;]&#125;</span>&lt;/td&gt;&lt;/tr&gt;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;&lt;/table&gt;&lt;br&gt;&lt;br&gt;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="variable">$res</span> = mysqli_query(<span class="variable">$conn</span>, <span class="string">&quot;select * from course&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(!<span class="variable">$res</span>) <span class="keyword">die</span>(<span class="string">&quot;无法读取数据: &quot;</span> . mysqli_error(<span class="variable">$conn</span>));</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;&lt;h4&gt; 课程--学分表course &lt;br&gt;&lt;/h4&gt;&#x27;</span>;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;&lt;table border=&quot;1&quot;&gt;&lt;tr&gt;&lt;td&gt;cname&lt;/td&gt;&lt;td&gt;ccre&lt;/td&gt;&lt;/tr&gt;&#x27;</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="variable">$row</span> = mysqli_fetch_array(<span class="variable">$res</span>, MYSQLI_ASSOC))&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;&lt;tr&gt;&lt;td&gt;<span class="subst">&#123;$row[&#x27;cname&#x27;]&#125;</span>&lt;/td&gt;&lt;td&gt;<span class="subst">&#123;$row[&#x27;ccre&#x27;]&#125;</span>&lt;/td&gt;&lt;/tr&gt;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;&lt;/table&gt;&lt;br&gt;&lt;br&gt;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="variable">$res</span> = mysqli_query(<span class="variable">$conn</span>, <span class="string">&quot;select * from stu&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(!<span class="variable">$res</span>) <span class="keyword">die</span>(<span class="string">&quot;无法读取数据: &quot;</span> . mysqli_error(<span class="variable">$conn</span>));</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;&lt;h4&gt; 学生信息表stu &lt;br&gt;&lt;/h4&gt;&#x27;</span>;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;&lt;table border=&quot;1&quot;&gt;&lt;tr&gt;&lt;td&gt;sno&lt;/td&gt;&lt;td&gt;sname&lt;/td&gt;&lt;td&gt;ssex&lt;/td&gt;&lt;td&gt;sbirthyear&lt;/td&gt;&lt;td&gt;sbirthmonth&lt;/td&gt;&lt;td&gt;class&lt;/td&gt;&lt;/tr&gt;&#x27;</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="variable">$row</span> = mysqli_fetch_array(<span class="variable">$res</span>, MYSQLI_ASSOC))&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;&lt;tr&gt;&lt;td&gt;<span class="subst">&#123;$row[&#x27;sno&#x27;]&#125;</span>&lt;/td&gt;&lt;td&gt;<span class="subst">&#123;$row[&#x27;sname&#x27;]&#125;</span>&lt;/td&gt;&lt;td&gt;<span class="subst">&#123;$row[&#x27;ssex&#x27;]&#125;</span>&lt;/td&gt;&lt;td&gt;<span class="subst">&#123;$row[&#x27;sbirthyear&#x27;]&#125;</span>&lt;/td&gt;&lt;td&gt;<span class="subst">&#123;$row[&#x27;sbirthmonth&#x27;]&#125;</span>&lt;/td&gt;&lt;td&gt;<span class="subst">&#123;$row[&#x27;class&#x27;]&#125;</span>&lt;/td&gt;&lt;/tr&gt;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;&lt;/table&gt;&lt;br&gt;&lt;br&gt;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="variable">$res</span> = mysqli_query(<span class="variable">$conn</span>, <span class="string">&quot;select * from schedule&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(!<span class="variable">$res</span>) <span class="keyword">die</span>(<span class="string">&quot;无法读取数据: &quot;</span> . mysqli_error(<span class="variable">$conn</span>));</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;&lt;h4&gt; 培养方案表schedule &lt;br&gt;&lt;/h4&gt;&#x27;</span>;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;&lt;table border=&quot;1&quot;&gt;&lt;tr&gt;&lt;td&gt;major&lt;/td&gt;&lt;td&gt;cname&lt;/td&gt;&lt;td&gt;iscompulsory&lt;/td&gt;&lt;td&gt;cdate&lt;/td&gt;&lt;/tr&gt;&#x27;</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="variable">$row</span> = mysqli_fetch_array(<span class="variable">$res</span>, MYSQLI_ASSOC))&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;&lt;tr&gt;&lt;td&gt;<span class="subst">&#123;$row[&#x27;major&#x27;]&#125;</span>&lt;/td&gt;&lt;td&gt;<span class="subst">&#123;$row[&#x27;cname&#x27;]&#125;</span>&lt;/td&gt;&lt;td&gt;<span class="subst">&#123;$row[&#x27;iscompulsory&#x27;]&#125;</span>&lt;/td&gt;&lt;td&gt;<span class="subst">&#123;$row[&#x27;cdate&#x27;]&#125;</span>&lt;/td&gt;&lt;/tr&gt;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;&lt;/table&gt;&lt;br&gt;&lt;br&gt;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="variable">$res</span> = mysqli_query(<span class="variable">$conn</span>, <span class="string">&quot;select * from teaching&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(!<span class="variable">$res</span>) <span class="keyword">die</span>(<span class="string">&quot;无法读取数据: &quot;</span> . mysqli_error(<span class="variable">$conn</span>));</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;&lt;h4&gt; 带课情况表teaching&lt;br&gt;&lt;/h4&gt;&#x27;</span>;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;&lt;table border=&quot;1&quot;&gt;&lt;tr&gt;&lt;td&gt;class&lt;/td&gt;&lt;td&gt;cname&lt;/td&gt;&lt;td&gt;tname&lt;/td&gt;&lt;/tr&gt;&#x27;</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="variable">$row</span> = mysqli_fetch_array(<span class="variable">$res</span>, MYSQLI_ASSOC))&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;&lt;tr&gt;&lt;td&gt;<span class="subst">&#123;$row[&#x27;class&#x27;]&#125;</span>&lt;/td&gt;&lt;td&gt;<span class="subst">&#123;$row[&#x27;cname&#x27;]&#125;</span>&lt;/td&gt;&lt;td&gt;<span class="subst">&#123;$row[&#x27;tname&#x27;]&#125;</span>&lt;/td&gt;&lt;/tr&gt;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;&lt;/table&gt;&lt;br&gt;&lt;br&gt;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="variable">$res</span> = mysqli_query(<span class="variable">$conn</span>, <span class="string">&quot;select * from sc&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(!<span class="variable">$res</span>) <span class="keyword">die</span>(<span class="string">&quot;无法读取数据: &quot;</span> . mysqli_error(<span class="variable">$conn</span>));</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;&lt;h4&gt; 选课成绩表teaching&lt;br&gt;&lt;/h4&gt;&#x27;</span>;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;&lt;table border=&quot;1&quot;&gt;&lt;tr&gt;&lt;td&gt;sno&lt;/td&gt;&lt;td&gt;cname&lt;/td&gt;&lt;td&gt;grade&lt;/td&gt;&lt;td&gt;是否是补考成绩&lt;/td&gt;&lt;/tr&gt;&#x27;</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="variable">$row</span> = mysqli_fetch_array(<span class="variable">$res</span>, MYSQLI_ASSOC))&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;&lt;tr&gt;&lt;td&gt;<span class="subst">&#123;$row[&#x27;sno&#x27;]&#125;</span>&lt;/td&gt;&lt;td&gt;<span class="subst">&#123;$row[&#x27;cname&#x27;]&#125;</span>&lt;/td&gt;&lt;td&gt;<span class="subst">&#123;$row[&#x27;grade&#x27;]&#125;</span>&lt;/td&gt;&lt;td&gt;<span class="subst">&#123;$row[&#x27;flag&#x27;]&#125;</span>&lt;/td&gt;&lt;/tr&gt;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;&lt;/table&gt;&lt;br&gt;&lt;br&gt;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;&lt;/center&gt;&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(<span class="variable">$op</span> == <span class="string">&#x27;DO&#x27;</span>)&#123;</span><br><span class="line">    <span class="variable">$sql</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;sql&#x27;</span>];</span><br><span class="line">    <span class="comment">// if(!mysqli_query($conn, $sql)) die(&quot;DO失败: &quot; . mysqli_error($conn));</span></span><br><span class="line">    <span class="keyword">if</span>(!mysqli_multi_query(<span class="variable">$conn</span>, <span class="variable">$sql</span>)) <span class="keyword">die</span>(<span class="string">&quot;DO失败: &quot;</span> . mysqli_error(<span class="variable">$conn</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(<span class="variable">$op</span> == <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">    <span class="variable">$sno</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;sno&#x27;</span>];</span><br><span class="line">    <span class="variable">$sname</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;sname&#x27;</span>];</span><br><span class="line">    <span class="variable">$ssex</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;ssex&#x27;</span>];</span><br><span class="line">    <span class="variable">$sbirthyear</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;sbirthyear&#x27;</span>];</span><br><span class="line">    <span class="variable">$sbirthmonth</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;sbirthmonth&#x27;</span>];</span><br><span class="line">    <span class="variable">$class</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;class&#x27;</span>];</span><br><span class="line"></span><br><span class="line">    <span class="variable">$sql</span> = <span class="string">&quot;insert into stu (sno, sname, ssex, sbirthyear, sbirthmonth, class) values(</span></span><br><span class="line"><span class="string">        &#x27;&quot;</span> .<span class="variable">$sno</span> .<span class="string">&quot;&#x27;,</span></span><br><span class="line"><span class="string">        &#x27;&quot;</span> .<span class="variable">$sname</span> .<span class="string">&quot;&#x27;,</span></span><br><span class="line"><span class="string">        &#x27;&quot;</span> .<span class="variable">$ssex</span> .<span class="string">&quot;&#x27;,</span></span><br><span class="line"><span class="string">        &#x27;&quot;</span> .<span class="variable">$sbirthyear</span> .<span class="string">&quot;&#x27;,</span></span><br><span class="line"><span class="string">        &#x27;&quot;</span> .<span class="variable">$sbirthmonth</span> .<span class="string">&quot;&#x27;,</span></span><br><span class="line"><span class="string">        &#x27;&quot;</span> .<span class="variable">$class</span> .<span class="string">&quot;&#x27;</span></span><br><span class="line"><span class="string">    )&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(!mysqli_query(<span class="variable">$conn</span>, <span class="variable">$sql</span>)) <span class="keyword">die</span>(<span class="string">&quot;操作1执行失败，无法插入: &quot;</span> . mysqli_error(<span class="variable">$conn</span>));</span><br><span class="line">    <span class="comment">// echo $sql;</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(<span class="variable">$op</span> == <span class="string">&#x27;2&#x27;</span>)&#123;</span><br><span class="line">    <span class="variable">$sno</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;sno&#x27;</span>];</span><br><span class="line">    <span class="variable">$cname</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;cname&#x27;</span>];</span><br><span class="line">    <span class="variable">$grade</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;grade&#x27;</span>];</span><br><span class="line">    <span class="variable">$flag</span> =<span class="variable">$_POST</span>[<span class="string">&#x27;flag&#x27;</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="variable">$fail</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable">$flag</span> == <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">        <span class="variable">$sql</span> = <span class="string">&quot;select * from sc where sno = &#x27;&quot;</span> .<span class="variable">$sno</span> .<span class="string">&quot;&#x27; AND cname = &#x27;&quot;</span> .<span class="variable">$cname</span> .<span class="string">&quot;&#x27;&quot;</span>;</span><br><span class="line">        <span class="variable">$res</span> = mysqli_query(<span class="variable">$conn</span>, <span class="variable">$sql</span>);</span><br><span class="line">        <span class="keyword">while</span>(<span class="variable">$row</span> = mysqli_fetch_array(<span class="variable">$res</span>, MYSQLI_ASSOC))&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="variable">$row</span>[<span class="string">&#x27;flag&#x27;</span>] == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="variable">$fail</span> = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(<span class="variable">$row</span>[<span class="string">&#x27;grade&#x27;</span>] &gt; <span class="variable">$grade</span>)&#123;</span><br><span class="line">                <span class="variable">$fail</span> = <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="variable">$fail</span> == <span class="number">1</span>) <span class="keyword">die</span>(<span class="string">&quot;&lt;center&gt;该学生已经补考过一次, 不得再次补考!&lt;/center&gt;&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="variable">$fail</span> == <span class="number">2</span>) <span class="keyword">die</span>(<span class="string">&quot;&lt;center&gt;该学生补考成绩不如正式考试!不予修改!&lt;/center&gt;&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="variable">$sql</span> = <span class="string">&quot;update sc</span></span><br><span class="line"><span class="string">        set grade = &#x27;&quot;</span> .<span class="variable">$grade</span> .<span class="string">&quot;&#x27;,</span></span><br><span class="line"><span class="string">        flag = &#x27;1&#x27;</span></span><br><span class="line"><span class="string">        where sno = &#x27;&quot;</span> .<span class="variable">$sno</span> .<span class="string">&quot;&#x27;</span></span><br><span class="line"><span class="string">        AND cname = &#x27;&quot;</span> .<span class="variable">$cname</span> .<span class="string">&quot;&#x27;</span></span><br><span class="line"><span class="string">        &quot;</span>;</span><br><span class="line">        <span class="comment">// echo $sql. &#x27;&lt;br&gt;&#x27;;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="variable">$sql</span> = <span class="string">&quot;insert into sc (sno, cname, grade, flag) values(</span></span><br><span class="line"><span class="string">            &#x27;&quot;</span> .<span class="variable">$sno</span> .<span class="string">&quot;&#x27;,</span></span><br><span class="line"><span class="string">            &#x27;&quot;</span> .<span class="variable">$cname</span> .<span class="string">&quot;&#x27;,</span></span><br><span class="line"><span class="string">            &#x27;&quot;</span> .<span class="variable">$grade</span> .<span class="string">&quot;&#x27;,</span></span><br><span class="line"><span class="string">            &#x27;&quot;</span> .<span class="variable">$flag</span> . <span class="string">&quot;&#x27;</span></span><br><span class="line"><span class="string">        )&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(!mysqli_query(<span class="variable">$conn</span>, <span class="variable">$sql</span>)) <span class="keyword">die</span>(<span class="string">&quot;插入成绩失败: &quot;</span> . mysqli_error(<span class="variable">$conn</span>));</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(<span class="variable">$op</span> == <span class="string">&#x27;31&#x27;</span>)&#123;</span><br><span class="line">    <span class="variable">$sno</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;sno&#x27;</span>];</span><br><span class="line">    <span class="variable">$sql</span> = <span class="string">&quot;select * from stu where sno=&#x27;&quot;</span> .<span class="variable">$sno</span> .<span class="string">&quot;&#x27;&quot;</span>;</span><br><span class="line">    <span class="variable">$res</span> = mysqli_query(<span class="variable">$conn</span>, <span class="variable">$sql</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;&lt;center&gt;&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="variable">$res</span>) <span class="keyword">die</span>(<span class="string">&quot;无法读取数据: &quot;</span> . mysqli_error(<span class="variable">$conn</span>));</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;&lt;h4&gt; 学生信息表stu &lt;br&gt;&lt;/h4&gt;&#x27;</span>;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;&lt;table border=&quot;1&quot;&gt;&lt;tr&gt;&lt;td&gt;学号&lt;/td&gt;&lt;td&gt;学生姓名&lt;/td&gt;&lt;td&gt;性别&lt;/td&gt;&lt;td&gt;出生年份&lt;/td&gt;&lt;td&gt;出生月份&lt;/td&gt;&lt;td&gt;班级&lt;/td&gt;&lt;/tr&gt;&#x27;</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="variable">$row</span> = mysqli_fetch_array(<span class="variable">$res</span>, MYSQLI_ASSOC))&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;&lt;tr&gt;&lt;td&gt;<span class="subst">&#123;$row[&#x27;sno&#x27;]&#125;</span>&lt;/td&gt;&lt;td&gt;<span class="subst">&#123;$row[&#x27;sname&#x27;]&#125;</span>&lt;/td&gt;&lt;td&gt;<span class="subst">&#123;$row[&#x27;ssex&#x27;]&#125;</span>&lt;/td&gt;&lt;td&gt;<span class="subst">&#123;$row[&#x27;sbirthyear&#x27;]&#125;</span>&lt;/td&gt;&lt;td&gt;<span class="subst">&#123;$row[&#x27;sbirthmonth&#x27;]&#125;</span>&lt;/td&gt;&lt;td&gt;<span class="subst">&#123;$row[&#x27;class&#x27;]&#125;</span>&lt;/td&gt;&lt;/tr&gt;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;&lt;/table&gt;&lt;br&gt;&lt;br&gt;&lt;/center&gt;&#x27;</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(<span class="variable">$op</span> == <span class="string">&#x27;32&#x27;</span>)&#123;</span><br><span class="line">    <span class="variable">$sname</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;sname&#x27;</span>];</span><br><span class="line">    <span class="variable">$sql</span> = <span class="string">&quot;select * from stu where sname=&#x27;&quot;</span> .<span class="variable">$sname</span> .<span class="string">&quot;&#x27;&quot;</span>;</span><br><span class="line">    <span class="variable">$res</span> = mysqli_query(<span class="variable">$conn</span>, <span class="variable">$sql</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;&lt;center&gt;&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="variable">$res</span>) <span class="keyword">die</span>(<span class="string">&quot;无法读取数据: &quot;</span> . mysqli_error(<span class="variable">$conn</span>));</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;&lt;h4&gt; 学生信息表stu &lt;br&gt;&lt;/h4&gt;&#x27;</span>;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;&lt;table border=&quot;1&quot;&gt;&lt;tr&gt;&lt;td&gt;学号&lt;/td&gt;&lt;td&gt;学生姓名&lt;/td&gt;&lt;td&gt;性别&lt;/td&gt;&lt;td&gt;出生年份&lt;/td&gt;&lt;td&gt;出生月份&lt;/td&gt;&lt;td&gt;班级&lt;/td&gt;&lt;/tr&gt;&#x27;</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="variable">$row</span> = mysqli_fetch_array(<span class="variable">$res</span>, MYSQLI_ASSOC))&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;&lt;tr&gt;&lt;td&gt;<span class="subst">&#123;$row[&#x27;sno&#x27;]&#125;</span>&lt;/td&gt;&lt;td&gt;<span class="subst">&#123;$row[&#x27;sname&#x27;]&#125;</span>&lt;/td&gt;&lt;td&gt;<span class="subst">&#123;$row[&#x27;ssex&#x27;]&#125;</span>&lt;/td&gt;&lt;td&gt;<span class="subst">&#123;$row[&#x27;sbirthyear&#x27;]&#125;</span>&lt;/td&gt;&lt;td&gt;<span class="subst">&#123;$row[&#x27;sbirthmonth&#x27;]&#125;</span>&lt;/td&gt;&lt;td&gt;<span class="subst">&#123;$row[&#x27;class&#x27;]&#125;</span>&lt;/td&gt;&lt;/tr&gt;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;&lt;/table&gt;&lt;br&gt;&lt;br&gt;&lt;/center&gt;&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(<span class="variable">$op</span> == <span class="string">&#x27;33&#x27;</span>)&#123;</span><br><span class="line">    <span class="variable">$major</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;major&#x27;</span>];</span><br><span class="line">    <span class="variable">$sql</span> = <span class="string">&quot;select * from stu, classinfo where stu.class=classinfo.class AND classinfo.major = &#x27;&quot;</span> .<span class="variable">$major</span>. <span class="string">&quot;&#x27;&quot;</span>;</span><br><span class="line">    <span class="variable">$res</span> = mysqli_query(<span class="variable">$conn</span>, <span class="variable">$sql</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;&lt;center&gt;&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="variable">$res</span>) <span class="keyword">die</span>(<span class="string">&quot;无法读取数据: &quot;</span> . mysqli_error(<span class="variable">$conn</span>));</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;&lt;h4&gt; 学生信息表stu &lt;br&gt;&lt;/h4&gt;&#x27;</span>;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;&lt;table border=&quot;1&quot;&gt;&lt;tr&gt;&lt;td&gt;学号&lt;/td&gt;&lt;td&gt;学生姓名&lt;/td&gt;&lt;td&gt;性别&lt;/td&gt;&lt;td&gt;出生年份&lt;/td&gt;&lt;td&gt;出生月份&lt;/td&gt;&lt;td&gt;班级&lt;/td&gt;&lt;/tr&gt;&#x27;</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="variable">$row</span> = mysqli_fetch_array(<span class="variable">$res</span>, MYSQLI_ASSOC))&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;&lt;tr&gt;&lt;td&gt;<span class="subst">&#123;$row[&#x27;sno&#x27;]&#125;</span>&lt;/td&gt;&lt;td&gt;<span class="subst">&#123;$row[&#x27;sname&#x27;]&#125;</span>&lt;/td&gt;&lt;td&gt;<span class="subst">&#123;$row[&#x27;ssex&#x27;]&#125;</span>&lt;/td&gt;&lt;td&gt;<span class="subst">&#123;$row[&#x27;sbirthyear&#x27;]&#125;</span>&lt;/td&gt;&lt;td&gt;<span class="subst">&#123;$row[&#x27;sbirthmonth&#x27;]&#125;</span>&lt;/td&gt;&lt;td&gt;<span class="subst">&#123;$row[&#x27;class&#x27;]&#125;</span>&lt;/td&gt;&lt;/tr&gt;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;&lt;/table&gt;&lt;br&gt;&lt;br&gt;&lt;/center&gt;&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(<span class="variable">$op</span> == <span class="string">&#x27;4&#x27;</span>)&#123;</span><br><span class="line">    <span class="variable">$sno</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;sno&#x27;</span>];</span><br><span class="line">    <span class="variable">$sql</span>=<span class="string">&quot;select * from temp where sno=&#x27;&quot;</span> .<span class="variable">$sno</span>.<span class="string">&quot;&#x27;&quot;</span>;</span><br><span class="line">    <span class="variable">$res</span> = mysqli_query(<span class="variable">$conn</span>, <span class="variable">$sql</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;&lt;center&gt;&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="variable">$res</span>) <span class="keyword">die</span>(<span class="string">&quot;无法读取数据: &quot;</span> . mysqli_error(<span class="variable">$conn</span>));</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;&lt;h4&gt; 学生成绩单 &lt;br&gt;&lt;/h4&gt;&#x27;</span>;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;&lt;table border=&quot;1&quot;&gt;&lt;tr&gt;&lt;td&gt;课程名&lt;/td&gt;&lt;td&gt;是否必修&lt;/td&gt;&lt;td&gt;课程开课时间&lt;/td&gt;&lt;td&gt;课程学分&lt;/td&gt;&lt;td&gt;课程成绩&lt;/td&gt;&lt;td&gt;是否补考&lt;/td&gt;&lt;/tr&gt;&#x27;</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="variable">$row</span> = mysqli_fetch_array(<span class="variable">$res</span>, MYSQLI_ASSOC))&#123;</span><br><span class="line">        <span class="variable">$temp</span> = <span class="string">&quot;&lt;tr&gt;&lt;td&gt;<span class="subst">&#123;$row[&#x27;cname&#x27;]&#125;</span>&lt;/td&gt; &lt;td&gt;&quot;</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="variable">$row</span>[<span class="string">&#x27;iscompulsory&#x27;</span>] == <span class="string">&#x27;1&#x27;</span>) <span class="variable">$temp</span> .= <span class="string">&quot;是&quot;</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="variable">$temp</span> .= <span class="string">&quot;否&quot;</span>;</span><br><span class="line">        <span class="variable">$temp</span> .= <span class="string">&quot;&lt;/td&gt;&lt;td&gt;<span class="subst">&#123;$row[&#x27;cdate&#x27;]&#125;</span>&lt;/td&gt;&lt;td&gt;<span class="subst">&#123;$row[&#x27;ccre&#x27;]&#125;</span>&lt;/td&gt;&lt;td&gt;<span class="subst">&#123;$row[&#x27;grade&#x27;]&#125;</span>&lt;/td&gt;&lt;td&gt;&quot;</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="variable">$row</span>[<span class="string">&#x27;flag&#x27;</span>] == <span class="number">1</span>) <span class="variable">$temp</span> .= <span class="string">&quot;是&quot;</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="variable">$temp</span> .= <span class="string">&quot;否&quot;</span>;</span><br><span class="line">        <span class="variable">$temp</span> .= <span class="string">&quot;&lt;/td&gt;&lt;/tr&gt;&quot;</span>;</span><br><span class="line">        <span class="keyword">echo</span> <span class="variable">$temp</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;&lt;/table&gt;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="variable">$sql</span>=</span><br><span class="line">    <span class="string">&quot;select sno, sum(ccre * grade)/sum(ccre) aver</span></span><br><span class="line"><span class="string">    from temp</span></span><br><span class="line"><span class="string">    where iscompulsory=&#x27;1&#x27; AND sno=&#x27;&quot;</span> .<span class="variable">$sno</span> .<span class="string">&quot;&#x27;&quot;</span>;</span><br><span class="line">    <span class="variable">$res</span> = mysqli_query(<span class="variable">$conn</span>, <span class="variable">$sql</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;&lt;center&gt;&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="variable">$res</span>) <span class="keyword">die</span>(<span class="string">&quot;无法读取数据: &quot;</span> . mysqli_error(<span class="variable">$conn</span>));</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;&lt;table border=&quot;1&quot;&gt;&lt;tr&gt;&lt;td&gt;学号&lt;/td&gt;&lt;td&gt;必修平均分&lt;/td&gt;&lt;/tr&gt;&#x27;</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="variable">$row</span> = mysqli_fetch_array(<span class="variable">$res</span>, MYSQLI_ASSOC))&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;&lt;tr&gt;&lt;td&gt;<span class="subst">&#123;$row[&#x27;sno&#x27;]&#125;</span>&lt;/td&gt;&lt;td&gt;<span class="subst">&#123;$row[&#x27;aver&#x27;]&#125;</span>&lt;/td&gt;&lt;/tr&gt;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;&lt;/table&gt;&#x27;</span>;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="variable">$sql</span>=</span><br><span class="line">    <span class="string">&quot;select sno, sum(ccre * grade)/sum(ccre) aver</span></span><br><span class="line"><span class="string">    from temp</span></span><br><span class="line"><span class="string">    where sno=&#x27;&quot;</span> .<span class="variable">$sno</span> .<span class="string">&quot;&#x27;&quot;</span>;</span><br><span class="line">    <span class="variable">$res</span> = mysqli_query(<span class="variable">$conn</span>, <span class="variable">$sql</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;&lt;center&gt;&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="variable">$res</span>) <span class="keyword">die</span>(<span class="string">&quot;无法读取数据: &quot;</span> . mysqli_error(<span class="variable">$conn</span>));</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;&lt;table border=&quot;1&quot;&gt;&lt;tr&gt;&lt;td&gt;学号&lt;/td&gt;&lt;td&gt;总平均分&lt;/td&gt;&lt;/tr&gt;&#x27;</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="variable">$row</span> = mysqli_fetch_array(<span class="variable">$res</span>, MYSQLI_ASSOC))&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;&lt;tr&gt;&lt;td&gt;<span class="subst">&#123;$row[&#x27;sno&#x27;]&#125;</span>&lt;/td&gt;&lt;td&gt;<span class="subst">&#123;$row[&#x27;aver&#x27;]&#125;</span>&lt;/td&gt;&lt;/tr&gt;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;&lt;/table&gt;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;&lt;/center&gt;&#x27;</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(<span class="variable">$op</span> == <span class="string">&#x27;5&#x27;</span>)&#123;</span><br><span class="line">    <span class="variable">$sno</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;sno&#x27;</span>];</span><br><span class="line">    <span class="variable">$sql</span> = </span><br><span class="line">    <span class="string">&quot;select teaching.tname, teaching.cname</span></span><br><span class="line"><span class="string">    from stu, teaching, sc</span></span><br><span class="line"><span class="string">    where stu.class=teaching.class AND stu.sno=sc.sno AND sc.cname=teaching.cname</span></span><br><span class="line"><span class="string">    AND stu.sno=&#x27;&quot;</span> .<span class="variable">$sno</span>.<span class="string">&quot;&#x27;&quot;</span>;</span><br><span class="line">    <span class="variable">$res</span> = mysqli_query(<span class="variable">$conn</span>, <span class="variable">$sql</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;&lt;center&gt;&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="variable">$res</span>) <span class="keyword">die</span>(<span class="string">&quot;无法读取数据: &quot;</span> . mysqli_error(<span class="variable">$conn</span>));</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;&lt;h4&gt; 学生-教师表stu &lt;br&gt;&lt;/h4&gt;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;&lt;table border=&quot;1&quot;&gt;&lt;tr&gt;&lt;td&gt;教师姓名&lt;/td&gt;&lt;td&gt;课程名&lt;/td&gt;&lt;/tr&gt;&#x27;</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="variable">$row</span> = mysqli_fetch_array(<span class="variable">$res</span>, MYSQLI_ASSOC))&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;&lt;tr&gt;&lt;td&gt;<span class="subst">&#123;$row[&#x27;tname&#x27;]&#125;</span>&lt;/td&gt;&lt;td&gt;<span class="subst">&#123;$row[&#x27;cname&#x27;]&#125;</span>&lt;/td&gt;&lt;/tr&gt;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;&lt;/table&gt;&lt;/center&gt;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(<span class="variable">$op</span> == <span class="string">&#x27;6&#x27;</span>)&#123;</span><br><span class="line">    <span class="variable">$sno</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;sno&#x27;</span>];</span><br><span class="line">    <span class="variable">$sql</span>=</span><br><span class="line">    <span class="string">&quot;select temp.sno , stu.sname, sum(temp.ccre) sumcre</span></span><br><span class="line"><span class="string">    from temp, stu</span></span><br><span class="line"><span class="string">    where temp.iscompulsory=&#x27;1&#x27; AND temp.grade &lt; 60 AND temp.sno=stu.sno</span></span><br><span class="line"><span class="string">    group by temp.sno</span></span><br><span class="line"><span class="string">    having sum(temp.ccre) &gt; 7&quot;</span>;</span><br><span class="line">    <span class="variable">$res</span> = mysqli_query(<span class="variable">$conn</span>, <span class="variable">$sql</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;&lt;center&gt;&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="variable">$res</span>) <span class="keyword">die</span>(<span class="string">&quot;无法读取数据: &quot;</span> . mysqli_error(<span class="variable">$conn</span>));</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;&lt;h4&gt; 学生开除表(必修)&lt;br&gt;&lt;/h4&gt;&#x27;</span>;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;&lt;table border=&quot;1&quot;&gt;&lt;tr&gt;&lt;td&gt;学号&lt;/td&gt;&lt;td&gt;学生姓名&lt;/td&gt;&lt;td&gt;不及格学分&lt;/td&gt;&lt;/tr&gt;&#x27;</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="variable">$row</span> = mysqli_fetch_array(<span class="variable">$res</span>, MYSQLI_ASSOC))&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;&lt;tr&gt;&lt;td&gt;<span class="subst">&#123;$row[&#x27;sno&#x27;]&#125;</span>&lt;/td&gt;&lt;td&gt;<span class="subst">&#123;$row[&#x27;sname&#x27;]&#125;</span>&lt;/td&gt;&lt;td&gt;<span class="subst">&#123;$row[&#x27;sumcre&#x27;]&#125;</span>&lt;/td&gt;&lt;/tr&gt;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;&lt;/table&gt;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="variable">$sql</span>=</span><br><span class="line">    <span class="string">&quot;select temp.sno , stu.sname, sum(temp.ccre) sumcre</span></span><br><span class="line"><span class="string">    from temp, stu</span></span><br><span class="line"><span class="string">    where temp.iscompulsory=&#x27;0&#x27; AND temp.grade &lt; 60 AND temp.sno=stu.sno</span></span><br><span class="line"><span class="string">    group by temp.sno</span></span><br><span class="line"><span class="string">    having sum(temp.ccre) &gt; 12&quot;</span>;</span><br><span class="line">    <span class="variable">$res</span> = mysqli_query(<span class="variable">$conn</span>, <span class="variable">$sql</span>);</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;&lt;center&gt;&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="variable">$res</span>) <span class="keyword">die</span>(<span class="string">&quot;无法读取数据: &quot;</span> . mysqli_error(<span class="variable">$conn</span>));</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;&lt;h4&gt; 学生开除表(选修)&lt;br&gt;&lt;/h4&gt;&#x27;</span>;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;&lt;table border=&quot;1&quot;&gt;&lt;tr&gt;&lt;td&gt;学号&lt;/td&gt;&lt;td&gt;学生姓名&lt;/td&gt;&lt;td&gt;不及格学分&lt;/td&gt;&lt;/tr&gt;&#x27;</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="variable">$row</span> = mysqli_fetch_array(<span class="variable">$res</span>, MYSQLI_ASSOC))&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;&lt;tr&gt;&lt;td&gt;<span class="subst">&#123;$row[&#x27;sno&#x27;]&#125;</span>&lt;/td&gt;&lt;td&gt;<span class="subst">&#123;$row[&#x27;sname&#x27;]&#125;</span>&lt;/td&gt;&lt;td&gt;<span class="subst">&#123;$row[&#x27;sumcre&#x27;]&#125;</span>&lt;/td&gt;&lt;/tr&gt;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;&lt;/table&gt;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">die</span>(<span class="string">&quot;请求的操作码有误&quot;</span>);</span><br><span class="line"><span class="variable">$conn</span>-&gt;close();</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;center&gt;&lt;br&gt;&quot;</span> . <span class="string">&quot;完成&quot;</span>. <span class="string">&quot;&lt;br&gt;&lt;/center&gt;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前后端 </tag>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF-edu102</title>
      <link href="/2021/01/15/CF-edu102/"/>
      <url>/2021/01/15/CF-edu102/</url>
      
        <content type="html"><![CDATA[<p><strong><a href="https://codeforces.ml/contest/1473">Educational Codeforces Round 102 (Rated for Div. 2)</a></strong></p><span id="more"></span><p>[toc]</p><h2 id="B-水题"><a href="#B-水题" class="headerlink" title="B 水题"></a>B 水题</h2><p>简单的题目因为忘记设置a[n] = 0作为字符串<code>a[0, ..., n-1]</code>的结尾导致多组数据的情况下出现神秘的错误。</p><p><del>太久不训练导致状态非常差qaq</del></p><h2 id="D-水题"><a href="#D-水题" class="headerlink" title="D 水题"></a>D 水题</h2><p><del>为什么我要用线段树写？？？</del></p><p>实际上简单地维护区间+-操作所能得到的数值区间，扣去中间一段，利用其偏移量即可很快的知道左右两端的数值区间。</p><h2 id="C-逆序对-amp-思维题"><a href="#C-逆序对-amp-思维题" class="headerlink" title="C 逆序对 &amp; 思维题"></a>C 逆序对 &amp; 思维题</h2><p>最开始考虑序列的任意一个状态都可以通过交换相邻两个数值得到（即一路冒泡过去），而对于仅仅交换相邻两项这一操作而言，它仅仅影响这两项（以及其可能存在于另一边的对称）本身所贡献的逆序对，而除了这若干项以外，其余的所有值所贡献的逆序对均不变。</p><p>但是经过”一番推敲”，将1 2 … 2 1变成2 1 … 1 2会导致逆序对的数量增加1。结果就导致耽误了非常久的时间。<del>我在搞毛？</del></p><p>最终过D题后写C总算发现逆序对数量并不会变化qaq</p><h2 id="E-拆点最短路"><a href="#E-拆点最短路" class="headerlink" title="E 拆点最短路"></a>E 拆点最短路</h2><p>场上大概研究了一阵子就跑去看F了   <del>虽然搞完C也没剩多少时间了</del></p><p>但是图上拆点最短路的思想总是不能深入我心，之前的镜面反射便久久不得要领，阅读题解后却是恍然大悟。</p><p>在这道题中，考虑最终到某个点的一条最优路径，那么这条路上一定存在一个最长边和最短边，根据题目给出的路径距离公式，可以等价地认为这条最长边的边权为0，最短边的边权为其本身的两倍，而其余的边权不变。</p><p>因为最优的距离结果一定如上，所以当每个点都有进行松弛的机会后，最终保留在答案中的一定是最优路所带来的松弛结果。</p><p>那么将每个点拆成4个状态，分别表示是否取过最长边和最短边(2 * 2 = 4)，边所带来的松弛只会将状态点从<code>未取过某一状态</code> 转移到<code>取过某一状态</code>，那么在普通的dij算法中在NODE节点中添加一些新的状态信息，松弛时同时尝试向所有可行的方向松弛。最终只考虑每个节点对应状态<code>既取最长边又取最短边</code>的距离，输出即可。</p><p>有特殊情况需注意，当当前边又是最长边又是最短边时，应该认为该边权不变，且状态直接从0转移到3.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">8e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">star</span>&#123;</span><span class="keyword">int</span> to, next; ll w;&#125;;</span><br><span class="line"><span class="keyword">int</span> head[manx], top = <span class="number">0</span>;</span><br><span class="line">star edge[maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _add(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)&#123;</span><br><span class="line">    edge[top].to = v;</span><br><span class="line">    edge[top].next = head[u];</span><br><span class="line">    edge[top].w = w;</span><br><span class="line">    head[u] = top++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    _add(u, v, w);</span><br><span class="line">    _add(v, u, w);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll dis[maxn][<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NODE</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u, type; ll d;</span><br><span class="line">    <span class="built_in">NODE</span>(<span class="keyword">int</span> a, ll b, <span class="keyword">int</span> c)&#123;</span><br><span class="line">        u = a; </span><br><span class="line">        d = b;</span><br><span class="line">        type = c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> NODE &amp;b) <span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> d &gt; b.d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;NODE&gt; pq;</span><br><span class="line"></span><br><span class="line"><span class="comment">//尝试将d更新到u结点的type类型上。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> u, ll d, <span class="keyword">int</span> type)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(d &lt; dis[u][type])&#123;</span><br><span class="line">        dis[u][type] = d;</span><br><span class="line">        pq.<span class="built_in">push</span>(&#123;u, d, type&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dij</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">clr</span>(dis, <span class="number">0x3f</span>);</span><br><span class="line"></span><br><span class="line">    dis[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    pq.<span class="built_in">push</span>(&#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">    <span class="keyword">while</span>(!pq.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        NODE tmep = pq.<span class="built_in">top</span>(); pq.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> now = temp.u, type = tmep.type;</span><br><span class="line"></span><br><span class="line">        ll d = tmep.d;</span><br><span class="line">        <span class="keyword">if</span>(d &gt; dis[now][type]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = haed[now]; ~i; i = edge[i].next)&#123;</span><br><span class="line">            <span class="keyword">int</span> to = edge[i].to;</span><br><span class="line">            <span class="built_in">update</span>(to, d + edge[i].w, type);</span><br><span class="line">            <span class="keyword">if</span>(type == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">update</span>(to, d + <span class="number">2</span> * edge[i].w, <span class="number">2</span>);</span><br><span class="line">                <span class="built_in">update</span>(to, d + <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">                <span class="built_in">update</span>(to, d + edge[i].w, <span class="number">3</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(type == <span class="number">1</span>)</span><br><span class="line">                <span class="built_in">update</span>(to, d + <span class="number">2</span> * edge[i].w, <span class="number">3</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(type == <span class="number">2</span>)</span><br><span class="line">                <span class="built_in">update</span>(to, d + <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//    Fastin;  </span></span><br><span class="line">    <span class="built_in">clr</span>(head, <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> u, v, w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line">        <span class="built_in">add</span>(u, v, w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dij</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) <span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>, dis[i][<span class="number">3</span>]); <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="F-流-amp-建图技巧"><a href="#F-流-amp-建图技巧" class="headerlink" title="F 流 &amp; 建图技巧"></a>F 流 &amp; 建图技巧</h2><p><del>场上想了好一阵子，尝试想过是流算法，但是自己流算法非常的菜，根本没有想到怎么建图。</del></p><p>总体来说是利用最大流算法求解由依赖关系所带来的<strong>最小代价</strong>。</p><p>构造这样的图:</p><p>对于所有bi&gt;0的点，添加网络流边<code>&lt;s, i, bi&gt;</code>；对于bi&lt;=0的点，则添加网络流边<code>&lt;i, t, -bi&gt;</code>；其中s、t是源点和汇点</p><p>再添加这样的边：指定j，遍历所有的$x=1,2,…,a[j]$, 找出具有x值且距离j最近的$i(i &lt; j)$，添加边<code>&lt;j, i, inf&gt;</code></p><p>有了这张图，我们就可以得知如下的信息：</p><p>如果想要选取若干的正值，这些正值之间可能存在依赖关系，并且对于该依赖关系成为一个闭包（？）（<del>封闭且与其他正值不存在依赖关系？</del>），那么显然我们选取这些正值所愿意支付的<strong>最多代价</strong>就是这些值之和，即与源点相连的所有边的边权和（此时也意味着完全不取这些正值），更优的情况便是取这些正值带来的负贡献不及这些正值之和，此时要付出的代价就是那些与汇点之间相连的边的边权和。而将这一簇簇的正值闭包全部汇聚到同一个源点上，那么一次的最大流就可以得知选取所有正值所需要付出的最小代价。</p><p>最终的结果就是正bi之和减去图上的最大流。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> itn maxn = <span class="number">3e3</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxe = <span class="number">3e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> ll inf = <span class="number">1ll</span> &lt;&lt; <span class="number">60</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">star</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next; ll w;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> head[maxn], top = <span class="number">0</span>;</span><br><span class="line">star edge[maxe &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    edge[top].to = v;</span><br><span class="line">    edge[top].next = head[u];</span><br><span class="line">    edge[top].w = w;</span><br><span class="line">    head[u] = top++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> d[maxn], cur[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t, ll flow)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (flow == <span class="number">0</span> || s == t)</span><br><span class="line">        <span class="keyword">return</span> flow;</span><br><span class="line"></span><br><span class="line">    ll res = <span class="number">0</span>, f;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = cur[s]; ~i; i = edge[i].next) &#123;</span><br><span class="line">        cur[s] = i;</span><br><span class="line">        <span class="keyword">if</span> (d[edge[i].to] == d[s] + <span class="number">1</span>) &#123;</span><br><span class="line">            f = <span class="built_in">dfs</span>(edge[i].to, t, <span class="built_in">min</span>(flow, (ll)edge[i].w));</span><br><span class="line">            edge[i].w -= f;</span><br><span class="line">            edge[i ^ <span class="number">1</span>].w += f;</span><br><span class="line">            res += f;</span><br><span class="line">            flow -= f;</span><br><span class="line">            <span class="keyword">if</span> (flow == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">queue&lt;<span class="keyword">int</span>&gt; q, q0;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">clr</span>(d, <span class="number">0</span>);</span><br><span class="line">    q = q0;</span><br><span class="line">    q.<span class="built_in">push</span>(s);</span><br><span class="line">    cur[s] = head[s];</span><br><span class="line">    d[s] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">int</span> now = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[now]; ~i; i = edge[i].next)</span><br><span class="line">            <span class="keyword">if</span> (!d[edge[i].to] &amp;&amp; edge[i].w &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                cur[edge[i].to] = head[edge[i].to];</span><br><span class="line">                d[edge[i].to] = d[now] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (edge[i].to == t)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(edge[i].to);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">dinic</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">bfs</span>(s, t)) ans += <span class="built_in">dfs</span>(s, t, inf);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[maxn], b[maxn];</span><br><span class="line"><span class="keyword">int</span> pre[<span class="number">110</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//    Fastin;</span></span><br><span class="line">    <span class="built_in">clr</span>(head, <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">clr</span>(pre, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">scnaf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n); </span><br><span class="line">    <span class="built_in">fro</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, a + i);</span><br><span class="line">    <span class="built_in">fro</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, b + i);</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b[i] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            ans += b[i];</span><br><span class="line">            <span class="built_in">add</span>(n, i, b[i]);</span><br><span class="line">            <span class="built_in">add</span>(i, n, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">add</span>(i, n + <span class="number">1</span>, -b[i]);</span><br><span class="line">            <span class="built_in">add</span>(n + <span class="number">1</span>, i, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= a[i]; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pre[j] != <span class="number">-1</span> &amp;&amp; a[i] % j == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">add</span>(i, pre[j], <span class="number">0x3f3f3f3f</span>);</span><br><span class="line">                <span class="built_in">add</span>(pre[j], i, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        pre[a[i]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    ans -= <span class="built_in">dinic</span>(n, n + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 最短路 </tag>
            
            <tag> 逆序对 </tag>
            
            <tag> 拆点最短路 </tag>
            
            <tag> 网络流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信小程序</title>
      <link href="/2020/12/07/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
      <url>/2020/12/07/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p>记一次微信小程序的搭建过程。</p><p>前端wxml+wxss+js，后端apache2+php+mysql</p><p>尽管为了完成微信小程序的基本功能只需要略知上述内容的皮毛即可，但是从零开始仍然是过程坎坷，花费了许多夜晚才略有成效；故特此记录。</p><p>[toc]</p><span id="more"></span><h2 id="后端apache服务器的配置"><a href="#后端apache服务器的配置" class="headerlink" title="后端apache服务器的配置"></a>后端apache服务器的配置</h2><h3 id="apache2"><a href="#apache2" class="headerlink" title="apache2"></a>apache2</h3><p>最初不知道从哪里安装了一个不带有<code>mysqli</code>库的apache2，导致我顶着超长的延迟在服务器修了一年还是不知道怎么搞出来。</p><p>最后根据另外一篇博文执行了一个安装许多拓展的指令，成功安装上mysqli.</p><h3 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h3><p>安装mysql比较一帆风顺；注意修改之打算用于远程访问服务器的用户为最高权限，同时加上密码以防止恶意破坏（虽然应该并没有人会打算破坏我这个什么都没有的服务器）。</p><h3 id="php"><a href="#php" class="headerlink" title="php"></a>php</h3><p><del>确实是没有想到0202年了还要用php</del></p><p><del>不过这可能是因为我从来没有接触过后端服务器，才一度见识浅薄地以为php是上古时期才存在的服务器语言。</del></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$servername</span> = <span class="string">&quot;xxx:3306&quot;</span>;</span><br><span class="line"><span class="variable">$username</span> = <span class="string">&quot;root&quot;</span>;</span><br><span class="line"><span class="variable">$password</span> = <span class="string">&quot;xxx&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$age</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;age&#x27;</span>];</span><br><span class="line"><span class="comment">//$age = 15;</span></span><br><span class="line"><span class="variable">$id</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;id&#x27;</span>];</span><br><span class="line"><span class="comment">//$id = &quot;215100test&quot;;</span></span><br><span class="line"><span class="comment">// 创建连接</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$conn</span> = mysqli_connect(<span class="variable">$servername</span>, <span class="variable">$username</span>, <span class="variable">$password</span>);</span><br><span class="line"><span class="comment">// 检测连接</span></span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$conn</span>-&gt;connect_error) &#123;</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">&quot;连接失败&quot;</span>);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//向数据库中插入数据</span></span><br><span class="line"><span class="variable">$sql</span> = <span class="string">&quot;INSERT INTO main(age, id) VALUES (&quot;</span> .<span class="variable">$age</span> .<span class="string">&quot;,  &#x27;&quot;</span> .<span class="variable">$id</span>.<span class="string">&quot;&#x27;)&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(mysqli_query(<span class="variable">$conn</span>, <span class="string">&quot;use temp;&quot;</span>) == <span class="literal">TRUE</span>)</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;CHANGE SUCCED; &quot;</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">die</span>(<span class="string">&quot;changed failed&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (mysqli_query(<span class="variable">$conn</span>, <span class="variable">$sql</span>) === <span class="literal">TRUE</span>)</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;succeed&quot;</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">echo</span> <span class="string">&quot;Error creating database: &quot;</span>;</span><br><span class="line"><span class="variable">$conn</span>-&gt;close();</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>第一个成功的php程序。可以直接通过访问ip地址+子网页名称得到success的消息。</p><p>并且<strong>实践证明，L21的use指令是必要的，这是mysql对于insert所要求保证的。</strong></p><h3 id="实现wxapp中记账本数据的上传和下载"><a href="#实现wxapp中记账本数据的上传和下载" class="headerlink" title="实现wxapp中记账本数据的上传和下载"></a>实现wxapp中记账本数据的上传和下载</h3><p>在实践中，因为最终新建了一个<code>wxapp</code>的数据库用于实战，但root权限只在之前测试时修改为最高过，导致use指令一直不成功。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GRANT ALL PRIVILEGES ON *.* TO &#x27;root&#x27;@&#x27;192.168.1.100&#x27; IDENTIFIED BY &#x27;$密码&#x27; WITH GRANT OPTION;</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure><h2 id="前端wxapp的配置"><a href="#前端wxapp的配置" class="headerlink" title="前端wxapp的配置"></a>前端wxapp的配置</h2><h3 id="初步成功地实现wx-request指令"><a href="#初步成功地实现wx-request指令" class="headerlink" title="初步成功地实现wx.request指令"></a>初步成功地实现wx.request指令</h3><p><del>线形的markdown文本结构显然是很难表现出我在并行研究这两块的时间顺序的，但是也只能以此进行粗略的记录。</del></p><p>初步构建完第一个php查询程序后，最迫切想去实现的当然是<code>wx.request</code>指令。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">wx.request(&#123;</span><br><span class="line">      <span class="attr">url</span>: <span class="string">&#x27;http://xxx/wxapp.php&#x27;</span>,</span><br><span class="line">      <span class="attr">data</span>:&#123;</span><br><span class="line">        <span class="attr">age</span>: <span class="number">11415</span>,</span><br><span class="line">        <span class="attr">id</span>: <span class="string">&#x27;230302&#x27;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">success</span>: <span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;OK&quot;</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(res.data)</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">fail</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>最开始一直被各种奇怪的错误卡死，说我查询失败。</p><p>经过检查后发现，首先要把php中的use指令加上，能够完成上述通过web浏览器访问。然后又抱错说我的url是无效的，翻阅了网友的博客才发现不能直接将ip地址写入url，而要加上<code>http://</code>，实在是非常的神奇。因为没有好好学习计算机网络，并且只检验了<code>https://$ip地址/wxwapp.php</code>是无法访问的，没有考虑到<a href="http://是默认的网络协议，导致卡了非常多的时间。">http://是默认的网络协议，导致卡了非常多的时间。</a></p><h3 id="wx-navigateTo"><a href="#wx-navigateTo" class="headerlink" title="wx.navigateTo"></a>wx.navigateTo</h3><p>该指令可以从一个页面跳转到另一个界面，值得注意的是，其中的url不能填写tabBar，并且url<strong>不需要加任何后缀</strong>!</p><h3 id="js中自定义sort的比较方法"><a href="#js中自定义sort的比较方法" class="headerlink" title="js中自定义sort的比较方法"></a>js中自定义sort的比较方法</h3><blockquote><p>若 a 小于 b，在排序后的数组中 a 应该出现在 b 之前，则返回一个小于 0 的值。<br>若 a 等于 b，则返回 0。<br>若 a 大于 b，则返回一个大于 0 的值。<br><strong>注意：b的值是数组遍历到的当前值，a是数组遍历到的下一个值（即b的下一个）</strong></p></blockquote><p>???所以说为什么会有这种神秘的方法</p><p>难怪我直接return一个不等式回去总是出错</p><p>js中需要return3种值，所以要用减号</p><p><del>orz</del></p><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="mysqli部分语法"><a href="#mysqli部分语法" class="headerlink" title="mysqli部分语法"></a>mysqli部分语法</h3><p>创建数据库：<code>create database $name;</code></p><p>选择数据库：<code>use $name;</code></p><p>查询数据库中有哪些数据表：<code>show tables;</code></p><p>展示一个数据表：<code>desc $TableName;</code></p><p>修改数据表中的列:<code>alter table $tableName change $原名称 $新名称 $数据类型</code></p><p>删除表中行信息：<code>delete from $tableName [where...]</code></p><p>撤销主键: <code>ALTER TABLE $tableName DROP PRIMARY KEY</code></p><h3 id="cashflow-php"><a href="#cashflow-php" class="headerlink" title="cashflow.php"></a>cashflow.php</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$conn</span> = mysqli_connect(<span class="string">&quot;xxx&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;xxx&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!<span class="variable">$conn</span>)</span><br><span class="line"><span class="keyword">die</span>(<span class="string">&quot;链接失败！&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!mysqli_query(<span class="variable">$conn</span>, <span class="string">&quot;use wxapp&quot;</span>)) <span class="keyword">die</span>(<span class="string">&quot;数据库选择失败！&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable">$op</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;op&#x27;</span>];</span><br><span class="line"><span class="variable">$title</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;title&#x27;</span>];</span><br><span class="line"><span class="variable">$id</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;id&#x27;</span>];</span><br><span class="line"><span class="variable">$subtitle</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;subtitle&#x27;</span>];</span><br><span class="line"><span class="variable">$cost</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;cost&#x27;</span>];</span><br><span class="line"><span class="variable">$date</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;date&#x27;</span>];</span><br><span class="line"><span class="variable">$time</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;time&#x27;</span>];</span><br><span class="line"><span class="variable">$typeindex</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;typeindex&#x27;</span>];</span><br><span class="line"><span class="variable">$hasLocation</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;hasLocation&#x27;</span>];</span><br><span class="line"><span class="variable">$errMsy</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;errMsy&#x27;</span>];</span><br><span class="line"><span class="variable">$locationName</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;locationName&#x27;</span>];</span><br><span class="line"><span class="variable">$locationAddress</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;locationAddress&#x27;</span>];</span><br><span class="line"><span class="variable">$latitude</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;latitude&#x27;</span>];</span><br><span class="line"><span class="variable">$longitude</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;longitude&#x27;</span>];</span><br><span class="line"><span class="variable">$submitTime</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;submitTime&#x27;</span>];</span><br><span class="line"><span class="variable">$old_submitTime</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;old_submitTime&#x27;</span>];</span><br><span class="line"><span class="variable">$openId</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;openId&#x27;</span>];</span><br><span class="line"><span class="variable">$flag</span>= <span class="variable">$_GET</span>[<span class="string">&#x27;flag&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">INFO</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$title</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$id</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$subtitle</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$cost</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$date</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$time</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$typeindex</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$hasLocation</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$errMsy</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$locationName</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$locationAddress</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$latitude</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$longitude</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$submitTime</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$flag</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$json</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="variable">$data</span> = <span class="keyword">array</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$op</span> == <span class="string">&#x27;INSERT&#x27;</span>)&#123;</span><br><span class="line">    <span class="variable">$sql</span> = <span class="string">&quot;insert into cashflow (title, id, subtitle, cost, date, time, typeindex, hasLocation, errMsy, locationName, locationAddress, latitude, longitude, submitTime, openId, flag) values(</span></span><br><span class="line"><span class="string">        &#x27;&quot;</span> .<span class="variable">$title</span>. <span class="string">&quot;&#x27;,</span></span><br><span class="line"><span class="string">    &#x27;&quot;</span> .<span class="variable">$id</span>. <span class="string">&quot;&#x27;,</span></span><br><span class="line"><span class="string">    &#x27;&quot;</span> .<span class="variable">$subtitle</span>. <span class="string">&quot;&#x27;,</span></span><br><span class="line"><span class="string">    &#x27;&quot;</span> .<span class="variable">$cost</span>. <span class="string">&quot;&#x27;,</span></span><br><span class="line"><span class="string">    &#x27;&quot;</span> .<span class="variable">$date</span>. <span class="string">&quot;&#x27;,</span></span><br><span class="line"><span class="string">    &#x27;&quot;</span> .<span class="variable">$time</span>. <span class="string">&quot;&#x27;,</span></span><br><span class="line"><span class="string">    &#x27;&quot;</span> .<span class="variable">$typeindex</span>. <span class="string">&quot;&#x27;,</span></span><br><span class="line"><span class="string">    &#x27;&quot;</span> .<span class="variable">$hasLocation</span>. <span class="string">&quot;&#x27;,</span></span><br><span class="line"><span class="string">    &#x27;&quot;</span> .<span class="variable">$errMsy</span>. <span class="string">&quot;&#x27;,</span></span><br><span class="line"><span class="string">    &#x27;&quot;</span> .<span class="variable">$locationName</span>. <span class="string">&quot;&#x27;,</span></span><br><span class="line"><span class="string">    &#x27;&quot;</span> .<span class="variable">$locationAddress</span>. <span class="string">&quot;&#x27;,</span></span><br><span class="line"><span class="string">    &#x27;&quot;</span> .<span class="variable">$latitude</span>. <span class="string">&quot;&#x27;,</span></span><br><span class="line"><span class="string">    &#x27;&quot;</span> .<span class="variable">$longitude</span>. <span class="string">&quot;&#x27;,</span></span><br><span class="line"><span class="string">    &#x27;&quot;</span> .<span class="variable">$submitTime</span>. <span class="string">&quot;&#x27;,</span></span><br><span class="line"><span class="string">    &#x27;&quot;</span> .<span class="variable">$openId</span>. <span class="string">&quot;&#x27;,</span></span><br><span class="line"><span class="string">    &#x27;&quot;</span> .<span class="variable">$flag</span>. <span class="string">&quot;&#x27;</span></span><br><span class="line"><span class="string">    )&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(!mysqli_query(<span class="variable">$conn</span>, <span class="variable">$sql</span>))&#123;</span><br><span class="line">        <span class="keyword">die</span>(<span class="string">&quot;Insert failed!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">echo</span> <span class="string">&quot;Insert OK!&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(<span class="variable">$op</span> == <span class="string">&#x27;UPDATE&#x27;</span>)&#123;</span><br><span class="line">    <span class="variable">$sql</span> = <span class="string">&quot;update cashflow set</span></span><br><span class="line"><span class="string">    subtitle=&#x27;&quot;</span> .<span class="variable">$subtitle</span>. <span class="string">&quot;&#x27;, </span></span><br><span class="line"><span class="string">    cost=&#x27;&quot;</span> .<span class="variable">$cost</span>. <span class="string">&quot;&#x27;, </span></span><br><span class="line"><span class="string">    date=&#x27;&quot;</span> .<span class="variable">$date</span>. <span class="string">&quot;&#x27;, </span></span><br><span class="line"><span class="string">    time=&#x27;&quot;</span> .<span class="variable">$time</span>. <span class="string">&quot;&#x27;, </span></span><br><span class="line"><span class="string">    typeindex=&#x27;&quot;</span> .<span class="variable">$typeindex</span>. <span class="string">&quot;&#x27;, </span></span><br><span class="line"><span class="string">    hasLocation=&#x27;&quot;</span> .<span class="variable">$hasLocation</span>. <span class="string">&quot;&#x27;, </span></span><br><span class="line"><span class="string">    errMsy=&#x27;&quot;</span> .<span class="variable">$errMsy</span>. <span class="string">&quot;&#x27;, </span></span><br><span class="line"><span class="string">    locationName=&#x27;&quot;</span> .<span class="variable">$locationName</span>. <span class="string">&quot;&#x27;, </span></span><br><span class="line"><span class="string">    locationAddress=&#x27;&quot;</span> .<span class="variable">$locationAddress</span>. <span class="string">&quot;&#x27;,</span></span><br><span class="line"><span class="string">    latitude=&#x27;&quot;</span> .<span class="variable">$latitude</span>. <span class="string">&quot;&#x27;, </span></span><br><span class="line"><span class="string">    longitude=&#x27;&quot;</span> .<span class="variable">$longitude</span>. <span class="string">&quot;&#x27;, </span></span><br><span class="line"><span class="string">    submitTime=&#x27;&quot;</span> .<span class="variable">$submitTime</span>. <span class="string">&quot;&#x27;</span></span><br><span class="line"><span class="string">    where openId=&#x27;&quot;</span> .<span class="variable">$openId</span>. <span class="string">&quot;&#x27; &amp;&amp; title=&#x27;&quot;</span> .<span class="variable">$title</span>. <span class="string">&quot;&#x27; &amp;&amp; id=&#x27;&quot;</span> .<span class="variable">$id</span>. <span class="string">&quot;&#x27; &amp;&amp; submitTime=&#x27;&quot;</span> .<span class="variable">$old_submitTime</span>. <span class="string">&quot;&#x27;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(mysqli_query(<span class="variable">$conn</span>, <span class="variable">$sql</span>) != <span class="literal">true</span>) <span class="keyword">die</span>(<span class="string">&quot;Update failed!&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">echo</span> <span class="string">&quot;Update OK!&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(<span class="variable">$op</span> == <span class="string">&#x27;DELETE&#x27;</span>)&#123;</span><br><span class="line">    <span class="variable">$sql</span> = <span class="string">&quot;delete from cashflow</span></span><br><span class="line"><span class="string">    where submitTime=&#x27;&quot;</span> .<span class="variable">$submitTime</span>. <span class="string">&quot;&#x27;&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(mysqli_query(<span class="variable">$conn</span>, <span class="variable">$sql</span>) != <span class="literal">true</span>) <span class="keyword">die</span>(<span class="string">&quot;Delte failed!&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">echo</span> <span class="string">&quot;Delete OK!&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(<span class="variable">$op</span> == <span class="string">&#x27;DELETEBOOK&#x27;</span>)&#123;</span><br><span class="line">    <span class="variable">$sql</span> = <span class="string">&quot;delete from cashflow</span></span><br><span class="line"><span class="string">    where id=&#x27;&quot;</span> .<span class="variable">$id</span>. <span class="string">&quot;&#x27;&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(mysqli_query(<span class="variable">$conn</span>, <span class="variable">$sql</span>) != <span class="literal">true</span>) <span class="keyword">die</span>(<span class="string">&quot;DelteBook failed!&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">echo</span> <span class="string">&quot;DeleteBook OK!&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(<span class="variable">$op</span> == <span class="string">&#x27;QUERY&#x27;</span>)&#123;</span><br><span class="line">    <span class="variable">$res</span> = mysqli_query(<span class="variable">$conn</span>, <span class="string">&quot;select * from cashflow where openId=&#x27;&quot;</span> .<span class="variable">$openId</span>. <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">    <span class="comment">// $res = mysqli_query($conn, &quot;select * from cashflow&quot;);</span></span><br><span class="line">    <span class="keyword">if</span>(!<span class="variable">$res</span>) <span class="keyword">die</span>(<span class="string">&quot;Query failed!&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="variable">$row</span> = mysqli_fetch_array(<span class="variable">$res</span>))&#123;</span><br><span class="line">            <span class="variable">$info</span> = <span class="keyword">new</span> INFO();</span><br><span class="line">            <span class="variable">$info</span>-&gt;title = <span class="variable">$row</span>[<span class="string">&quot;title&quot;</span>];</span><br><span class="line">            <span class="variable">$info</span>-&gt;id = <span class="variable">$row</span>[<span class="string">&quot;id&quot;</span>];</span><br><span class="line">            <span class="variable">$info</span>-&gt;subtitle = <span class="variable">$row</span>[<span class="string">&quot;subtitle&quot;</span>];</span><br><span class="line">            <span class="variable">$info</span>-&gt;cost = <span class="variable">$row</span>[<span class="string">&quot;cost&quot;</span>];</span><br><span class="line">            <span class="variable">$info</span>-&gt;date = <span class="variable">$row</span>[<span class="string">&quot;date&quot;</span>];</span><br><span class="line">            <span class="variable">$info</span>-&gt;time = <span class="variable">$row</span>[<span class="string">&quot;time&quot;</span>];</span><br><span class="line">            <span class="variable">$info</span>-&gt;typeindex = <span class="variable">$row</span>[<span class="string">&quot;typeindex&quot;</span>];</span><br><span class="line">            <span class="variable">$info</span>-&gt;hasLocation = <span class="variable">$row</span>[<span class="string">&quot;hasLocation&quot;</span>];</span><br><span class="line">            <span class="variable">$info</span>-&gt;errMsy = <span class="variable">$row</span>[<span class="string">&quot;errMsy&quot;</span>];</span><br><span class="line">            <span class="variable">$info</span>-&gt;locationName = <span class="variable">$row</span>[<span class="string">&quot;locationName&quot;</span>];</span><br><span class="line">            <span class="variable">$info</span>-&gt;locationAddress = <span class="variable">$row</span>[<span class="string">&quot;locationAddress&quot;</span>];</span><br><span class="line">            <span class="variable">$info</span>-&gt;latitude = <span class="variable">$row</span>[<span class="string">&quot;latitude&quot;</span>];</span><br><span class="line">            <span class="variable">$info</span>-&gt;longitude = <span class="variable">$row</span>[<span class="string">&quot;longitude&quot;</span>];</span><br><span class="line">            <span class="variable">$info</span>-&gt;submitTime = <span class="variable">$row</span>[<span class="string">&quot;submitTime&quot;</span>];</span><br><span class="line">            <span class="variable">$info</span>-&gt;flag = <span class="variable">$row</span>[<span class="string">&quot;flag&quot;</span>];</span><br><span class="line">            <span class="variable">$data</span>[] = <span class="variable">$info</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable">$json</span> = json_encode(<span class="variable">$data</span>);</span><br><span class="line">        <span class="comment">// echo &quot;&#123;&quot;.&#x27;&quot;data&quot;&#x27;.&quot;:&quot;.$json.&quot;&#125;&quot;;</span></span><br><span class="line">        <span class="keyword">echo</span> <span class="variable">$json</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(<span class="variable">$op</span> == <span class="string">&#x27;RENAME&#x27;</span>)&#123;</span><br><span class="line">    <span class="variable">$sql</span> = <span class="string">&quot;update cashflow set</span></span><br><span class="line"><span class="string">    title = &#x27;&quot;</span> .<span class="variable">$title</span>. <span class="string">&quot;&#x27;</span></span><br><span class="line"><span class="string">    where openId = &#x27;&quot;</span> .<span class="variable">$openId</span>. <span class="string">&quot;&#x27; &amp;&amp; id = &#x27;&quot;</span> .<span class="variable">$id</span>. <span class="string">&quot;&#x27;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!mysqli_query(<span class="variable">$conn</span>, <span class="variable">$sql</span>)) <span class="keyword">die</span>(<span class="string">&quot;Rename failed!&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">echo</span> <span class="string">&quot;Rename OK!&quot;</span>;</span><br><span class="line">    <span class="comment">// echo $sql; die;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(<span class="variable">$op</span> == <span class="string">&#x27;INSERTCOL&#x27;</span>)&#123;</span><br><span class="line">    <span class="variable">$sql</span> = <span class="string">&quot;insert into cashflow (title, id, flag, submitTime, openId) values(</span></span><br><span class="line"><span class="string">        &#x27;&quot;</span> .<span class="variable">$title</span>. <span class="string">&quot;&#x27;,</span></span><br><span class="line"><span class="string">        &#x27;&quot;</span> .<span class="variable">$id</span>. <span class="string">&quot;&#x27;,</span></span><br><span class="line"><span class="string">        &#x27;&quot;</span> .<span class="variable">$flag</span>. <span class="string">&quot;&#x27;,</span></span><br><span class="line"><span class="string">        &#x27;&quot;</span> .<span class="variable">$submitTime</span>. <span class="string">&quot;&#x27;,</span></span><br><span class="line"><span class="string">        &#x27;&quot;</span> .<span class="variable">$openId</span>. <span class="string">&quot;&#x27;</span></span><br><span class="line"><span class="string">        )&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(!mysqli_query(<span class="variable">$conn</span>, <span class="variable">$sql</span>))&#123;</span><br><span class="line">        <span class="keyword">die</span>(<span class="string">&quot;InsertCol failed!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">echo</span> <span class="string">&quot;InsertCol OK!&quot;</span>;</span><br><span class="line">    <span class="comment">// echo $sql; die;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">die</span>(<span class="string">&quot;Invalid Input!&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="variable">$conn</span>-&gt;close();</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 微信小程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前后端 </tag>
            
            <tag> PHP </tag>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020-ccpc-weihai</title>
      <link href="/2020/11/21/2020-ccpc-weihai/"/>
      <url>/2020/11/21/2020-ccpc-weihai/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><span id="more"></span><h2 id="G-线段树-区间修改、取模，区间哈希和查询"><a href="#G-线段树-区间修改、取模，区间哈希和查询" class="headerlink" title="G 线段树 区间修改、取模，区间哈希和查询"></a>G 线段树 区间修改、取模，区间哈希和查询</h2><p>需要维护一个支持区间加1并对固定模数取模、区间哈希查询的线段树</p><p>开局就想写的一道题，写到最后艰难调出来后wa7，最终放弃上机辅助队友看别的题</p><p>晚上回去又调了很久，发现了几个错误</p><ul><li>线段树哈希写错了，在求哈希和的时候不像普通的线段树区间和一样，查询哈希和时查询的区间[L, R]是需要<strong>动态变化</strong>的，必须保证<code>L</code>被不断地截断，才能保证算法的正确性</li><li>眼睛比较瞎，前缀和pre[]对M(65536)取模了</li><li>最开始的purify(将那些超过65536的位置取模)写挫了，在<strong>终止条件(l == r)之前就调用了down函数</strong>。调了一年才发现原来是这里有问题：如果在终止条件之前就调用down函数，这会导致地址的越界访问。因为st只开了4倍空间，所以如果在那种边角叶子结点（在满二叉树上多一个节外生枝的结构）仍然尝试down下去，就会访问到8倍的位置！在CF居然没有发生RE报警，以至于我一度怀疑是自己算法写错了，其实是空间的计算错误导致了UKE。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls (p &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs ((p &lt;&lt; 1) | 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mid ((l + r) &gt;&gt; 1)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">5e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">65536</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> pp = <span class="number">999983</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1000237529</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line">ll tag1[maxn &lt;&lt; <span class="number">2</span>], st2[maxn &lt;&lt; <span class="number">2</span>], st[maxn &lt;&lt; <span class="number">2</span>];</span><br><span class="line">ll po[maxn], pre[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    st[p] = st[ls] + st[rs] * po[mid - l + <span class="number">1</span>] % mod; st[p] %= mod;</span><br><span class="line">    st2[p] = <span class="built_in">max</span>(st2[ls], st2[rs]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r &amp;&amp; l == k)&#123;</span><br><span class="line">        st[p] = st2[p] = x;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(k &lt;= mid) <span class="built_in">build</span>(ls, l, mid, k, x);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">build</span>(rs, mid + <span class="number">1</span>, r, k, x);</span><br><span class="line">    <span class="built_in">up</span>(p, l, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tag1[p])&#123;</span><br><span class="line">        tag1[ls] += tag1[p];</span><br><span class="line">        tag1[rs] += tag1[p];</span><br><span class="line">        </span><br><span class="line">        st[ls] += pre[mid - l] * tag1[p] % mod; st[ls] %= mod;</span><br><span class="line">        st[rs] += pre[r - mid - <span class="number">1</span>] * tag1[p] % mod; st[rs] %= mod;</span><br><span class="line">        </span><br><span class="line">        st2[ls] += tag1[p];</span><br><span class="line">        st2[rs] += tag1[p];</span><br><span class="line">        </span><br><span class="line">        tag1[p] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R)&#123;</span><br><span class="line">        st[p] += pre[r - l]; st[p] %= mod;</span><br><span class="line">        st2[p]++; tag1[p]++;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">down</span>(p, l, r);</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= mid) <span class="built_in">udpate</span>(ls, l, mid, L, R);</span><br><span class="line">    <span class="keyword">if</span>(R &gt; mid) <span class="built_in">update</span>(rs, mid + <span class="number">1</span>, r, L ,R);</span><br><span class="line">    <span class="built_in">up</span>(p, l, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">purify</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(st2[p] &lt; M) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">down</span>(p, l, r);</span><br><span class="line">    <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">        st[p] %= M; st2[p] %= M;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(st2[ls] &gt;= M) <span class="built_in">purify</span>(ls, l, mid);</span><br><span class="line">    <span class="keyword">if</span>(st2[rs] &gt;= M) <span class="built_in">purify</span>(rs, mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="built_in">up</span>(p, l, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">hsh</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R) <span class="keyword">return</span> st[p];</span><br><span class="line">    <span class="built_in">down</span>(p, l, r);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(R &lt;= mid) <span class="keyword">return</span> <span class="built_in">hsh</span>(ls, l, mid, L, R);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(L &gt; mid) <span class="keyword">return</span> <span class="built_in">hsh</span>(rs, mid + <span class="number">1</span>, r, L, R);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        ll ans = <span class="built_in">hsh</span>(ls, l, mid, L, mid);</span><br><span class="line">        ans += <span class="built_in">hsh</span>(rs, mid + <span class="number">1</span>, r, mid + <span class="number">1</span>, R) * po[mid - L + <span class="number">1</span>] % mod;</span><br><span class="line">        ans %= mod;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//   Fastin;</span></span><br><span class="line">    po[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; maxn; i++) po[i] = po[i - <span class="number">1</span>] * <span class="number">1ll</span> * pp % mod;</span><br><span class="line">    pre[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; maxn; i++) pre[i] = pre[i - <span class="number">1</span>] + po[i], pre[i] %= mod;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> n, m; <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, a + i);</span><br><span class="line">        <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n, i, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="keyword">int</span> op; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;op);</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> l, r; <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;l, &amp;r);</span><br><span class="line">            <span class="built_in">update</span>(<span class="number">1</span>, <span class="number">1</span>, n, l, r);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> l, r, k; <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;l, &amp;r, &amp;k);</span><br><span class="line">            <span class="built_in">purify</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">            </span><br><span class="line">            ll res1 = <span class="built_in">hsh</span>(<span class="number">1</span>, <span class="number">1</span>, n, l, l + k - <span class="number">1</span>);</span><br><span class="line">            ll res2 = <span class="built_in">hsh</span>(<span class="number">1</span>, <span class="number">1</span>, n, r, r + k - <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">puts</span>(res1 == res2? <span class="string">&quot;yes&quot;</span>: <span class="string">&quot;no&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="L-分组背包-amp-LCM"><a href="#L-分组背包-amp-LCM" class="headerlink" title="L 分组背包 &amp; LCM"></a>L 分组背包 &amp; LCM</h2><p>给出n，构造某种拆分$p_1+p_2+…+p_k = n$，使得$lcm(p_1, p_2, …, p_k)$最大。</p><p>可以证明，当${p_i}$两两互素时，其lcm一定最大：</p><p>对于任意一组拆分，如果存在$gcd(a, b) = d&gt;=2$，那么可以通过提取出d得到一个新的拆分方法，使得lcm不变，但是元素和变小。</p><p>另外，如果存在某个元素是若干素因子的乘积，也可以通过拆分该元素成若干的小数字，使得lcm不变、元素和变小。</p><p>通过上述两种更新得到后的新序列的情况一定不劣于原序列，那么不断进行这样的操作，最终一定会得到两两互素的序列。（这一点是显然的，因为上述两种操作均是单向的，且不可能构成环）</p><p>这样即可说明，两两互素的情况一定不会劣于任意的其他拆分方法。</p><p>那么分组背包，对素数进行分组，随便泡一下就过了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">3e4</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> prime[maxn], top = <span class="number">0</span>, vis[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">euler</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">30000</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[i]) prime[top++] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; top &amp;&amp; prime[j] * i &lt;= <span class="number">30000</span>; j++)&#123;</span><br><span class="line">            vis[prime[j] * i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i % prime[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">double</span> dp[maxn], w[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// Fastin;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">euler</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">30000</span>; i++) w[i] = <span class="built_in">log</span>(i);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历所有的组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; top; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> n = <span class="number">30000</span>; n &gt;= <span class="number">1</span>; n--)&#123;</span><br><span class="line">            ll p = prime[i];</span><br><span class="line">            <span class="comment">//用给定组中的所有物品来尝试更新当前重量。</span></span><br><span class="line">            <span class="keyword">while</span>(p &lt;= n)&#123;</span><br><span class="line">                dp[n] = <span class="built_in">max</span>(dp[n], dp[n - p] + w[p]);</span><br><span class="line">                p *= prime[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TTT&#123;</span><br><span class="line">        <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n); <span class="built_in">printf</span>(<span class="string">&quot;%.9f\n&quot;</span>, dp[n]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线段树 </tag>
            
            <tag> 分组背包 </tag>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>opencup-gym102391</title>
      <link href="/2020/11/11/opencup-gym102391/"/>
      <url>/2020/11/11/opencup-gym102391/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><span id="more"></span><h2 id="J-RQD-IGVA树-树上DSU"><a href="#J-RQD-IGVA树-树上DSU" class="headerlink" title="J RQD-IGVA树 树上DSU"></a>J <del>RQD-IGVA树</del> 树上DSU</h2><p>最开始以为险段长度跟n无关，所以加了根[1, n]的线段进去就WA到死，后来改成[1, 1000000]即可。</p><p>大概是叫dsu on tree，可以处理一些与子树有关的询问，复杂度Onlogn</p><p><del>可惜IGVA不知道场上什么地方写挫了 场后10分钟A了</del></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">3e5</span> + <span class="number">10</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> n, w[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">star</span>&#123;</span><span class="keyword">int</span> to, next;&#125;;</span><br><span class="line"><span class="keyword">int</span> head[maxn], top = <span class="number">0</span>;</span><br><span class="line">star edge[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    edge[top].to = v;</span><br><span class="line">    edge[top].next = head[u];</span><br><span class="line">    head[u] = top++;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NODE</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, w;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> NODE &amp;b) <span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l != b.l) <span class="keyword">return</span> l &lt; b.l;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> r &gt; b.r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;NODE&gt; vec;</span><br><span class="line">priority_queue&lt;ll&gt; pq[maxn];</span><br><span class="line"><span class="keyword">int</span> conv[maxn];</span><br><span class="line">vector&lt;ll&gt; temp;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//合并边i和边j的优先队列，放到i里面</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> i , <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    temp.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">if</span>(pq[conv[i]].<span class="built_in">size</span>() &lt; pq[conv[j]].<span class="built_in">size</span>()) <span class="built_in">swap</span>(conv[i], conv[j]);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span>(!pq[conv[j]].<span class="built_in">empty</span>())&#123;</span><br><span class="line">        temp.<span class="built_in">push_back</span>(pq[conv[i]].<span class="built_in">top</span>() + pq[conv[j]].<span class="built_in">top</span>());</span><br><span class="line">        pq[conv[i]].<span class="built_in">pop</span>(); pq[conv[j]].<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x: temp) pq[conv[i]].<span class="built_in">push</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sove</span><span class="params">(<span class="keyword">int</span> now)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[now]; ~i; i = edge[i].next)&#123;</span><br><span class="line">        <span class="built_in">sove</span>(edge[i].to);</span><br><span class="line">        <span class="built_in">merge</span>(now, edge[i].to);</span><br><span class="line">    &#125;</span><br><span class="line">    pq[conv[now]].<span class="built_in">push</span>(vec[now].w);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">stack&lt;<span class="keyword">int</span>&gt; sta;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// Fastin;</span></span><br><span class="line">    <span class="built_in">clr</span>(head, <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> u, v, w; <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line">        vec.<span class="built_in">push_back</span>(&#123;u, v, w&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    vec.<span class="built_in">push_back</span>(&#123;<span class="number">1</span>, <span class="number">1000000</span>, <span class="number">0</span>&#125;);</span><br><span class="line">    <span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>());</span><br><span class="line"> </span><br><span class="line">    sta.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> top = sta.<span class="built_in">top</span>();</span><br><span class="line">        <span class="keyword">while</span>(!(vec[top].l &lt;= vec[i].l &amp;&amp; vec[i].r &lt;= vec[top].r))&#123;</span><br><span class="line">            sta.<span class="built_in">pop</span>(); </span><br><span class="line">            <span class="keyword">if</span>(sta.<span class="built_in">empty</span>())&#123;<span class="keyword">while</span>(<span class="number">1</span>);&#125;;</span><br><span class="line">            top = sta.<span class="built_in">top</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">add</span>(top, i); sta.<span class="built_in">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span>(itn i = <span class="number">0</span>; i &lt;= n; i++) conv[i] = i;</span><br><span class="line">    <span class="built_in">sove</span>(<span class="number">0</span>);</span><br><span class="line">  </span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!pq[conv[<span class="number">0</span>]].<span class="built_in">empty</span>())&#123;</span><br><span class="line">            ans += pq[conv[<span class="number">0</span>]].<span class="built_in">top</span>(); pq[conv[<span class="number">0</span>]].<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="I-最小直径生成树-MDST"><a href="#I-最小直径生成树-MDST" class="headerlink" title="I 最小直径生成树 MDST"></a>I 最小直径生成树 MDST</h2><p>为了求解MDST，就需要求解绝对中心所在的位置。绝对中心不一定在节点上，可以在边上。</p><p>当选定某条边<u, v>后，min(某点到u的距离，某点到v的距离)是一个单峰函数<code>^</code>，把所有的点的山峰函数放到一张图中，那么应该从最顶端的折线中找一个最低点。因为会出现山峰完全被另一个山峰嵌套的情况，所以将所有点按照到u的距离排升序，有意义的折点一定是被那些到v距离呈降序的点。以此就可不断遍历上述折线，找到绝对中心所在的边。</p><p>找到生成树的绝对中心后，即可dijstra或其他什么办法找到最短路径生成树。通过数学计算，可以知道中心在距离u点$ans - 2 * dis[i][rk[i][now]]$的位置，很快的可以知道距离v点的距离。那么以绝对中心为起点跑dijstra，就等价于将u点和v点更新为中心到其的距离，其余设置为inf。为了避免除以2的浮点数出现，将所有的权值扩大为2倍即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">5e2</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> ll inf = <span class="number">1ll</span> &lt;&lt; <span class="number">60</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line">ll a[maxn][manx], dis[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> rk[maxn][maxn];</span><br><span class="line"></span><br><span class="line">ll ans; <span class="keyword">int</span> ansi, ansj;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NODE</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to; ll d;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> NODE &amp;b) <span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> d &gt; b.d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;NODE&gt; pq;</span><br><span class="line">ll D[maxn], dx; <span class="keyword">int</span> par[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getpath</span><span class="params">()</span></span>&#123;</span><br><span class="line">    D[ansi] = dx;  pq.<span class="built_in">push</span>(&#123;ansi, D[ansi]&#125;); </span><br><span class="line">    <span class="keyword">if</span>(ansi != ansj)&#123; </span><br><span class="line">        D[ansj] = <span class="number">2</span> * a[ansi][ansj] - dx; pq.<span class="built_in">push</span>(&#123;ansj, D[ansj]&#125;); par[ansj] = ansi;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!pq.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        NODE temp = pq.<span class="built_in">top</span>(); pq.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">int</span> to = temp.to; ll d = temp.d;</span><br><span class="line">        <span class="keyword">if</span>(d &gt; D[to]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">if</span>(D[i] &gt; d + <span class="number">2</span> * a[to][i])&#123;</span><br><span class="line">            D[i] = d + <span class="number">2</span> * a[to][i];</span><br><span class="line">            par[i] = to;</span><br><span class="line">            pq.<span class="built_in">push</span>(&#123;i, D[i]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// Fastin;</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) a[i][j] = dis[i][j] = inf;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) dis[i][i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> u, v, w; <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line">        a[u][v] = a[v][u] = w;</span><br><span class="line">        dis[u][v] = dis[v][u] = <span class="built_in">min</span>(dis[u][v], <span class="number">1ll</span> * w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k++) <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) <span class="keyword">if</span>(i != j)</span><br><span class="line">        dis[i][j] = <span class="built_in">min</span>(dis[i][j], dis[i][k] + dis[k][j]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) rk[i][j] = j;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">sort</span>(rk[i] + <span class="number">1</span>, rk[i] + <span class="number">1</span> + n, [i](<span class="keyword">int</span> a, <span class="keyword">int</span> b)-&gt;<span class="keyword">bool</span>&#123;<span class="keyword">return</span> dis[i][a] &lt; dis[i][b];&#125;);</span><br><span class="line">    ans = inf;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) <span class="keyword">if</span>(i != j &amp;&amp; a[i][j] != inf)&#123;</span><br><span class="line">        <span class="built_in">update</span>(dis[i][rk[i][n]] * <span class="number">2</span>, i, i);</span><br><span class="line">        <span class="built_in">update</span>(dis[j][rk[j][n]] * <span class="number">2</span>, j, j);</span><br><span class="line">        <span class="keyword">int</span> pre = n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> now = n - <span class="number">1</span>; now &gt;= <span class="number">1</span>; now--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dis[j][rk[i][now]] &gt; dis[j][rk[i][pre]])&#123;</span><br><span class="line">                ll temp = dis[j][rk[i][pre]] + dis[i][rk[i][now]] + a[i][j];</span><br><span class="line">                <span class="keyword">if</span>(temp &lt; ans)&#123;</span><br><span class="line">                    ans = tmep;</span><br><span class="line">                    ansi = i; ansj = j;</span><br><span class="line">                    dx = ans - <span class="number">2</span> * dis[i][rk[i][now]];</span><br><span class="line">                &#125;</span><br><span class="line">                pre = now; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) D[i] = inf;</span><br><span class="line">    <span class="built_in">getpath</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">if</span>(par[i]) <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, i, par[i], a[i][par[i]]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树 </tag>
            
            <tag> DSU on tree </tag>
            
            <tag> MDST </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>chanllage</title>
      <link href="/2020/11/03/chanllage/"/>
      <url>/2020/11/03/chanllage/</url>
      
        <content type="html"><![CDATA[<p>有一些有趣但是大概需要高深数学知识的计算机问题悬而未决，特此记录。</p><span id="more"></span><h3 id="张帆猜想"><a href="#张帆猜想" class="headerlink" title="张帆猜想"></a>张帆猜想</h3><h3 id="哈希冲突概率"><a href="#哈希冲突概率" class="headerlink" title="哈希冲突概率"></a><a href="http://rqdmap.top/2020/10/28/2020-ccpc-qinhuangdao/#more">哈希冲突概率</a></h3><p>有等式$(a_1^k+a_2^k+…+a_n^k) \% 2^{64}=(b_1^k+b_2^k+…+b_n^k)\% 2^{64}$，</p><p>定义“冲突“为：满足上述等式的两个多重集合{an}{bn}不完全相同。</p><p>希望说明：当n为1e5的级别时，k=2时冲突概率极高，而当k&gt;=3时冲突的概率就会降低到一个可以接受的程度。</p><p>集合{an}{bn}的元素可能可以认为是在[0, 2^64)均匀分布的，不过这一点没有仔细考究，也没有造若干数据进行检验。</p>]]></content>
      
      
      <categories>
          
          <category> 悬而未决 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2020-ccpc-qinhuangdao</title>
      <link href="/2020/10/28/2020-ccpc-qinhuangdao/"/>
      <url>/2020/10/28/2020-ccpc-qinhuangdao/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><span id="more"></span><h2 id="K-树dp"><a href="#K-树dp" class="headerlink" title="K 树dp"></a>K 树dp</h2><p>场上想了一个不太对的排序办法，真正的排序方法应该是将子树按照最深深度从低到高进行排序。然后随便维护一个dp数组表示从根节点派遣若干士兵遍历完i子树所需要的最小时间，每次尝试用子树的结果更新他们共同父节点的信息：</p><ul><li>如果某节点是叶子，那么用其深度作为结果；</li><li>如果某节点不是叶子，将子树按照上述顺序排序后，考虑子树v1可能对v2造成的贡献：当height[v1] + 2 &lt;= dep[v2]，那么从v1的士兵原路返回会比重新派遣一个人过来更优，将结果减去差值，不断重复更新。每次只需要考虑子树$i$对子树${i + 1}$的贡献，这是因为子树序列是单调的，一旦到某个位置后重新派遣更优，之后的所有位置也一定是重新派遣更优。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> manx = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">star</span>&#123;</span><span class="keyword">int</span> to, next;&#125;;</span><br><span class="line"><span class="keyword">int</span> head[maxn], top = <span class="number">0</span>;</span><br><span class="line">star edge[maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    edge[top].to = v;</span><br><span class="line">    edge[top].next = head[u];</span><br><span class="line">    head[u] = top++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dep[maxn], height[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> par)</span></span>&#123;</span><br><span class="line">    height[x] = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; ~i; i = edge[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> to = edge[i].to; <span class="keyword">if</span>(to == par) <span class="keyword">continue</span>;</span><br><span class="line">        dep[to] = dep[x] + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(to, x);</span><br><span class="line">        height[x] = <span class="built_in">max</span>(height[x], height[to] + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从根结点派遣若干人，遍历完i子树所需要的最小代价即为dp[i]</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;<span class="keyword">return</span> height[x] &lt; height[y];&#125;</span><br><span class="line">ll dp[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sove</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> par)</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[now]; ~i; i = edge[i].next)&#123;</span><br><span class="line">        itn to = edge[i].to; <span class="keyword">if</span>(to == par) <span class="keyword">continue</span>;</span><br><span class="line">        vec.<span class="built_in">push_back</span>(to);</span><br><span class="line">        <span class="built_in">sove</span>(to, now);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), cmp);</span><br><span class="line">    <span class="keyword">if</span>(vec.<span class="built_in">empty</span>()) dp[now] = dep[now];</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> top = (<span class="keyword">int</span>)vec.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x: vec) dp[now] += dp[x];</span><br><span class="line">        <span class="built_in">fro</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; top; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(height[vec[i - <span class="number">1</span>]] + <span class="number">2</span> &lt;= dep[vec[i]])&#123; </span><br><span class="line">                dp[now] -= dep[vec[i]] - height[vec[i - <span class="number">1</span>]] - <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// Fastin;</span></span><br><span class="line">    <span class="keyword">int</span> _; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;_); <span class="built_in">fro</span>(<span class="keyword">int</span> __ = <span class="number">1</span>; __ &lt;= _; __++)&#123;</span><br><span class="line">        top = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            dp[i] = height[i] = dep[i] = <span class="number">0</span>;</span><br><span class="line">            head[i] = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">            <span class="built_in">add</span>(x, i); <span class="built_in">add</span>(i, x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">sove</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case #%d: %d\n&quot;</span>, __, dp[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="J-哈希与组合数学"><a href="#J-哈希与组合数学" class="headerlink" title="J 哈希与组合数学"></a>J 哈希与组合数学</h2><p>感谢冯佬的指点qaq 不然我可能一年都调不出来这题…sro flukehn….</p><p>题意读明白后剩余的就比较简单了，先On遍历长度d,对于每一段长度先处理出来一种组合情况，复杂度大概是Olog；接下来不断地移动残余的小区间r，每次移动只会影响到上一次划分的某一个d区间，那么我们就可以只将某一段区间的次数减一，然后对新区间的次数加一即可；如果使用map/unordered_map等容器，那么复杂度大概就是$log^2$，总复杂度$nlog^2$。</p><p>对字符串的哈希采用传统哈希即可，对不同字符串的组合状态我采用了平方法。平方法比较好写，同时操作可逆，值得一试。然而最后发现平方法的冲突概率极高，连随机数据都无法完美跑过；换成3方和4方即可顺利AC。</p><p>有一些值得注意的点：</p><ul><li>字符串hash可以采用ull自然溢出的办法，如果指定素数不断取模会很慢，如果遇到一些常数比较紧的题目就会T死(<del>比如这道题如果不用自然溢出大概就会TLE</del>)</li><li>unorder_set/unordered_map的clear()方法会比直接.swap一个新的空容器慢很多<del>在这题中真的很多</del>。有猜测是说clear()不会清空缓存，导致之后的哈希表元素相距较远，查询起来就会慢很多？</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">cosnt itn manx = <span class="number">3e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> itn M = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">const</span> itn pp = <span class="number">23333333</span>;</span><br><span class="line"><span class="keyword">int</span> n; </span><br><span class="line"><span class="keyword">char</span> s[maxn];</span><br><span class="line"></span><br><span class="line">ull hsh[maxn], po[manx];</span><br><span class="line">ll fac[maxn], facinv[maxn], inv[maxn];</span><br><span class="line"> </span><br><span class="line"><span class="comment">//返回字符串s[l..r]的hsh值</span></span><br><span class="line"><span class="function">ull <span class="title">gethsh</span><span class="params">(<span class="keyword">int</span> l ,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    ull ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l == <span class="number">0</span>) ans = hsh[r];</span><br><span class="line">    <span class="keyword">else</span> ans = hsh[r] - hsh[l - <span class="number">1</span>];</span><br><span class="line">    ans = ans * po[n - l]; </span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//ss存结果</span></span><br><span class="line">unordered_set&lt;ull&gt; sts;</span><br><span class="line"><span class="comment">//记录某种手串出现过多少次，</span></span><br><span class="line">unordered_map&lt;ull, <span class="keyword">int</span>&gt; mp;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//利用map数组，更新结果到ss中</span></span><br><span class="line"><span class="function">ll <span class="title">getans</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>; ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x: mp) <span class="keyword">if</span>(x.second &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        ans *= facinv[x.second]; ans %= M;</span><br><span class="line">        n += x.second;</span><br><span class="line">    &#125;</span><br><span class="line">    ans = ans * fac[n] % M; </span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// Fastin;</span></span><br><span class="line">    po[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">300000</span>; i++) po[i] = po[i - <span class="number">1</span>] * pp;</span><br><span class="line"></span><br><span class="line">    fac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">fro</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">300000</span>; i++) fac[i] = fac[i - <span class="number">1</span>] * i % M;</span><br><span class="line">    facinv[<span class="number">300000</span>] = <span class="built_in">qp</span>(fac[<span class="number">300000</span>], M - <span class="number">2</span>, M);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">300000</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) facinv[i] = facinv[i + <span class="number">1</span>] * (i + <span class="number">1</span>) % M;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">300000</span>; i++) inv[i] = <span class="built_in">qp</span>(i, M - <span class="number">2</span>, M);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> __; <span class="built_in">scnaf</span>(<span class="string">&quot;%d&quot;</span>, &amp;__); <span class="keyword">for</span>(<span class="keyword">int</span> _ = <span class="number">1</span>; _ &lt;= __; _++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s); n = (<span class="keyword">int</span>)<span class="built_in">strlen</span>(s);</span><br><span class="line">        hsh[<span class="number">0</span>] = s[<span class="number">0</span>] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">            hsh[i] = hsh[i - <span class="number">1</span>] + (s[i] - <span class="string">&#x27;a&#x27;</span>) * po[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//选取长度为d的单个项链</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> d = <span class="number">1</span>; d &lt;= n; d++)&#123;</span><br><span class="line">            unordered_set&lt;ull&gt; sts0;</span><br><span class="line">            unordered_map&lt;ull, <span class="keyword">int</span>&gt; mp0;</span><br><span class="line">            sts.<span class="built_in">swap</span>(sts0);</span><br><span class="line">            mp.<span class="built_in">swap</span>(mp0);</span><br><span class="line">            <span class="comment">//初始化 </span></span><br><span class="line">            ull K = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> now = <span class="number">0</span>; now + d - <span class="number">1</span> &lt; n; now += d)&#123;</span><br><span class="line">                ull value = <span class="built_in">gethsh</span>(now, now + d - <span class="number">1</span>);</span><br><span class="line">                mp[value]++;</span><br><span class="line">                K += value * value * value * value;</span><br><span class="line">            &#125;</span><br><span class="line">            ll temp = <span class="built_in">getans</span>();</span><br><span class="line">            ans += temp; sts.<span class="built_in">insert</span>(K); </span><br><span class="line">            <span class="keyword">if</span>(n % d)&#123;</span><br><span class="line">                <span class="keyword">int</span> r = n % d; <span class="keyword">int</span> pos = n / d * d;</span><br><span class="line">                <span class="comment">//[pos, pos + r - 1]</span></span><br><span class="line">                <span class="comment">//往前移动一次，减去[pos - d, pos - 1]，加上[pos + r - d, pos + r - 1];</span></span><br><span class="line">                <span class="keyword">while</span>(pos &gt;= d)&#123;</span><br><span class="line">                    ull value = <span class="built_in">gethsh</span>(pos - d, pos - <span class="number">1</span>);</span><br><span class="line">                    ll bias = mp[value];</span><br><span class="line"></span><br><span class="line">                    mp[value]--;</span><br><span class="line">                    K -= value * value * value * value;</span><br><span class="line"></span><br><span class="line">                    value = <span class="built_in">gethsh</span>(pos + r - d, pos + r - <span class="number">1</span>);</span><br><span class="line">                    mp[value]++;</span><br><span class="line">                    bias = bias * inv[mp[value]] % M;</span><br><span class="line">                    K += value * value * value * value;</span><br><span class="line"></span><br><span class="line">                    temp = temp * bias % M;</span><br><span class="line">                    <span class="keyword">if</span>(sts.<span class="built_in">count</span>(K) == <span class="number">0</span>)&#123;</span><br><span class="line">                        sts.<span class="built_in">insert</span>(K);</span><br><span class="line">                        ans += temp; ans %= M;</span><br><span class="line">                    &#125;</span><br><span class="line">                    pos -= d;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case #%d: %lld\n&quot;</span>, _, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="I-数论-amp-辗转相除-线性空间基底"><a href="#I-数论-amp-辗转相除-线性空间基底" class="headerlink" title="I 数论&amp;辗转相除 线性空间基底"></a>I 数论&amp;辗转相除 线性空间基底</h2><p>场上想了个(0, y)(x, 0)的基底，但是非常遗憾这种基底虽然非常简洁，却只适用于实数域中，在整数领域中这种基底并不能奏效。</p><p>考虑辗转相除法，使用形如(0, y0), (x1, y1)的基底，这样既能够张成一个二维平面，又能够<strong>不丢失、不扩张原有基底的表示范围</strong>。每次加入一个元素(x, y)只需要将(x1, y1)和(x, y)做辗转相除，消去其中某一个向量的x分量，再将该向量的y分量与(0, y0)的y分量做gcd就能得到一个融合的基底，用这个新基底就能够等价地表示原有的两个向量。</p><p><del>有一些地方得小心处理，不然不仅会爆int甚至会爆longlong</del></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;pair&lt;ll, ll&gt;&gt; vec;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(pair&lt;ll, ll&gt; &amp;p1, pair&lt;ll, ll&gt; &amp;p2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(p1.first)&#123;</span><br><span class="line">        ll d = p2.first / p1.first;</span><br><span class="line">        p2.first -= d * p1.first;</span><br><span class="line">        p2.second -= d * p1.second;</span><br><span class="line">        <span class="built_in">swap</span>(p1, p2);</span><br><span class="line">    &#125;</span><br><span class="line">    p1.second = <span class="built_in">abs</span>(p1.second);</span><br><span class="line">    p2.second %= p1.second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(ll u, ll v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(vec.<span class="built_in">empty</span>()) vec.<span class="built_in">push_back</span>(&#123;u, v&#125;);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        pair&lt;ll, ll&gt; temp; temp.first = u; temp.second = v;</span><br><span class="line">        <span class="built_in">assert</span>(vec.<span class="built_in">size</span>() &lt;= <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span>(vec.<span class="built_in">size</span>() == <span class="number">1</span>)&#123;</span><br><span class="line">            vec.<span class="built_in">push_back</span>(temp);</span><br><span class="line">            <span class="built_in">fun</span>(vec[<span class="number">0</span>], vec[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">fun</span>(vec[<span class="number">1</span>], tmep);</span><br><span class="line">            <span class="built_in">assert</span>(vec[<span class="number">0</span>].first == vec[<span class="number">1</span>].first &amp;&amp; vec[<span class="number">0</span>].first == <span class="number">0</span>);</span><br><span class="line">            vec[<span class="number">0</span>].second = <span class="built_in">abs</span>(<span class="built_in">gcd</span>(vec[<span class="number">0</span>].second, vec[<span class="number">1</span>].second));</span><br><span class="line">            temp.second %= vec[<span class="number">0</span>].second; </span><br><span class="line">            vec[<span class="number">1</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(ll x, ll y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x == <span class="number">0</span> &amp;&amp; y == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(vec.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(vec.<span class="built_in">size</span>() == <span class="number">1</span>) <span class="keyword">return</span> vec[<span class="number">0</span>].first * y == vec[<span class="number">0</span>].second * x;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x % vec[<span class="number">1</span>].first) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        y -= x / vec[<span class="number">1</span>].first * vec[<span class="number">1</span>].second;</span><br><span class="line">        <span class="keyword">if</span>(y % vec[<span class="number">0</span>].second == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// Fastin;</span></span><br><span class="line">    <span class="keyword">int</span> TT; <span class="built_in">scnaf</span>(<span class="string">&quot;%d&quot;</span>, &amp;TT); </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> cas = <span class="number">1</span>; cas &lt;= TT; cas++)&#123;</span><br><span class="line">        ll ans = <span class="number">0</span>; vec.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">int</span> q; <span class="built_in">scnaf</span>(<span class="string">&quot;%d&quot;</span>, &amp;q); <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">            <span class="keyword">int</span> op; <span class="built_in">scnaf</span>(<span class="string">&quot;%d&quot;</span>, &amp;op);</span><br><span class="line">            <span class="keyword">if</span>(op == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> x, y; <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">                <span class="keyword">if</span>(x == <span class="number">0</span> &amp;&amp; y == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="comment">//保证加入有意义的向量。</span></span><br><span class="line">                <span class="built_in">add</span>(x, y);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> x, y, w; <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;x, &amp;y, &amp;w);</span><br><span class="line">                ans += w * <span class="built_in">query</span>(x, y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case #%d: %lld\n&quot;</span>, cas, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="H-计数-DP"><a href="#H-计数-DP" class="headerlink" title="H 计数 DP"></a>H 计数 DP</h2><p>首先学习于博客 <a href="https://www.cnblogs.com/CzxingcHen/p/13892671.html">点我</a>, 然而调了一下午发现他讲的十分晦涩，自己的理解是错误的。</p><p>接下来便从Linqi的博客中找到了一种漂亮的说明，<a href="https://www.cnblogs.com/linqi05/p/13860846.html">这里</a></p><p>对于要求的这种<strong>平方</strong>和式，一种常见的转化是转化成$\sum _{1≤i,j≤n}[a[i] = a[j] = k],$ 其中k给定。那么对于某个k而言，我们只要在所有的合法序列中找出所有的这种序列对数即可。</p><p>通过<code>第一个出现数值k的位置</code>来划分一簇序列，这一簇序列可以通过一些统一的手段进行计数。</p><p>首先预处理出两个计数dp数组：</p><ul><li>$dp1[i][j]$表示所有序列a1, a2,…,ai, a0=0中满足$pi=j$的所有合法序列的个数</li><li>dp$2[i][j]$表示所有序列a1, a2,…,ai, a0=j中合法序列的个数。</li></ul><p>那么对一簇序列计数（记pos为第一个出现k的位置）时分4种情况考虑:</p><ul><li>两个数均选择pos</li><li>一个数选择pos、另一个数不选择pos</li><li>两个数均选择pos后的某一个位置</li><li>两个位置不同且均不选择pos</li></ul><p>情况1显然对应$dp2[n - pos][t] * dp[pos - 1][t - 1]$。</p><p>情况23都是在(pos, n]中选择了一个位置，那么只需要考虑长度为n-pos-1的合法序列个数即可。<strong>这是因为可以通过插入/删除一个位置的元素来与原序列进行一一映射</strong>。结果均是$ (n - pos) * dp2[n - pos - 1][t]$，而这两种情况一共有3种可能的第一个选择情况，因而上述表达式乘以3后贡献进答案。</p><p>情况4与情况23类似，不同的仅仅是在(pos, n]中选择了两个数，因而结果为：$ (n - pos) <em> (n - pos - 1) </em> dp2[n - pos - 2][t]$</p><p>据此，即可$O(n^2)$地得出所有的结果。</p><p><del>sro zlq!</del></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">cosnt <span class="keyword">int</span> maxn = <span class="number">3e3</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, M;</span><br><span class="line">ll dp[maxn][maxn], dp2[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">ini</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">clr</span>(dp, <span class="number">0</span>); <span class="built_in">clr</span>(dp2, <span class="number">0</span>); </span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">        dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + j * dp[i - <span class="number">1</span>][j] % M;</span><br><span class="line">        dp[i][j] %= M;</span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) dp2[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">    dp2[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>; dp2[<span class="number">1</span>][n] = n; <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) dp2[<span class="number">1</span>][i] = i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">        dp2[i][j] = dp2[i - <span class="number">1</span>][j + <span class="number">1</span>] + dp2[i - <span class="number">1</span>][j] * j % M;</span><br><span class="line">        dp2[i][j] %= M;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// Fastin;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> TT; <span class="built_in">scnaf</span>(<span class="string">&quot;%d&quot;</span>, &amp;TT); </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> cas = <span class="number">1</span>; cas &lt;= TT; cas++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case #%d:\n&quot;</span>, cas);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;M);</span><br><span class="line">        <span class="built_in">ini</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> t = <span class="number">1</span>; t &lt;= n; t++)&#123;</span><br><span class="line">            ll temp = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> pos = t; pos &lt;= n; pos++)&#123;</span><br><span class="line">                ll ans = dp2[n - pos][t];</span><br><span class="line">                <span class="keyword">if</span>(pos &lt;= n - <span class="number">1</span>) ans = (ans + <span class="number">3ll</span> * (n - pos) % M * dp2[n - pos - <span class="number">1</span>][t] % M) % M;</span><br><span class="line">                <span class="keyword">if</span>(pos &lt;= n - <span class="number">2</span>) ans = (ans + (n - pos) * <span class="number">1ll</span> * (n - pos - <span class="number">1</span>) % M * dp2[n - pos - <span class="number">2</span>][t] % M) % M;</span><br><span class="line">                ans = ans * dp[pos - <span class="number">1</span>][t - <span class="number">1</span>] % M;</span><br><span class="line">                tmep += ans; temp %= M;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>, temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树dp </tag>
            
            <tag> 字符串哈希 </tag>
            
            <tag> 组合计数 </tag>
            
            <tag> 线性基底 </tag>
            
            <tag> 辗转相除 </tag>
            
            <tag> 计数DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019-SWERC</title>
      <link href="/2020/10/17/2019-SWERC/"/>
      <url>/2020/10/17/2019-SWERC/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><span id="more"></span><p><strong>参考博客：</strong></p><p><a href="https://www.cnblogs.com/heyuhhh/p/12941654.html">https://www.cnblogs.com/heyuhhh/p/12941654.html</a></p><h3 id="K-图上的路径存在问题-gt-建反图进行染色"><a href="#K-图上的路径存在问题-gt-建反图进行染色" class="headerlink" title="K 图上的路径存在问题(?) -&gt;建反图进行染色"></a>K 图上的路径存在问题(?) -&gt;建反图进行染色</h3><p>建反图，用rot的每个邻点去对整张图染色，被染色的点就意味着可以走到该颜色所代表的邻点。我们允许每个点最多被染色两次，这是因为rot的邻点一旦被超过一个点染色，那么就一定不合法；所以对图中每个点而言，如果其被染色次数大于等于2，那么其出边所对应的一系列点的更新也已经都完成，再次染色增加染色次数没有任何意义，并不会改变“不合法”这一性质。</p><p>需要注意的是为了避免在一些环路中绕死，每次应该判断一下当前点是否已经被当前颜色染过。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, rot;</span><br><span class="line"><span class="keyword">int</span> head[maxn], top = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">star</span>&#123;</span><span class="keyword">int</span> to, next;&#125;;</span><br><span class="line">star edge[maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    edge[top].to = v;</span><br><span class="line">    edge[top].next = head[u];</span><br><span class="line">    head[u] = top++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">set&lt;<span class="keyword">int</span>&gt; ans, res;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; vec[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sze = (<span class="keyword">int</span>)vec[now].<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span>(sze == <span class="number">2</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(sze == <span class="number">1</span> &amp;&amp; vec[now][<span class="number">0</span>] == c) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        vec[now].<span class="built_in">push_back</span>(c);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = head[now]; ~i; i = edge[i].next)&#123;</span><br><span class="line">            <span class="keyword">if</span>(edge[i].to == rot) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(edge[i].to, c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// Fastin;  </span></span><br><span class="line">    <span class="built_in">clr</span>(head, <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;n, &amp;m, &amp;rot);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> u, v; <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">        <span class="built_in">add</span>(v, u);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[rot]; ~i; i = edge[i].next)&#123;</span><br><span class="line">        ans.<span class="built_in">insert</span>(edge[i].to);</span><br><span class="line">        <span class="built_in">dfs</span>(edge[i].to, edge[i].to);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x: ans) <span class="keyword">if</span>((vec[x].<span class="built_in">size</span>() == <span class="number">1</span> &amp;&amp; vec[x][<span class="number">0</span>] == x)) res.<span class="built_in">insert</span>(x);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, (<span class="keyword">int</span>)res.<span class="built_in">size</span>());</span><br><span class="line">    <span class="built_in">fro</span>(<span class="keyword">int</span> x: res) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, x);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="A-二维价值dijstra-在一维路径权值和有上限的条件下求另一维的最短路"><a href="#A-二维价值dijstra-在一维路径权值和有上限的条件下求另一维的最短路" class="headerlink" title="A 二维价值dijstra(在一维路径权值和有上限的条件下求另一维的最短路)"></a>A 二维价值dijstra(在一维路径权值和有上限的条件下求另一维的最短路)</h3><p>复杂度大概是$EBlog{EB}$，E是图中边数，B是距离的上限。</p><p>简单地修改一下dijstra即可，但是写起来感觉又长又麻烦。</p><p><del>sro 场上1A的IGVA</del></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">POINT</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span>&#123;<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;x, &amp;y);&#125;</span><br><span class="line">&#125;;</span><br><span class="line">POINT p[manx], s, t;</span><br><span class="line"><span class="keyword">int</span> b, c[maxn], type, n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[maxn], top = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">star</span>&#123;</span><span class="keyword">int</span> from, to, next, dis, w, op;&#125;;</span><br><span class="line">star edge[maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getdis</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> rdis = (p[u].x - p[v].x) * (p[u].x - p[v].x) + (p[u].y - p[v].y) * (p[u].y - p[v].y);</span><br><span class="line">    <span class="keyword">int</span> dis = <span class="built_in">max</span>(<span class="number">0</span>, (<span class="keyword">int</span>)<span class="built_in">sqrt</span>(rdis) - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">while</span>(dis * dis &lt; rdis) dis++;</span><br><span class="line">    <span class="keyword">return</span> dis;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> op)</span></span>&#123;</span><br><span class="line">    <span class="comment">//以op的方式连接一条路径</span></span><br><span class="line">    edge[top].from = u;</span><br><span class="line">    edge[top].to = v;</span><br><span class="line">    edge[top].op = op;</span><br><span class="line">    edge[top].next= head[u];</span><br><span class="line">    head[u] = top++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    edge[i].dis = <span class="built_in">getdis</span>(edge[i].from, edge[i].to);</span><br><span class="line">    edge[i].w = edge[i].dis * c[edge[i].op];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//dis[i][j]表示从s到达i点、距离花费为j时的最小碳排放量</span></span><br><span class="line"><span class="keyword">int</span> dis[maxn][<span class="number">110</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NODE</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v, dis, w;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> NODE&amp; b)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(w != b.w) <span class="keyword">return</span> w &gt; b.w;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> dis &gt; b.dis;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;NODE&gt; pq;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dij</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">clr</span>(dis, <span class="number">0x3f</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> d = <span class="built_in">getdis</span>(n, i); <span class="keyword">if</span>(d &gt; b) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> w = d * c[<span class="number">0</span>];</span><br><span class="line">        pq.<span class="built_in">push</span>(&#123;i, d, w&#125;);</span><br><span class="line">        dis[i][d] = w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!pq.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        NODE temp = pq.<span class="built_in">top</span>(); pq.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">int</span> d = temp.dis, w = tmep.w, v = temp.v;</span><br><span class="line">        <span class="keyword">if</span>(w &gt; dis[v][d]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = head[v]; ~i; i = edge[i].next) </span><br><span class="line">        <span class="keyword">if</span>(edge[i].dis + d &lt;= b)&#123;</span><br><span class="line">            <span class="keyword">if</span>(edge[i].w + w &lt; dis[edge[i].to][d + edge[i].dis])&#123;</span><br><span class="line">                dis[edge[i].to][d + edge[i].dis] = edge[i].w + w;</span><br><span class="line">                pq.<span class="built_in">push</span>(&#123;edge[i].to, d + edge[i].dis, edge[i].w + w&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="keyword">for</span>(<span class="keyword">int</span> d = <span class="number">0</span>; d &lt;= b; d++)&#123;</span><br><span class="line">        <span class="keyword">int</span> dd = <span class="built_in">getdis</span>(i, n + <span class="number">1</span>); <span class="keyword">if</span>(d + dd &gt; b) <span class="keyword">break</span>;</span><br><span class="line">        ans = <span class="built_in">min</span>(ans, dis[i][d] + dd * c[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">getdis</span>(n, n + <span class="number">1</span>) &lt;= b) ans = <span class="built_in">min</span>(ans, <span class="built_in">getdis</span>(n, n + <span class="number">1</span>) * c[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">if</span>(ans == <span class="number">0x3f3f3f3f</span>) ans = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// Fastin;  </span></span><br><span class="line">    <span class="built_in">clr</span>(head, <span class="number">-1</span>);</span><br><span class="line">    s.<span class="built_in">read</span>(); t.<span class="built_in">read</span>();</span><br><span class="line">    <span class="built_in">scnaf</span>(<span class="string">&quot;%d&quot;</span>, &amp;b);</span><br><span class="line">    <span class="built_in">scnaf</span>(<span class="string">&quot;%d&quot;</span>, c);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;type);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= type; i++) <span class="built_in">scnaf</span>(<span class="string">&quot;%d&quot;</span>, c + i);</span><br><span class="line">    <span class="built_in">scnaf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        p[i].<span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">int</span> l; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;l);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; l; j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> v, op; <span class="built_in">scnaf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;v, &amp;op);</span><br><span class="line">            <span class="built_in">add</span>(i, v, op); <span class="built_in">add</span>(v, i, op);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fro</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; top; i++) <span class="built_in">update</span>(i);</span><br><span class="line">    p[n] = s; p[n + <span class="number">1</span>] = t;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">dij</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="J-卡特兰数计数问题"><a href="#J-卡特兰数计数问题" class="headerlink" title="J 卡特兰数计数问题"></a>J 卡特兰数计数问题</h3><p>中序遍历一棵树，给出其深度序列，且满足树上某个节点的深度一定不低于其父节点的深度。</p><p>容易想到n^3的算法，但其实这种形式是卡特兰数的一个表达形式，即</p><p>$c_0c_{n-1} +c_1c_{n - 2} + c_2c_{n-3} +…+c_{n-1}c_0=c_n$</p><p>$c_0 = c_1=1$</p><p>在当前区间中，如果最小值为m，且其数量为k个，那么这些最小值一定构成树的上层框架，其种数就是c[k]；并且无论上层框架的结构如何，对于那些被划分开来的更深的区域，只需要递归地求解并且乘上其种数即可。</p><p><del>脑补了一个线段树的比较草的nlogn的算法，但是还没有实现就看到了一个On的处理办法</del></p><p>维护一个单调增的单调栈，栈中元素为&lt;数值大小，出现次数&gt;。每次当一个较小的数字进入后，就将那些太高的点弹栈，他们的“辖域”已经被切断，根据其个数即可更新结果。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1000000007</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> inv[maxn];</span><br><span class="line"><span class="keyword">int</span> c[maxn];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NODE</span>&#123;</span><span class="keyword">int</span> num, times;&#125;;</span><br><span class="line">NODE node[maxn]; <span class="keyword">int</span> top = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(top == <span class="number">0</span>)&#123;</span><br><span class="line">        node[top].times = <span class="number">1</span>;</span><br><span class="line">        node[top].num = x;</span><br><span class="line">        top++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">assert</span>(node[top - <span class="number">1</span>].num &lt;= x);</span><br><span class="line">    <span class="keyword">if</span>(node[top - <span class="number">1</span>].num &lt; x)&#123;</span><br><span class="line">        node[top].num = x;</span><br><span class="line">        node[top].times = <span class="number">1</span>;</span><br><span class="line">        top++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> node[top - <span class="number">1</span>].times++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// Fastin;  </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; maxn; i++) inv[i] = (<span class="keyword">int</span>)<span class="built_in">qp</span>(i, M - <span class="number">2</span>, M);</span><br><span class="line">    c[<span class="number">0</span>] = <span class="number">1</span>; </span><br><span class="line">    <span class="built_in">fro</span>(itn i = <span class="number">0</span>; i &lt; <span class="number">1000005</span>; i++)&#123;</span><br><span class="line">        c[i + <span class="number">1</span>] = (<span class="keyword">int</span>)(<span class="number">1LL</span> * c[i] * (<span class="number">4</span> * i + <span class="number">2</span>) % M * inv[i + <span class="number">2</span>] % M);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">scnaf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="built_in">fro</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x; </span><br><span class="line">        <span class="keyword">if</span>(i != n) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x); <span class="keyword">else</span> x = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(top == <span class="number">0</span> || node[top - <span class="number">1</span>].num &lt;= x) <span class="built_in">push</span>(x);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(top &amp;&amp; node[top - <span class="number">1</span>].num &gt; x)&#123;</span><br><span class="line">                ans *= c[node[top - <span class="number">1</span>].times]; </span><br><span class="line">                ans %= M;</span><br><span class="line">                top--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">push</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="H-分段打表"><a href="#H-分段打表" class="headerlink" title="H 分段打表"></a>H 分段打表</h3><p>场上按道理应该是半推半就<del>实则观看题解</del>即可发现S序列具有周期性。</p><p>本来打算用hash找出循环地周期和起点，然而在1e8下直接慢到爆炸。</p><p>使用了IGVA教的序列快慢指针法即可On地找出循环节的信息。</p><p>起点和循环周题都在1e8的级别，考虑分段打表。</p><p>令$n = p*m + r$, m是自己选定的一个模数。只将整除于m的下标对应数的相关信息进行存储，查询时即可O(r)地查询。</p><p>然而一直TLE，才惊觉n可以等于0…..?   <del>orz</del></p><p>改了之后飞快过去了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ll M = <span class="number">1ll</span> &lt;&lt; <span class="number">40</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">fun</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line">    ll ans = (x + (x &gt;&gt; <span class="number">20</span>) + <span class="number">12345</span>) % M;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mm = <span class="number">5e5</span>;</span><br><span class="line">ll a[<span class="number">10000</span>] = &#123;&#125;;</span><br><span class="line">ll b[<span class="number">10000</span>] = &#123;&#125;;</span><br><span class="line">ll cnta[<span class="number">10000</span>] = &#123;&#125;;</span><br><span class="line">ll cntb[<span class="number">10000</span>] = &#123;&#125;;</span><br><span class="line">ll cnt0 = <span class="number">91029304</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// Fastin;</span></span><br><span class="line">    <span class="comment">// Fastout; </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// int n = 1e9;</span></span><br><span class="line">    <span class="comment">// int p = 0, q = 1;</span></span><br><span class="line">    <span class="comment">// ll r1 = 0x600dcafe, r2 = fun(r1);</span></span><br><span class="line">    <span class="comment">// while(p &lt;= n &amp;&amp; q &lt;= n &amp;&amp; r1 != r2)&#123;</span></span><br><span class="line">    <span class="comment">//     p++; q += 2;</span></span><br><span class="line">    <span class="comment">//     r1 = fun(r1);</span></span><br><span class="line">    <span class="comment">//     r2 = fun(fun(r2));</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// if(p &gt; n || q &gt; n) puts(&quot;orz&quot;);</span></span><br><span class="line">    <span class="comment">// else printf(&quot;%d %d: %lld\n&quot;, p, q, r1);</span></span><br><span class="line">    <span class="comment">//364258417 728516835: 1613948613</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// int cnt = 1;</span></span><br><span class="line">    <span class="comment">// ll res = fun(1613948613);</span></span><br><span class="line">    <span class="comment">// while(res != 1613948613)&#123;</span></span><br><span class="line">    <span class="comment">//     cnt++;</span></span><br><span class="line">    <span class="comment">//     res = fun(res);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// printf(&quot;%lld\n&quot;, cnt);</span></span><br><span class="line">    <span class="comment">//T: 182129209</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ll period = 182129209;</span></span><br><span class="line">    <span class="comment">// ll start = 364258417 - period;</span></span><br><span class="line">    <span class="comment">// ll r1 = 0x600dcafe;</span></span><br><span class="line">    <span class="comment">// while(start--) r1 = fun(r1);</span></span><br><span class="line">    <span class="comment">// start = 364258417 - period;</span></span><br><span class="line">    <span class="comment">// ll r2 = 1613948613, end = 364258417;</span></span><br><span class="line">    <span class="comment">// while(r1 != r2)&#123;</span></span><br><span class="line">    <span class="comment">//     start++; end++;</span></span><br><span class="line">    <span class="comment">//     r1 = fun(r1); r2 = fun(r2);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// printf(&quot;%d %d: %lld\n&quot;, start, end, r1);</span></span><br><span class="line">    <span class="comment">//350125310 532254519: 516914</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    ll start = <span class="number">350125310</span>, period = <span class="number">182129209</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ll p = 0, s = 0x600dcafe, cnt = 0;</span></span><br><span class="line">    <span class="comment">// while(p &lt; start)&#123;</span></span><br><span class="line">    <span class="comment">//     cnt += s % 2 == 0;</span></span><br><span class="line">    <span class="comment">//     if(p % mm == 0)&#123;</span></span><br><span class="line">    <span class="comment">//         a[p / mm] = s;</span></span><br><span class="line">    <span class="comment">//         cnta[p / mm] = cnt;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">         </span><br><span class="line">    <span class="comment">//      s = fun(s); p++;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// ll cnt0 = 0;</span></span><br><span class="line">    <span class="comment">// p -= start;</span></span><br><span class="line">    <span class="comment">// while(p &lt; period)&#123;</span></span><br><span class="line">    <span class="comment">//     cnt += s % 2 == 0;</span></span><br><span class="line">    <span class="comment">//     cnt0 += s % 2 == 0;</span></span><br><span class="line">    <span class="comment">//     if(p % mm == 0)&#123;</span></span><br><span class="line">    <span class="comment">//         b[p / mm] = s;</span></span><br><span class="line">    <span class="comment">//         cntb[p / mm] = cnt;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//     s = fun(s); p++;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// // printf(&quot;%lld\n&quot;, cnt0);</span></span><br><span class="line">    <span class="comment">// for(int i = 0; i &lt; 10000; i++) printf(&quot;%lld, &quot;, a[i]); </span></span><br><span class="line">    <span class="comment">// printf(&quot;\n&quot;);</span></span><br><span class="line">    <span class="comment">// for(int i = 0; i &lt; 10000; i++) printf(&quot;%lld, &quot;, b[i]);</span></span><br><span class="line">    <span class="comment">// printf(&quot;\n&quot;);</span></span><br><span class="line">    <span class="comment">// for(int i = 0; i &lt; 10000; i++) printf(&quot;%lld, &quot;, cnta[i]); </span></span><br><span class="line">    <span class="comment">// printf(&quot;\n&quot;);</span></span><br><span class="line">    <span class="comment">// for(int i = 0; i &lt; 10000; i++) printf(&quot;%lld, &quot;, cntb[i]);</span></span><br><span class="line">    <span class="comment">// printf(&quot;\n&quot;);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ll n; <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;n); </span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    n--;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; start)&#123;</span><br><span class="line">        ll res = a[n / mm];</span><br><span class="line">        ll ans = cnta[n / mm];</span><br><span class="line">        n %= mm;</span><br><span class="line">        <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">            res = <span class="built_in">fun</span>(res);</span><br><span class="line">            ans += res % <span class="number">2</span> == <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        n -= start;</span><br><span class="line">        ll p = n / period;</span><br><span class="line">        n %= period;</span><br><span class="line">        ll res = b[n / mm];</span><br><span class="line">        ll ans = cntb[n / mm] + p * cnt0;</span><br><span class="line">        n %= mm;</span><br><span class="line">        <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">            res = <span class="built_in">fun</span>(res);</span><br><span class="line">            ans += res % <span class="number">2</span> == <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="L-暴力-amp-normal-game"><a href="#L-暴力-amp-normal-game" class="headerlink" title="L 暴力 &amp; normal game"></a>L 暴力 &amp; normal game</h3><p>为了补这题重新从源头上学习了一番SG定理相关，并花费了较多的时间学习misere game的解法？但是好像收效颇微，不如以题代学，最近打算开几套博弈论专题作为训练，以便于切实地掌握各种normal play的一般解法，并尝试学习misere game的相关知识。</p><p>在本题中，题目保证两块湿地间距不小于3，那么可以单独地处理每一块；而在每一块中，只有那些连续的空地才需要被划分为一个单独的normal play，<del>不然可选状态过多，会TLE/MLE 后知后觉的我错了10发才意识到这个问题</del>，这样整个问题就被划分成了若干个normal play的组合，异或上其sg值即得到母游戏的sg值。具体到对某一个子游戏求解时，记忆化搜索即可，并没有什么技术难度。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">15</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">char</span> s[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> vis[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">in</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &gt;= <span class="number">1</span> &amp;&amp; y &gt;= <span class="number">1</span> &amp;&amp; x &lt;= n &amp;&amp; y &lt;= n &amp;&amp; s[x][y] != <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//保证进入vec的空地只有一次</span></span><br><span class="line">vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; vec, now;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> nx = x + dx[i], ny = y + dy[i];</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">in</span>(nx, ny) &amp;&amp; !vis[nx][ny])&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[nx][ny] == <span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">                vis[nx][ny] = <span class="number">2</span>;</span><br><span class="line">                vec.<span class="built_in">push_back</span>(&#123;nx, ny&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                vis[nx][ny] = <span class="number">1</span>;</span><br><span class="line">                <span class="built_in">dfs</span>(nx, ny);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> top;</span><br><span class="line">unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; sg;</span><br><span class="line"><span class="keyword">int</span> tong[<span class="number">100</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sove</span><span class="params">(<span class="keyword">int</span> sts, vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; &amp;vec)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(sg[sts] != <span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; top; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(sts &amp; <span class="number">1</span> &lt;&lt; i) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(sg[sts | <span class="number">1</span> &lt;&lt; i] == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> fail = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; top; j++) <span class="keyword">if</span>(sts &amp; <span class="number">1ll</span> &lt;&lt; j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">abs</span>(vec[i].first - vec[j].first) + <span class="built_in">abs</span>(vec[i].second - vec[j].second) &lt;= <span class="number">1</span>)&#123;fail = <span class="number">1</span>; <span class="keyword">break</span>;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(fail) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">sove</span>(sts | <span class="number">1</span> &lt;&lt; i, vec);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= top; i++) tong[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; top; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(sts &amp; <span class="number">1</span> &lt;&lt; i) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(sg[sts | <span class="number">1</span> &lt;&lt; i] != <span class="number">-1</span>) tong[sg[sts | <span class="number">1</span> &lt;&lt; i]] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> l; <span class="keyword">for</span>(l = <span class="number">0</span>; l &lt; top; l++) <span class="keyword">if</span>(tong[l] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    sg[sts] = l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">split</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    vis[x][y] = <span class="number">1</span>; now.<span class="built_in">push_back</span>(&#123;x, y&#125;);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> nx = x + dx[i], ny = y + dy[i];</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">in</span>(nx, ny) &amp;&amp; vis[nx][ny] == <span class="number">2</span>) <span class="built_in">split</span>(nx, ny);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// Fastin;</span></span><br><span class="line">    <span class="built_in">scnaf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n); <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scnaf</span>(<span class="string">&quot;%s&quot;</span>, s[i] + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">fro</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) <span class="keyword">if</span>(s[i][j] == <span class="string">&#x27;*&#x27;</span> &amp;&amp; !vis[i][j])&#123;</span><br><span class="line">        vec.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="built_in">dfs</span>(i, j); <span class="keyword">int</span> N = (<span class="keyword">int</span>)vec.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) <span class="keyword">if</span>(vis[vec[i].first][vec[i].second] == <span class="number">2</span>)&#123;</span><br><span class="line">            now.<span class="built_in">clear</span>();</span><br><span class="line">            <span class="built_in">split</span>(vec[i].first, vec[i].second);</span><br><span class="line">            top = (<span class="keyword">int</span>)now.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(itn i = <span class="number">0</span>; i &lt; <span class="number">1</span> &lt;&lt; top; i++) sg[i] = <span class="number">-1</span>;</span><br><span class="line">            <span class="built_in">sove</span>(<span class="number">0</span>, now); ans ^= sg[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(ans? <span class="string">&quot;First player will win&quot;</span>: <span class="string">&quot;Second player will win&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 最短路 </tag>
            
            <tag> 卡特兰数 </tag>
            
            <tag> 分段打表 </tag>
            
            <tag> 博弈论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019-icpc-taipei</title>
      <link href="/2020/10/04/2019-icpc-taipei/"/>
      <url>/2020/10/04/2019-icpc-taipei/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><span id="more"></span><h2 id="I-已知两数差，求所有可能的原本的序列"><a href="#I-已知两数差，求所有可能的原本的序列" class="headerlink" title="I 已知两数差，求所有可能的原本的序列"></a>I 已知两数差，求所有可能的原本的序列</h2><p>原序列长度小于等于62，序列值小于1000且两两不同。</p><p>如果已经还原出了原序列中的$i$个值，那么除去这i个值两两的差之后，差值集合中最大的数便可以基本确定下来：这个数一定是原序列中的某个数与a[1] = 0或者a[n]作差得到的，这点由“最大”保证。</p><p>那么检查这个最大的数出现的次数，如果次数超过2，则不满足两两不同的要求；如果次数为2，直接根据a[1], a[n]可以更新两个值进行原序列；如果次数仅为1，则需要分别递归考虑一番。</p><p>每次插入一个新值的时候要进行若干判断 </p><p><del>可能因此条件较为严苛？导致次数仅为1的2^n递归也在可以接受的范围之内；具体次数证明并没有太想得到</del></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">5e3</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, a[maxn], M;</span><br><span class="line">multiset&lt;<span class="keyword">int</span>, greater&lt;<span class="keyword">int</span>&gt;&gt; s, temp;</span><br><span class="line">multiset&lt;<span class="keyword">int</span>, greater&lt;<span class="keyword">int</span>&gt;&gt;::iterator it;</span><br><span class="line"></span><br><span class="line">set&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">vector&lt;set&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sove</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//从s集合中挑选一个进行尝试构造</span></span><br><span class="line">    <span class="keyword">if</span>(s.<span class="built_in">empty</span>())&#123;ans.<span class="built_in">push_back</span>(res); <span class="keyword">return</span>;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> now = *s.<span class="built_in">begin</span>(); <span class="keyword">int</span> cnt = (<span class="keyword">int</span>)s.<span class="built_in">count</span>(now);</span><br><span class="line">    <span class="keyword">if</span>(cnt &gt; <span class="number">2</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(cnt == <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> x = now, y = M - now;</span><br><span class="line">        <span class="comment">//保证两两不同</span></span><br><span class="line">        <span class="keyword">if</span>(res.<span class="built_in">find</span>(x) != res.<span class="built_in">end</span>() || res.<span class="built_in">find</span>(y) != res.<span class="built_in">end</span>()) <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        temp = s; <span class="keyword">int</span> fail = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//遍历那些已经确定好的值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> pre: res)&#123;</span><br><span class="line">            it = temp.<span class="built_in">find</span>(<span class="built_in">abs</span>(pre - x));</span><br><span class="line">            <span class="keyword">if</span>(it == temp.<span class="built_in">end</span>())&#123;fail = <span class="number">1</span>; <span class="keyword">break</span>;&#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;temp.<span class="built_in">erase</span>(it);&#125;</span><br><span class="line"></span><br><span class="line">            it = temp.<span class="built_in">find</span>(<span class="built_in">abs</span>(pre - y));</span><br><span class="line">            <span class="keyword">if</span>(it == temp.<span class="built_in">end</span>())&#123;fail = <span class="number">1</span>; <span class="keyword">break</span>;&#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;temp.<span class="built_in">erase</span>(it);&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(fail) <span class="keyword">return</span> ;</span><br><span class="line">        it = temp.<span class="built_in">find</span>(<span class="built_in">abs</span>(x - y));</span><br><span class="line">        <span class="keyword">if</span>(it == temp.<span class="built_in">end</span>()) <span class="keyword">return</span> ;</span><br><span class="line">        temp.<span class="built_in">erase</span>(it); </span><br><span class="line"></span><br><span class="line">        s = temp; res.<span class="built_in">insert</span>(x); res.<span class="built_in">insert</span>(y);</span><br><span class="line">        <span class="built_in">sove</span>(); res.<span class="built_in">erase</span>(x); res.<span class="built_in">erase</span>(y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//个数为1</span></span><br><span class="line">        multiset&lt;<span class="keyword">int</span>, greater&lt;<span class="keyword">int</span>&gt;&gt; s0 = s;</span><br><span class="line">        <span class="keyword">int</span> x = now;</span><br><span class="line">        <span class="keyword">if</span>(res.<span class="built_in">find</span>(x) == res.<span class="built_in">end</span>())&#123;</span><br><span class="line">            <span class="keyword">int</span> fail = <span class="number">0</span>; temp = s0;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> pre: res)&#123;</span><br><span class="line">                it = temp.<span class="built_in">find</span>(<span class="built_in">abs</span>(x - pre));</span><br><span class="line">                <span class="keyword">if</span>(it == temp.<span class="built_in">end</span>())&#123;fail = <span class="number">1</span>; <span class="keyword">break</span>;&#125;</span><br><span class="line">                <span class="keyword">else</span> temp.<span class="built_in">erase</span>(it);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!fail)&#123;</span><br><span class="line">                res.<span class="built_in">insert</span>(x); s = temp; <span class="built_in">sove</span>();</span><br><span class="line">                res.<span class="built_in">erase</span>(x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        x = M - now;</span><br><span class="line">        <span class="keyword">if</span>(res.<span class="built_in">find</span>(x) == res.<span class="built_in">end</span>())&#123;</span><br><span class="line">            <span class="keyword">int</span> fail = <span class="number">0</span>; temp = s0;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> pre: res)&#123;</span><br><span class="line">                it = temp.<span class="built_in">find</span>(<span class="built_in">abs</span>(x - pre));</span><br><span class="line">                <span class="keyword">if</span>(it == temp.<span class="built_in">end</span>())&#123;fail = <span class="number">1</span>; <span class="keyword">break</span>;&#125;</span><br><span class="line">                <span class="keyword">else</span> temp.<span class="built_in">erase</span>(it);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!fail)&#123;</span><br><span class="line">                res.<span class="built_in">insert</span>(x); s = temp; <span class="built_in">sove</span>();</span><br><span class="line">                res.<span class="built_in">erase</span>(x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// Fastin;</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n); <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n * (n - <span class="number">1</span>) / <span class="number">2</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x; <span class="built_in">scnaf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x); s.<span class="built_in">insert</span>(x);</span><br><span class="line">        <span class="keyword">if</span>(x &gt; <span class="number">999</span>)&#123; <span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>); <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">        M = <span class="built_in">max</span>(M, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>((<span class="keyword">int</span>)s.<span class="built_in">count</span>(M) &gt; <span class="number">1</span>)&#123; <span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>); <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line"></span><br><span class="line">    a[n] = M; s.<span class="built_in">erase</span>(a[n]); res.<span class="built_in">insert</span>(<span class="number">0</span>); res.<span class="built_in">insert</span>(M);</span><br><span class="line">    <span class="built_in">sove</span>();</span><br><span class="line">    <span class="keyword">int</span> top = (<span class="keyword">int</span>)(<span class="built_in">unique</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>()) - ans.<span class="built_in">begin</span>());</span><br><span class="line">    <span class="built_in">sort</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">begin</span>() + top);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, top);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; top; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x: ans[i]) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, x);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="luogu-两数和"><a href="#luogu-两数和" class="headerlink" title="luogu 两数和"></a>luogu 两数和</h3><p>给出两数和，问是否存在一个可行原序列。</p><p>原序列长度不超过10.</p><p>将两数和的集合从小到大开始考虑，通过最小的和数可以枚举出a[1], a[2]的值，接下来在集合中删除这些值，剩下的元素中最小值必然就是a[1]+a[3]，据此可以得到a[3]的值，重复操作即可不断向后构造。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">multiset&lt;<span class="keyword">int</span>&gt; s0, s;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">20</span>];</span><br><span class="line">multiset&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">     Fastin;</span><br><span class="line">    <span class="keyword">int</span> n; </span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scnaf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n))&#123;</span><br><span class="line">        s0.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="built_in">fro</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n * (n - <span class="number">1</span>) / <span class="number">2</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x); s0.<span class="built_in">insert</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> ok = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(a[<span class="number">1</span>] = <span class="number">0</span>; a[<span class="number">1</span>] &lt;= *s0.<span class="built_in">begin</span>() - a[<span class="number">1</span>]; a[<span class="number">1</span>]++)&#123;</span><br><span class="line">            <span class="keyword">int</span> fail = <span class="number">0</span>;</span><br><span class="line">            s = s0;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">                a[i] = *s.<span class="built_in">begin</span>() - a[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>(a[i] &lt; <span class="number">0</span> || a[i] &lt; a[i - <span class="number">1</span>])&#123;fail = <span class="number">1</span>; <span class="keyword">break</span>;&#125;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; j++)&#123;</span><br><span class="line">                    it = s.<span class="built_in">find</span>(a[j] + a[i]);</span><br><span class="line">                    <span class="keyword">if</span>(it == s.<span class="built_in">end</span>())&#123;fail = <span class="number">1</span>; <span class="keyword">break</span>;&#125;</span><br><span class="line">                    s.<span class="built_in">erase</span>(it);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(fail) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!fail)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">printf</span>(<span class="string">&quot;%d%c&quot;</span>, a[i], <span class="string">&quot; \n&quot;</span>[i == n]);</span><br><span class="line">                ok = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!ok) <span class="built_in">puts</span>(<span class="string">&quot;Impossible&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 构造 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript</title>
      <link href="/2020/09/18/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/09/18/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><span id="more"></span><h1 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h1><h2 id="数据变量与类型"><a href="#数据变量与类型" class="headerlink" title="数据变量与类型"></a>数据变量与类型</h2><p>JS中整数和浮点数统一对待，甚至可以对浮点数做<code>%</code>运算，但是整数数值的范围是<code>[-2^53, 2^53]</code><del>非常神秘</del></p><p>表达一个字符串既可以用<code>&#39;</code>也可以用<code>&quot;</code>。</p><p>JS有缺陷的一点在于，使用相等运算符<code>==</code>时，可以对不同类型的元素进行比较，这往往会导致奇怪的结果；为此，建议总是使用<code>===</code>这一相等运算符，该运算符会先比较类型是否相同，不同则返回<code>false</code>，相同再比较变量是否相同。</p><p>浮点数的相等比较依然要设置<code>eps</code>，<del>而且我怀疑js中的精度可能比double垃圾很多</del></p><p>js中<code>null</code>表示一个“空”的值，这和C中null表示0不同。</p><p>建议通过<code>[]</code>来创建一个数组，下标一样从0开始。</p><p>对象的定义方式与C++类似。</p><p>变量通过<code>var</code>来声明，因其类型不固定，因而这种语言称为<code>动态语言</code></p><p>为了显示变量的值，可以使用语句<code>console.log(variable)</code></p><p>如果没有使用<code>`var</code>来声明一个变量，那么它就会成为一个全局变量。可以通过<code>&#39;use strict&#39;</code>来强制加上<code>var</code>关键字。</p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>可以通过<code>&#39;\x41&#39;</code>十六进制地表示一个字符，通过<code>\u4e2d</code>表示一个unicode字符。</p><p>在输入多行字符串的时候为了避免较多<code>&#39;\n&#39;</code>带来的麻烦，可以使用<code>` </code>来表示多行字符串。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">`多</span></span><br><span class="line"><span class="string">行</span></span><br><span class="line"><span class="string">字符串`</span>;</span><br></pre></td></tr></table></figure><p>众所周知C++可以使用<code>+</code>来连接若干个string，js更进一步可以使用<code>模版字符串</code>来连接字符串。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;rqdmap&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> age = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> mes = <span class="string">`Hello <span class="subst">$&#123;name&#125;</span>, you are <span class="subst">$&#123;age&#125;</span> years old`</span>;</span><br><span class="line"><span class="built_in">console</span>.log(mes);</span><br></pre></td></tr></table></figure><p>必须使用<code>` </code>，使用<code>&#39;</code>和<code>&quot;</code>均无法成功显示字符串的原本信息。</p><p>通过<code>s.length</code>来获得字符串的长度。</p><p>通过下标可以进行随机访问字符串的任意位置，但需要注意<strong>越界访问不会报错，只会返回undefined</strong></p><p>js中的字符串是不可通过索引值进行改变的 <del>大概是因为C++直接操作地址而这里不知道实现了什么别的结构</del></p><p>但是可以通过再次赋值改变整个字符串的值。</p><p><strong>常用的一些操作方法</strong></p><p>toUpperCase()</p><p>toLowerCase()</p><p>indexOf(“xxxx”): 搜索子串在主串中的位置，如果没有搜索到返回-1</p><p>substring(int a): 从索引a开始到字符串结束</p><p>substring(int a, int b): 返回子串<code>[s[a], s[b])</code></p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>js中的数组元素可以是不同类型，通过索引进行访问。</p><p>直接给<code>array.length</code>进行赋值会导致数组的长度发生变化。</p><p>可以通过索引值改变数组的某个元素。</p><p><del>至此可以推断出js中的字符串不是<code>字符的数组</code>，而是一个基本的类型</del></p><p>如果越界赋值也会导致数组的长度发生改变。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">arr[<span class="number">5</span>] = <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line">arr; <span class="comment">// arr变为[1, 2, 3, undefined, undefined, &#x27;x&#x27;]</span></span><br></pre></td></tr></table></figure><p><del>这种特性不知道是好是坏</del></p><p><strong>常用操作</strong></p><p>indeOf: 与string中的indexOf类似</p><p>slice: 与substring类似；如果不给slice传任何参数，就会整个截取该数组，据此可以很容易的完成数组的复制。</p><p>push/pop: 对数组的结尾进行添/删元素</p><p>unshift/shift：对数组的头部进行添/删元素</p><p>push和unshift可以一次添加若干个元素，而pop和shift只能删去一个元素；如果空数组继续删除，不会报错而会返回undefined.</p><p>sort: 按默认顺序排序</p><p>reverse: 反转</p><p><strong>splice</strong>: 从指定的索引删除若干元素，然后再从该位置加入若干元素。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;Microsoft&#x27;</span>, <span class="string">&#x27;Apple&#x27;</span>, <span class="string">&#x27;Yahoo&#x27;</span>, <span class="string">&#x27;AOL&#x27;</span>, <span class="string">&#x27;Excite&#x27;</span>, <span class="string">&#x27;Oracle&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从索引2开始删除3个元素,然后再添加两个元素:</span></span><br><span class="line">arr.splice(<span class="number">2</span>, <span class="number">3</span>, <span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;Facebook&#x27;</span>); <span class="comment">// 返回删除的元素 [&#x27;Yahoo&#x27;, &#x27;AOL&#x27;, &#x27;Excite&#x27;]</span></span><br><span class="line">arr; <span class="comment">// [&#x27;Microsoft&#x27;, &#x27;Apple&#x27;, &#x27;Google&#x27;, &#x27;Facebook&#x27;, &#x27;Oracle&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 只删除,不添加:</span></span><br><span class="line">arr.splice(<span class="number">2</span>, <span class="number">2</span>); <span class="comment">// [&#x27;Google&#x27;, &#x27;Facebook&#x27;]</span></span><br><span class="line">arr; <span class="comment">// [&#x27;Microsoft&#x27;, &#x27;Apple&#x27;, &#x27;Oracle&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 只添加,不删除:</span></span><br><span class="line">arr.splice(<span class="number">2</span>, <span class="number">0</span>, <span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;Facebook&#x27;</span>); <span class="comment">// 返回[],因为没有删除任何元素</span></span><br><span class="line">arr; <span class="comment">// [&#x27;Microsoft&#x27;, &#x27;Apple&#x27;, &#x27;Google&#x27;, &#x27;Facebook&#x27;, &#x27;Oracle&#x27;]</span></span><br></pre></td></tr></table></figure><p>concat: 数组拼接</p><p>concat可以接受任意多个元素，并且将接收到的array不断拆开、将其元素拼接入原数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>];</span><br><span class="line">arr.concat(<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]); <span class="comment">// [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, 1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure><p>join：将数组的每个元素用指定的字符串进行连接，如果元素不是字符串则会先自动将其转换成字符串。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">arr.join(<span class="string">&#x27;-&#x27;</span>); <span class="comment">// &#x27;A-B-C-1-2-3&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>JavaScript的对象是一种无序的集合数据类型，它由若干键值对组成。</p><p>如果某个属性名中含有特殊字符，可以通过<code>object[&#39;属性名&#39;]</code>来进行访问；当然建议按照规范进行命名，这样就可以直接通过<code>.</code>操作符进行访问了。</p><p>类似的，如果访问一个不存在的属性，那么会返回undefined.</p><p>由于js的对象是动态属性，所以可以很容易为一个对象增添/删除属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;小明&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line">xiaoming.age; <span class="comment">// undefined</span></span><br><span class="line">xiaoming.age = <span class="number">18</span>; <span class="comment">// 新增一个age属性</span></span><br><span class="line">xiaoming.age; <span class="comment">// 18</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> xiaoming.age; <span class="comment">// 删除age属性</span></span><br><span class="line">xiaoming.age; <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> xiaoming[<span class="string">&#x27;name&#x27;</span>]; <span class="comment">// 删除name属性</span></span><br><span class="line">xiaoming.name; <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> xiaoming.school; <span class="comment">// 删除一个不存在的school属性也不会报错</span></span><br></pre></td></tr></table></figure><p>可以使用<code>in</code>来判断一个属性是否在一个对象中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;小明&#x27;</span>,</span><br><span class="line">    <span class="attr">birth</span>: <span class="number">1990</span>,</span><br><span class="line">    <span class="attr">school</span>: <span class="string">&#x27;No.1 Middle School&#x27;</span>,</span><br><span class="line">    <span class="attr">height</span>: <span class="number">1.70</span>,</span><br><span class="line">    <span class="attr">weight</span>: <span class="number">65</span>,</span><br><span class="line">    <span class="attr">score</span>: <span class="literal">null</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="string">&#x27;name&#x27;</span> <span class="keyword">in</span> xiaoming; <span class="comment">// true</span></span><br><span class="line"><span class="string">&#x27;grade&#x27;</span> <span class="keyword">in</span> xiaoming; <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>不过in也会判断那些继承来的属性，为了判断对象自身所拥有的属性，可以使用<code>hasOwnProperty()</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;小明&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line">xiaoming.hasOwnProperty(<span class="string">&#x27;name&#x27;</span>); <span class="comment">// true</span></span><br><span class="line">xiaoming.hasOwnProperty(<span class="string">&#x27;toString&#x27;</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h2 id="语句结构"><a href="#语句结构" class="headerlink" title="语句结构"></a>语句结构</h2><p>在<code>if</code>语句中，js把<code>null</code>, <code>undefined</code>, <code>0</code>, <code>NaN</code>和<code>&#39;&#39;</code>视为false，其余均视为true</p><p>循环语句结构与C++类似，可以在for语句初始化值的位置定义变量，也可以使用自增自减运算符，也可以使用<code>+=</code>系列运算符。</p><p>类似于C++的范围for语句，js有for in语句，用于将对象、数组的<code>属性</code>全部列出来：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Jack&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">20</span>,</span><br><span class="line">    <span class="attr">city</span>: <span class="string">&#x27;Beijing&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> o) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key); <span class="comment">// &#x27;name&#x27;, &#x27;age&#x27;, &#x27;city&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果想要过滤掉父类的属性，可以在循环后面加一句<code>o.hasOwnProperty(key)</code>的判断语句。</p><p><strong>对array进行<code>for in</code>循环时，数组的索引被认为是其属性，循环得到的不是<code>number</code>而是<code>string</code>！</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> a) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i); <span class="comment">// &#x27;0&#x27;, &#x27;1&#x27;, &#x27;2&#x27;</span></span><br><span class="line">    <span class="built_in">console</span>.log(a[i]); <span class="comment">// &#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Map与Set"><a href="#Map与Set" class="headerlink" title="Map与Set"></a>Map与Set</h2><p>有两种方法对Map进行初始化</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//利用二维数组初始化一个Map</span></span><br><span class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">&#x27;Michael&#x27;</span>, <span class="number">95</span>], [<span class="string">&#x27;Bob&#x27;</span>, <span class="number">75</span>], [<span class="string">&#x27;Tracy&#x27;</span>, <span class="number">85</span>]]);</span><br><span class="line">m.get(<span class="string">&#x27;Michael&#x27;</span>); <span class="comment">// 95</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//也可以初始化一个空Map，然后利用以下方法添加元素。</span></span><br><span class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>(); <span class="comment">// 空Map</span></span><br><span class="line">m.set(<span class="string">&#x27;Adam&#x27;</span>, <span class="number">67</span>); <span class="comment">// 添加新的key-value</span></span><br><span class="line">m.set(<span class="string">&#x27;Bob&#x27;</span>, <span class="number">59</span>);</span><br><span class="line">m.has(<span class="string">&#x27;Adam&#x27;</span>); <span class="comment">// 是否存在key &#x27;Adam&#x27;: true</span></span><br><span class="line">m.get(<span class="string">&#x27;Adam&#x27;</span>); <span class="comment">// 67</span></span><br><span class="line">m.delete(<span class="string">&#x27;Adam&#x27;</span>); <span class="comment">// 删除key &#x27;Adam&#x27;</span></span><br><span class="line">m.get(<span class="string">&#x27;Adam&#x27;</span>); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>一个键只能对应一个值，所以多次对一个键赋值会覆盖掉之前的值。</p><p>类似地，可以初始化一个空Set或者用一维数组初始化一个Set。重复元素自动被删除。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line">s.add(<span class="number">4</span>);</span><br><span class="line">s; <span class="comment">// Set &#123;1, 2, 3, 4&#125;</span></span><br><span class="line">s.add(<span class="number">4</span>);</span><br><span class="line">s; <span class="comment">// 仍然是 Set &#123;1, 2, 3, 4&#125;</span></span><br><span class="line">s.delete(<span class="number">4</span>);</span><br><span class="line">s; <span class="comment">// Set&#123;1, 2, 3&#125;</span></span><br></pre></td></tr></table></figure><h2 id="iterable"><a href="#iterable" class="headerlink" title="iterable"></a>iterable</h2><p>通过<code>for ... of ...</code>循环可以遍历具有<code>iterable</code>类型的集合。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>];</span><br><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>]);</span><br><span class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="number">1</span>, <span class="string">&#x27;x&#x27;</span>], [<span class="number">2</span>, <span class="string">&#x27;y&#x27;</span>], [<span class="number">3</span>, <span class="string">&#x27;z&#x27;</span>]]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> x <span class="keyword">of</span> a) &#123; <span class="comment">// 遍历Array</span></span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> x <span class="keyword">of</span> s) &#123; <span class="comment">// 遍历Set</span></span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> x <span class="keyword">of</span> m) &#123; <span class="comment">// 遍历Map</span></span><br><span class="line">    <span class="built_in">console</span>.log(x[<span class="number">0</span>] + <span class="string">&#x27;=&#x27;</span> + x[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而以往的<code>for in</code>就无法遍历set和map。</p><p><strong><code>for in</code>循环访问的是对象的属性，而<code>for of</code>只循环集合本身的元素。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>];</span><br><span class="line">a.name = <span class="string">&#x27;Hello&#x27;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> x <span class="keyword">in</span> a) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x); <span class="comment">// &#x27;0&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;name&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>];</span><br><span class="line">a.name = <span class="string">&#x27;Hello&#x27;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> x <span class="keyword">of</span> a) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x); <span class="comment">// &#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h2><p>不同于C++，js中函数不定义返回值类型，直接用function进行定义即可。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">abs</span>(<span class="params">a</span>)</span>&#123;<span class="keyword">return</span> a &lt; <span class="number">0</span>? -a: a;&#125;</span><br></pre></td></tr></table></figure><p>如果函数没有返回值，那么该函数也会返回undefined.</p><p>此外，js中函数也是一个对象，所以可以使用以下的匿名函数定义一个函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> abs = <span class="function"><span class="keyword">function</span>(<span class="params">a</span>)</span>&#123;<span class="keyword">return</span> a &lt; <span class="number">0</span>? -a: a;&#125;;</span><br></pre></td></tr></table></figure><p>不过由于第二种方法是赋值语句，所以记得加上<code>;</code></p><h2 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h2><p>js传入参数的数量不被严格的限制：如果多于需要的数量，那么多余的将不会被使用；如果少于需要的数量，函数中的参数会收到<code>undefined</code>。</p><p>有一种方法可以判断是否收到<code>undefined</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> abs = <span class="function"><span class="keyword">function</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> a !== <span class="string">&#x27;number&#x27;</span>) <span class="keyword">throw</span> <span class="string">&#x27;Not a number&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> a &lt; <span class="number">0</span>? -a: a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在函数内部可以使用<strong><code>arguments</code></strong>来指向所有的传入参数，argument也有属性<code>length</code>，可以用length来判断传入的参数是否足够。</p><p>如果传入的参数过多，可以使用ES6标准引入的<code>rest</code>参数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a, b, ...rest</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;a = &#x27;</span> + a);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;b = &#x27;</span> + b);</span><br><span class="line">    <span class="built_in">console</span>.log(rest);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"><span class="comment">// 结果:</span></span><br><span class="line"><span class="comment">// a = 1</span></span><br><span class="line"><span class="comment">// b = 2</span></span><br><span class="line"><span class="comment">// Array [ 3, 4, 5 ]</span></span><br><span class="line"></span><br><span class="line">foo(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 结果:</span></span><br><span class="line"><span class="comment">// a = 1</span></span><br><span class="line"><span class="comment">// b = undefined</span></span><br><span class="line"><span class="comment">// Array []</span></span><br></pre></td></tr></table></figure><p>rest必须写在最后，并用<code>...</code>标示。</p><p>js会自动在行末添加分号，所以要注意return和其返回值不要换行分隔。</p><h3 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h3><p>打开<code>&#39;use strict&#39;</code>后就禁止不加var声明变量，那么var变量作用域只在当前函数内。</p><p>如果嵌套的内层函数有与外层同名的变量，与C++一样的覆盖规则是成立的。</p><h4 id=""><a href="#" class="headerlink" title=" "></a> </h4><p>JS在函数中有<strong>变量提升</strong>这一特性，在运行函数前扫描整个函数，将变量的声明提升到函数的最前面。</p><p><del>所以可以写一些快乐的毒瘤代码</del></p><p>如果不在任何函数内声明一个变量，那么该变量就是全局变量。全局变量被绑定在了JS默认的一个全局对象<code>window</code>的属性上。因而可以通过<code>window.</code>来访问一个全局变量。</p><p>当多个文件同时工作时，为了避免全局变量命名的冲突，可以将所有的全局变量绑定在一个全局变量上，这样就可以实现“命名空间“的工作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 唯一的全局变量MYAPP:</span></span><br><span class="line"><span class="keyword">var</span> MYAPP = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其他变量:</span></span><br><span class="line">MYAPP.name = <span class="string">&#x27;myapp&#x27;</span>;</span><br><span class="line">MYAPP.version = <span class="number">1.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其他函数:</span></span><br><span class="line">MYAPP.foo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>事实上，因为函数内的变量会被提升到首部，所以如下的C++风格代码并不能完成它本来想完成的功能：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">      <span class="comment">//do something;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为此，ES6引入新的关键字<code>let</code>,可以声明一个块级作用域的变量，利用let关键字就可以完成上述的操作了。</p><p>ES6也引入了<code>const</code>来声名一个常量。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> pi = <span class="number">3.14</span>;</span><br></pre></td></tr></table></figure><h3 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h3><p>这是ES6引入的一种可以对多个变量同时赋值的语法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//直接对三个变量进行赋值</span></span><br><span class="line"><span class="keyword">var</span> [x, y, z] = [<span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;JavaScript&#x27;</span>, <span class="string">&#x27;ES6&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果右值有嵌套，那么多个变量之间也要保持格式一致。</span></span><br><span class="line"><span class="keyword">let</span> [x, [y, z]] = [<span class="string">&#x27;hello&#x27;</span>, [<span class="string">&#x27;JavaScript&#x27;</span>, <span class="string">&#x27;ES6&#x27;</span>]];</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以忽略掉某些元素</span></span><br><span class="line"><span class="keyword">let</span> [, , z] = [<span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;JavaScript&#x27;</span>, <span class="string">&#x27;ES6&#x27;</span>]; </span><br></pre></td></tr></table></figure><p>也可以从一个对象中抽取出若干属性进行赋值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;小明&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">20</span>,</span><br><span class="line">    <span class="attr">gender</span>: <span class="string">&#x27;male&#x27;</span>,</span><br><span class="line">    <span class="attr">passport</span>: <span class="string">&#x27;G-12345678&#x27;</span>,</span><br><span class="line">    <span class="attr">school</span>: <span class="string">&#x27;No.4 middle school&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> &#123;name, age, passport&#125; = person;</span><br></pre></td></tr></table></figure><p>如果使用了不存在的属性名将会获得<code>undefined</code></p><p>可以通过如下语句将某属性的值赋值到另一个名称的属性上</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;name, <span class="attr">passport</span>:id&#125; = person;</span><br></pre></td></tr></table></figure><p>解构赋值也可以设置默认值，避免产生<code>undefined</code>的问题</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;小明&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">20</span>,</span><br><span class="line">    <span class="attr">gender</span>: <span class="string">&#x27;male&#x27;</span>,</span><br><span class="line">    <span class="attr">passport</span>: <span class="string">&#x27;G-12345678&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果person对象没有single属性，默认赋值为true:</span></span><br><span class="line"><span class="keyword">var</span> &#123;name, single = <span class="literal">true</span>&#125; = person;</span><br></pre></td></tr></table></figure><p>如果想要对已经声明过的变量做解构赋值，需采用如下形式<del>我也不知道为什么</del></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(&#123;x, y&#125; = &#123; <span class="attr">name</span>: <span class="string">&#x27;小明&#x27;</span>, <span class="attr">x</span>: <span class="number">100</span>, <span class="attr">y</span>: <span class="number">200</span>&#125;);</span><br></pre></td></tr></table></figure><h2 id="函数方法"><a href="#函数方法" class="headerlink" title="函数方法"></a>函数方法</h2><p>在JS中可以使用如下语法定义一个对象专用的方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;小明&#x27;</span>,</span><br><span class="line">    <span class="attr">birth</span>: <span class="number">1990</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> y = <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear();</span><br><span class="line">        <span class="keyword">return</span> y - <span class="built_in">this</span>.birth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对象也可以使用一种“全局方法”。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getage</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> y = <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear();</span><br><span class="line">    <span class="keyword">return</span> y - <span class="built_in">this</span>.birth;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;小明&#x27;</span>, <span class="attr">birth</span>: <span class="number">1990</span>,</span><br><span class="line">    <span class="attr">age</span>: getage,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(xiaoming.age());</span><br></pre></td></tr></table></figure><p>好处在于可以按需使用“全局方法”，但是如果不加任何对象的调用了这个方法则会返回<code>undefined</code>。这是因为该对象默认成为<code>window</code>，方法中的this指向了window。为了解决this的正确指向问题，可以通过<code>strict</code>模式来使得这种情况下this总指向<code>undefined</code>来及时的报错避免该问题。</p><p>此外，在对象某个方法中的子方法，无法通过<code>this</code>指向原对象，只会指向<code>undefined</code>，实际使用时可以通过创建局部变量来解决。</p><p>可以利用<strong>apply</strong>方法来手动指定全局方法的this对象并给出参数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAge</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> y = <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear();</span><br><span class="line">    <span class="keyword">return</span> y - <span class="built_in">this</span>.birth;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;小明&#x27;</span>,</span><br><span class="line">    <span class="attr">birth</span>: <span class="number">1990</span>,</span><br><span class="line">    <span class="attr">age</span>: getAge</span><br><span class="line">&#125;;</span><br><span class="line">getAge.apply(xiaoming, []); <span class="comment">// 25, this指向xiaoming, 参数为空</span></span><br></pre></td></tr></table></figure><p>第一个参数为对象名，第二个参数为一个数组，其中元素为要传入给函数的参数。</p><p>方法<strong>call</strong>与apply基本类似，唯一不同的地方在于call将函数需要的参数一个个列出为形参。</p><p>利用apply可以对原函数进行加“壳”</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> oldfun = fun;</span><br><span class="line"><span class="built_in">window</span>.fun = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">//dosomething</span></span><br><span class="line">  <span class="keyword">return</span> oldfun.apply(xxx, [...])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><del>vscode可能没有配置完备，导致window.xxxx系列函数无法在vscode执行；然而切换到chrome的控制台便可以顺利执行。</del></p><blockquote><p><code>window</code> is a browser thing that doesn’t exist on Node.</p></blockquote><h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><p>高阶函数是指接受其他函数作为参量的函数。</p><p>并附上回调函数的一个解释: <strong>A “callback” is any function that is called by another function which takes the first function as a parameter.</strong> </p><h2 id="map方法"><a href="#map方法" class="headerlink" title="map方法"></a>map方法</h2><p>指定一个映射方法，通过map方法将原本的元素一一进行置换。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pow</span>(<span class="params">a</span>)</span>&#123;<span class="keyword">return</span> a * a;&#125;</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr.map(pow));</span><br><span class="line"><span class="comment">//[ 1, 4, 9, 16 ]</span></span><br></pre></td></tr></table></figure><h2 id="reduce方法"><a href="#reduce方法" class="headerlink" title="reduce方法"></a>reduce方法</h2><p>指定一个必须传入2个元素的方法，将序列前两项按照该方法做运算后的结果继续与第三个元素做运算，其后以此类推。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[x1, x2, x3, x4].reduce(f) = f(f(f(x1, x2), x3), x4)</span><br></pre></td></tr></table></figure><p>给出一些实例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>];</span><br><span class="line">arr.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;); <span class="comment">// 25</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>];</span><br><span class="line">arr.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * <span class="number">10</span> + y;</span><br><span class="line">&#125;); <span class="comment">// 13579</span></span><br></pre></td></tr></table></figure><p><del>JS中如何将字符转化为整数？</del></p><p>如果不使用parseInt系列方法：</p><ol><li><p>使用Number(c) - Number(‘0’)来类似于C++的转化为Int</p></li><li><p>通过运算符自动解析字符串为数值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;12345&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.length; i++)  arr[i] = s[i] * <span class="number">1</span>;</span><br><span class="line"><span class="comment">//[ 1, 2, 3, 4, 5 ]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.length; i++)  arr[i] = s[i] - <span class="number">0</span>;</span><br><span class="line"><span class="comment">//[ 1, 2, 3, 4, 5 ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//无法通过&#x27;+&#x27;将字符串解析为数值！</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.length; i++)  arr[i] = s[i] + <span class="number">0</span>;</span><br><span class="line"><span class="comment">//[ &#x27;10&#x27;, &#x27;20&#x27;, &#x27;30&#x27;, &#x27;40&#x27;, &#x27;50&#x27; ]</span></span><br></pre></td></tr></table></figure></li></ol><p>如果想要使用这类不是很知道实现原理的内置函数时，就可能会产生如下意想不到结果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log([<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>].map(<span class="built_in">parseInt</span>));</span><br><span class="line"><span class="comment">//[ 1, NaN, NaN ]</span></span><br></pre></td></tr></table></figure><p>这是因为<code>parseInt()</code>实际会接受两个参数，第一个是表达式字符串，第二个是基数。而在使用map传入时会将字符作为字符串表达式、序号为基数传入parstInt函数，那么就无法正确解析{‘2’, 1}和{‘3’, 2}表达式了。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>办公楼biu</title>
      <link href="/2020/09/04/%E5%8A%9E%E5%85%AC%E6%A5%BCbiu/"/>
      <url>/2020/09/04/%E5%8A%9E%E5%85%AC%E6%A5%BCbiu/</url>
      
        <content type="html"><![CDATA[<p>给出一张图，求出其补图所有联通块的个数及其大小。</p><span id="more"></span><h3 id="黑暗爆炸OJ-1098"><a href="#黑暗爆炸OJ-1098" class="headerlink" title="黑暗爆炸OJ 1098"></a><a href="https://darkbzoj.tk/problem/1098">黑暗爆炸OJ 1098</a></h3><p>容易想到$O(n^2)$的算法：对于每一个点，枚举所有邻点打上标记，然后找那些没有被打上标记的点，将这些点加入到一个联通块中。</p><p>如果使用链表，可以将复杂度优化到$O(n + m)$，非常的神奇。</p><p><del>本来是非常的神秘，后来qko学长给我讲了下就变得非常神奇了 orz</del></p><p>链表优化后的总体思路与上类似，枚举每一个点，将邻点打上标记，接下来在链表中找那些没有被标记过的点加入到联通块中。这里我们维护链表中的元素为可能成为该点所在联通块的那些元素，这意味着对于那些已经加入其他联通块或是已经被加入到当前联通块的元素不会再被考虑。每次我们将那些元素加入到联通块中后，就将他们在链表中删去，这样就可以维护上述的性质。</p><p>初看总感觉会被卡到$O(n^2)$，因为某个点如果连了很多个邻边，那么在链表中就有可能会遍历到最后一个元素才只能删掉1个元素。那么会成为$O(n^2)$吗，应该是不会的。</p><p>按照我最开始粗浅的想法是，如果点数n和边数m同阶，那么不可能会有很多这种联通性极强的点，从而On的遍历链表的次数也不会很多。不过这样的解释终归有点牵强，问了qko学长后得知了一种更优美的说明方法：考察链表中每个点被遍历过的次数。根据补图的定义，某个点最多只会被冗余遍历$O(m_i)$次，$m_i$表示i节点的边的个数。因为如果有一条不连接该点的点正在进行扩散操作，那么该点因为不与其相连，一定会将其加入到补图联通块中，之后便会在链表中删去该节点的信息。只有那些与其原本相连的点在扩散过程中才会保留这些邻点不删去。那么总共访问链表的次数显然就是$O(m)$了。</p><p>另一方面，枚举每个点进行联通块扩散的时间为$O(n)$，所以总共时间复杂度为$O(n + m)$。</p><p>orz</p><p>太巧妙了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>, maxe = <span class="number">2e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">star</span>&#123;</span><span class="keyword">int</span> to, next;&#125;;</span><br><span class="line"><span class="keyword">int</span> head[maxn], top = <span class="number">0</span>;</span><br><span class="line">star edge[maxe &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    edge[top].to = v;</span><br><span class="line">    edge[top].next = head[u];</span><br><span class="line">    head[u] = top++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">list&lt;<span class="keyword">int</span>&gt; ls;</span><br><span class="line">queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="keyword">int</span> vis[maxn];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//    Fastin;</span></span><br><span class="line">    <span class="built_in">clr</span>(head, <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m); <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> u, v; <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">        <span class="built_in">add</span>(u, v); <span class="built_in">add</span>(v, u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) ls.<span class="built_in">push_back</span>(i);</span><br><span class="line">    <span class="keyword">while</span>(!ls.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        q.<span class="built_in">push</span>(ls.<span class="built_in">front</span>()); ls.<span class="built_in">pop_front</span>();</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">int</span> now = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>(); cnt++;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = head[now]; ~i; i = edge[i].next)&#123;</span><br><span class="line">                <span class="keyword">int</span> to = edge[i].to;</span><br><span class="line">                vis[to] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            list&lt;<span class="keyword">int</span>&gt;::iterator it = ls.<span class="built_in">begin</span>();</span><br><span class="line">            <span class="keyword">while</span>(it != ls.<span class="built_in">end</span>())&#123;</span><br><span class="line">                <span class="keyword">if</span>(vis[*it])&#123;vis[*it] = <span class="number">0</span>; it++;&#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;q.<span class="built_in">push</span>(*it); ls.<span class="built_in">erase</span>(it++);&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(cnt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> top = (<span class="keyword">int</span>)ans.<span class="built_in">size</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, top);</span><br><span class="line">    <span class="built_in">sort</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; top; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, ans[i]);</span><br><span class="line">        <span class="built_in">printf</span>(i != top - <span class="number">1</span>? <span class="string">&quot; &quot;</span>: <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图论 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>24point</title>
      <link href="/2020/09/02/24point/"/>
      <url>/2020/09/02/24point/</url>
      
        <content type="html"><![CDATA[<p>24点小游戏~</p><span id="more"></span><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line">      </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;random&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line">     </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line">      </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> itn int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fro for</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> scnaf scanf</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sacnf scanf</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> manx maxn</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pritnf printf</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Fastin freopen(<span class="meta-string">&quot;in.txt&quot;</span>, <span class="meta-string">&quot;r&quot;</span>, stdin)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Fastout freopen(<span class="meta-string">&quot;out.txt&quot;</span>, <span class="meta-string">&quot;w&quot;</span>, stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> min(a, b) ((a) &lt; (b)? (a): (b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> max(a, b) ((a) &gt; (b)? (a): (b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) ((x) &amp; (-x))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ceil(n, p) (((n) +(p) - 1) / (p))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DBG(x) (void)(cout &lt;&lt; <span class="meta-string">&quot;L&quot;</span> &lt;&lt; __LINE__ &lt;&lt; <span class="meta-string">&quot;: &quot;</span> &lt;&lt; #x &lt;&lt; <span class="meta-string">&quot; = &quot;</span> &lt;&lt;( x) &lt;&lt; <span class="meta-string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clr(a, x) memset((a), x, sizeof (a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TTT int __; scanf(<span class="meta-string">&quot;%d&quot;</span>, &amp;__); while(__--)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">5</span>], b[<span class="number">5</span>], p[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NODE</span>&#123;</span></span><br><span class="line">    string s; <span class="keyword">double</span> w;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> NODE&amp; b)<span class="keyword">const</span>&#123;<span class="keyword">return</span> s &lt; b.s;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">set&lt;NODE&gt; s[<span class="number">5</span>][<span class="number">5</span>];</span><br><span class="line"><span class="comment">//处理[left, right]的值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sove</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left &gt; right) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span>(left == right)&#123;</span><br><span class="line">        NODE temp;</span><br><span class="line">        temp.s = <span class="built_in">to_string</span>(a[left]); temp.w = a[left];</span><br><span class="line">        s[left][right].<span class="built_in">insert</span>(temp);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = left; i &lt;= right - <span class="number">1</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">sove</span>(left, i); <span class="built_in">sove</span>(i + <span class="number">1</span>, right);</span><br><span class="line">        NODE temp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x: s[left][i]) <span class="keyword">for</span>(<span class="keyword">auto</span> y: s[i + <span class="number">1</span>][right])&#123;</span><br><span class="line">            temp.s = x.s; <span class="keyword">if</span>(left != i) temp.s = <span class="string">&quot;(&quot;</span> + temp.s + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">            temp.s += <span class="string">&quot;+&quot;</span>; temp.w = x.w + y.w;</span><br><span class="line">            <span class="keyword">if</span>(i + <span class="number">1</span> != right) temp.s += <span class="string">&quot;(&quot;</span> + y.s + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">            <span class="keyword">else</span> temp.s += y.s;</span><br><span class="line">            s[left][right].<span class="built_in">insert</span>(temp);</span><br><span class="line">            </span><br><span class="line">            temp.s = x.s; <span class="keyword">if</span>(left != i) temp.s = <span class="string">&quot;(&quot;</span> + temp.s + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">            temp.s += <span class="string">&quot;-&quot;</span>; temp.w = x.w - y.w;</span><br><span class="line">            <span class="keyword">if</span>(i + <span class="number">1</span> != right) temp.s += <span class="string">&quot;(&quot;</span> + y.s + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">            <span class="keyword">else</span> temp.s += y.s;</span><br><span class="line">            s[left][right].<span class="built_in">insert</span>(temp);</span><br><span class="line">            </span><br><span class="line">            temp.s = x.s; <span class="keyword">if</span>(left != i) temp.s = <span class="string">&quot;(&quot;</span> + temp.s + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">            temp.s += <span class="string">&quot;*&quot;</span>; temp.w = x.w * y.w;</span><br><span class="line">            <span class="keyword">if</span>(i + <span class="number">1</span> != right) temp.s += <span class="string">&quot;(&quot;</span> + y.s + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">            <span class="keyword">else</span> temp.s += y.s;</span><br><span class="line">            s[left][right].<span class="built_in">insert</span>(temp);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(y.w == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            temp.s = x.s; <span class="keyword">if</span>(left != i) temp.s = <span class="string">&quot;(&quot;</span> + temp.s + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">            temp.s += <span class="string">&quot;/&quot;</span>; temp.w = x.w / y.w;</span><br><span class="line">            <span class="keyword">if</span>(i + <span class="number">1</span> != right) temp.s += <span class="string">&quot;(&quot;</span> + y.s + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">            <span class="keyword">else</span> temp.s += y.s;</span><br><span class="line">            s[left][right].<span class="built_in">insert</span>(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line">set&lt;string&gt; ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//    Fastin;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">4</span>; i++) <span class="built_in">scnaf</span>(<span class="string">&quot;%d&quot;</span>, b + i);</span><br><span class="line">    p[<span class="number">1</span>] = <span class="number">1</span>; p[<span class="number">2</span>] = <span class="number">2</span>; p[<span class="number">3</span>] = <span class="number">3</span>; p[<span class="number">4</span>] = <span class="number">4</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++) s[i][j].<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">4</span>; i++) a[i] = b[p[i]];</span><br><span class="line">        <span class="built_in">sove</span>(<span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x: s[<span class="number">1</span>][<span class="number">4</span>]) <span class="keyword">if</span>(<span class="built_in">abs</span>(x.w - <span class="number">24</span>) &lt;= eps)&#123;</span><br><span class="line">            ans.<span class="built_in">insert</span>(x.s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">while</span>(<span class="built_in">next_permutation</span>(p + <span class="number">1</span>, p + <span class="number">5</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(ans.<span class="built_in">empty</span>()) <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">for</span>(<span class="keyword">auto</span> s: ans) cout &lt;&lt; s &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Search </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019-XDU-onsite</title>
      <link href="/2020/09/02/2019-XDU-onsite/"/>
      <url>/2020/09/02/2019-XDU-onsite/</url>
      
        <content type="html"><![CDATA[<p>1427 qko的宝可梦 （已补）</p><p>1428 qko的串</p><p>1429 qko的进化公式</p><p>1430 qko的树</p><span id="more"></span><p>[toc]</p><h2 id="1427-set对有序链的维护"><a href="#1427-set对有序链的维护" class="headerlink" title="1427 set对有序链的维护"></a>1427 set对有序链的维护</h2><p>set中每个节点拥有最小攻击力和最大攻击力，保证set中一定满足严格的偏序关系，即保证两个元素之间一定有某元素的最大值全部小于另一个元素的最小值。</p><p>初始将1号宝可梦插入到set中，然后遍历2-n宝可梦，通过lower_bound和upper_bound来获得set中“相等“的那些元素。这里的相等意味着不存在严格的偏序关系，那么也就意味着两者互相可以击败，从而这些元素都可以与第i个元素互相可达，应该合并成一个SCC。遍历所有这些相等的元素，将信息进行不断合并，最后将新元素再插入到set中，这样就可以保证set中的严格偏序关系，输出结果时将最后一个元素的个数输出即可。</p><p>算法非常精妙，由其是利用set进行合并和查询的操作值得学习！</p><p><del>原来set可以用lower/upper_bound来进行二分，之前我还在苦恼地想怎么才能在set中进行二分，orz</del></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> manx = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[maxn][<span class="number">15</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NODE</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> m[<span class="number">10</span>], M[<span class="number">10</span>], size;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (NODE <span class="keyword">const</span> &amp;b)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) <span class="keyword">if</span>(M[i] &gt; b.m[i]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;node[maxn];</span><br><span class="line">set&lt;NODE&gt; s;</span><br><span class="line">set&lt;NODE&gt;::iterator p, q, it;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//    Fastin;</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; j++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, node[i].m + j); node[i].size = <span class="number">1</span>;</span><br><span class="line">        node[i].M[j] = node[i].m[j];</span><br><span class="line">    &#125;</span><br><span class="line">    s.<span class="built_in">insert</span>(node[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">        NODE temp = node[i];</span><br><span class="line">        p = s.<span class="built_in">lower_bound</span>(temp);</span><br><span class="line">        q = s.<span class="built_in">upper_bound</span>(temp);</span><br><span class="line">        it = p;</span><br><span class="line">        <span class="keyword">while</span>(it != q)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)&#123;</span><br><span class="line">                temp.m[i] = <span class="built_in">min</span>(temp.m[i], it-&gt;m[i]);</span><br><span class="line">                temp.M[i] = <span class="built_in">max</span>(temp.M[i], it-&gt;M[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            temp.size += it-&gt;size;</span><br><span class="line">            s.<span class="built_in">erase</span>(it++);</span><br><span class="line">        &#125;</span><br><span class="line">        s.<span class="built_in">insert</span>(temp);</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, s.<span class="built_in">rbegin</span>()-&gt;size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> set </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020-牛客多校-10</title>
      <link href="/2020/08/25/2020-%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A1-10/"/>
      <url>/2020/08/25/2020-%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A1-10/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><span id="more"></span><h3 id="C-思维-amp-树"><a href="#C-思维-amp-树" class="headerlink" title="C 思维 &amp; 树"></a>C 思维 &amp; 树</h3><h4 id="C-Namomo-2C"><a href="#C-Namomo-2C" class="headerlink" title="C* Namomo 2C"></a>C* <a href="https://namomo.top:8081/contest/2/problem/C">Namomo 2C</a></h4><p>区间减1，代价为长度的平方，问将区间操作为全0的最小代价和最大代价。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line">      </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;random&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line">     </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line">      </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> itn int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fro for</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> scnaf scanf</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sacnf scanf</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Fastin freopen(<span class="meta-string">&quot;in.txt&quot;</span>, <span class="meta-string">&quot;r&quot;</span>, stdin)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Fastout freopen(<span class="meta-string">&quot;out.txt&quot;</span>, <span class="meta-string">&quot;w&quot;</span>, stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> manx maxn</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) ((x) &amp; (-x))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ceil(n, p) (((n) +(p) - 1) / (p))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DBG(x) (void)(cout &lt;&lt; <span class="meta-string">&quot;L&quot;</span> &lt;&lt; __LINE__ &lt;&lt; <span class="meta-string">&quot;: &quot;</span> &lt;&lt; #x &lt;&lt; <span class="meta-string">&quot; = &quot;</span> &lt;&lt;( x) &lt;&lt; <span class="meta-string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clr(a, x) memset((a), x, sizeof (a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> min(a, b) ((a) &lt; (b)? (a): (b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> max(a, b) ((a) &gt; (b)? (a): (b))</span></span><br><span class="line">     </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">     </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> ng=<span class="number">0</span>,x=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">   <span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span> || ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) ng|=ch==<span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">   <span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span> &amp;&amp; ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+ch-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">   <span class="keyword">return</span> ng?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*------------------------------------------------------------------------------------*/</span></span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll x, ll y)</span></span>&#123;<span class="keyword">return</span> !x? y: <span class="built_in">gcd</span>(y % x, x);&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exgcd</span><span class="params">(ll a, ll b, ll &amp;x, ll &amp;y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!b)&#123;x = <span class="number">1</span>; y = <span class="number">0</span>;<span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="built_in">exgcd</span>(b, a % b, y, x); y -= a / b * x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">qp</span><span class="params">(ll a, ll p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    ll ans = <span class="number">1</span>; <span class="keyword">while</span>(p)&#123;<span class="keyword">if</span>(p &amp; <span class="number">1</span>) ans = ans * a ; a = a * a; p &gt;&gt;= <span class="number">1</span>;&#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">qp</span><span class="params">(ll a, ll p, ll M)</span></span>&#123;</span><br><span class="line">    ll ans = <span class="number">1</span>; <span class="keyword">while</span>(p)&#123; <span class="keyword">if</span>(p &amp; <span class="number">1</span>) ans = ans * a % M; a = a * a % M; p &gt;&gt;= <span class="number">1</span>;&#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*------------------------------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">5e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn], b[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">cal</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;<span class="keyword">return</span> (r - l) * <span class="number">1ll</span> * (r - l) % M;&#125;</span><br><span class="line"></span><br><span class="line">stack&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; sta;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//    Fastin;</span></span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">scnaf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, a + i); a[n + <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + <span class="number">1</span>; i++) b[i] = a[i] - a[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span>(b[n + <span class="number">1</span>] == <span class="number">0</span>) n--;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">1</span>, q = <span class="number">1</span>; <span class="keyword">while</span>(b[q] &gt;= <span class="number">0</span>) q++;</span><br><span class="line">    <span class="keyword">while</span>(p &lt;= n + <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b[p] + b[q] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            ans += -b[q] * <span class="built_in">cal</span>(p, q); ans %= M;</span><br><span class="line">            b[p] += b[q];</span><br><span class="line">            q++; <span class="keyword">while</span>(q &lt;= n + <span class="number">1</span> &amp;&amp; b[q] &gt;= <span class="number">0</span>) q++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(b[p] + b[q] == <span class="number">0</span>)&#123;</span><br><span class="line">            ans += b[p] * <span class="built_in">cal</span>(p, q); ans %= M;</span><br><span class="line">            p++; q++; <span class="keyword">while</span>(p &lt;= n + <span class="number">1</span> &amp;&amp; b[p] &lt; <span class="number">0</span>) p++; <span class="keyword">while</span>(q &lt;= n + <span class="number">1</span> &amp;&amp; b[q] &gt;= <span class="number">0</span>) q++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            ans += b[p] * <span class="built_in">cal</span>(p, q); ans %= M;</span><br><span class="line">            b[q] += b[p];</span><br><span class="line">            p++; <span class="keyword">while</span>(p &lt;= n + <span class="number">1</span> &amp;&amp; b[p] &lt; <span class="number">0</span>) p++;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>, ans % M);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + <span class="number">1</span>; i++) b[i] = a[i] - a[i - <span class="number">1</span>];</span><br><span class="line">    ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + <span class="number">1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b[i] &gt; <span class="number">0</span>) sta.<span class="built_in">push</span>(&#123;i, b[i]&#125;);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(b[i] &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">                pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; now = sta.<span class="built_in">top</span>(); sta.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(now.second + b[i] &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                    ans += now.second * <span class="built_in">cal</span>(now.first, i); ans %= M;</span><br><span class="line">                    b[i] += now.second;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    ans += -b[i] * <span class="built_in">cal</span>(now.first, i); ans %= M;</span><br><span class="line">                    now.second += b[i];</span><br><span class="line">                    sta.<span class="built_in">push</span>(now);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="I-构造"><a href="#I-构造" class="headerlink" title="I 构造"></a>I 构造</h3><p><del>虽然感觉还是说不太清楚qaq</del></p><p>假设当前将要引入第i个人进入比赛，考虑在最优的构造下，之前在场的$i - 1$个人中<strong>最多</strong>有多少个人可以与第i人比赛。如果已有$j-1$个人跟i人比过赛，第j人将要跟i人比赛，则这次对决对于那些已经比过赛的$j-1$人没有任何意义，这些人最终都会因此多等待一天；而如果j人不与i人比赛，那么下一轮操作(<strong>最多</strong>意味着不会再考虑$j + 1$人的情况)就是引入第$i+1$人，这也就说明如果这次不比赛，之后尚未引入的$n-i$个人的进场时间都会提前一天。那么我们比较两个时间，如果$j - 1&lt; n - i$，就选择比赛，不然则不比赛。可以直接顺序将j从1到i -1进行枚举考虑，原因非常神秘，我感觉我可能不太理解。当上述过程重复操作完成后，将那些没有比过的赛再全部安排上即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">3e2</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">bool</span> vis[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Fastin;</span><br><span class="line">    TTT&#123;</span><br><span class="line">        <span class="built_in">clr</span>(vis, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; j++) <span class="keyword">if</span>(j - <span class="number">1</span> &lt; n - i)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, j, i);</span><br><span class="line">            vis[j][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n; j++) <span class="keyword">if</span>(!vis[i][j])</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, i, j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 构造 </tag>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020-hdu多校-3</title>
      <link href="/2020/07/28/2020-hdu%E5%A4%9A%E6%A0%A1-3/"/>
      <url>/2020/07/28/2020-hdu%E5%A4%9A%E6%A0%A1-3/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><span id="more"></span><h2 id="1004-前缀和dp"><a href="#1004-前缀和dp" class="headerlink" title="1004 前缀和dp"></a>1004 前缀和dp</h2><p>预处理出前缀和，前缀和相同的两个点之间就可以合并成一个满足条件的数。</p><p>从后往前利用前缀和即可dp处理出最多的个数。</p><h2 id="1009-模拟括号匹配"><a href="#1009-模拟括号匹配" class="headerlink" title="1009 模拟括号匹配"></a>1009 模拟括号匹配</h2><p>出现未配对的右括号就用最左边的<code>*</code>去匹配，出现未配对的左括号就用最右边的<code>*</code>去匹配。</p><p><del>差不多是这样</del></p><h2 id="1005-并查集-amp-计数"><a href="#1005-并查集-amp-计数" class="headerlink" title="1005 并查集&amp;计数"></a>1005 并查集&amp;计数</h2><p>先统计一下所有点集在无边时的ans值，然后每连两个联通块，就将这两个联通块之间之前会产生的贡献全部减去即可。</p><p>两个联通块可能产生的情况有：</p><ul><li><p>1号贡献一个1，2号贡献一个2，在剩余其他所有点中找一个2</p></li><li><p>1号贡献一个2，2号贡献一个1，在剩余其他所有点中找一个2</p></li><li><p>1号贡献一个2，2号贡献一个2，在剩余点中随意找一个</p></li></ul><p>那么随便搞一下就行了。</p><p><del>注意不要爆int 我是sb我是sb我是sb…</del></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> itn maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> par[maxn];</span><br><span class="line">ll cnt2[maxn], cnt1[maxn], s1, s2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> x == par[x]? x: par[x] = <span class="built_in">find</span>(par[x]);&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r1 = <span class="built_in">find</span>(x), r2 = <span class="built_in">find</span>(y);</span><br><span class="line">    <span class="built_in">assert</span>(r1 != r2);</span><br><span class="line">    par[r2] = r1;</span><br><span class="line">    cnt2[r1] += cnt2[r2]; cnt1[r1] += cnt1[r2];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//    Fastin;</span></span><br><span class="line"><span class="comment">//    Fastout;</span></span><br><span class="line">    <span class="keyword">int</span> t; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);  <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n); s1 = s2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">            par[i] = i;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(x == <span class="number">1</span>)&#123;cnt1[i] = <span class="number">1</span>;cnt2[i] = <span class="number">0</span>; s1++;&#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;cnt2[i] = <span class="number">1</span>; cnt1[i] = <span class="number">0</span>; s2++;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ll ans = s1 * s2 * (s2 - <span class="number">1</span>) / <span class="number">2</span> % M + s2 * (s2 - <span class="number">1</span>) * (s2 - <span class="number">2</span>) / <span class="number">6</span> % M; ans %= M;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> u, v; <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">            <span class="keyword">int</span> r1 = <span class="built_in">find</span>(u), r2 = <span class="built_in">find</span>(v);</span><br><span class="line">            ll res = (cnt1[r1] * cnt2[r2] + cnt2[r1] * cnt1[r2]) * (s2 - cnt2[r1] - cnt2[r2])</span><br><span class="line">                + (cnt2[r1] * cnt2[r2]) * (s1 + s2 - cnt1[r1] - cnt2[r1] - cnt1[r2] - cnt2[r2]);</span><br><span class="line">            res %= M;</span><br><span class="line">            ans -= res; ans = (ans % M + M) % M;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">            <span class="built_in">merge</span>(u, v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="1007-边权随机均匀分布的完全图上问题"><a href="#1007-边权随机均匀分布的完全图上问题" class="headerlink" title="1007 边权随机均匀分布的完全图上问题"></a>1007 边权随机均匀分布的完全图上问题</h2><p>当V与E同阶时，可以使用堆优化的dij算法$O(ElogE)$</p><p><del>用斐波那契堆可以降低到$O(VlogV+E)$ 不会</del></p><p>当完全图时，则应该使用朴素的dij算法$O(n^2)$</p><p>在这道题中，因为边权随机均分分布，所以最短路径不会很长(个数意义上)。同时我们发现，如果不堵塞当前最短路径中的某一条边，那么修改其他边是不会影响结果的。因而我们跑最短路算法，枚举路径上每一条边来堵塞，递归地在新图中再次跑最短路，堵塞最短路上的每一条边…枚举&amp;回溯即可得到所有的结果，取出最长的最短路作为答案即可。</p><p>时间复杂度$O(T<em>n^2</em>L^k)$ 其中$L$是最短路径可能的长度。</p><p><del>虽然没有测试，但是L大概最多大概也就6、7的级别</del></p><p><del>然而wmx真算法了结果没有初始化GG</del> </p><p><del>IGVA orz</del></p><h2 id="1008-计算几何与平面旋转"><a href="#1008-计算几何与平面旋转" class="headerlink" title="1008 计算几何与平面旋转"></a>1008 计算几何与平面旋转</h2><p>转化思路，不考虑小球在这个三角形中如何弹射，而是用三角形密铺整个平面，那么小球在三角形的弹射路径就可以通过对称操作变成一条直线，那么现在的问题就是在三角形平面中求一条线碰到第k个交点时的时间。</p><p>二分时间，检查当前时间时只需要检查当前长度的线段与三族平行线(<code>0, pi / 3, pi * 2 / 3</code>)之间各自交了多少个点。</p><p>检查<code>0</code>时只需要看y轴方向的速度，该方向上的长度h能跨越多少个平行线，注意判断一下最开始的半截的影响。</p><p>接下来要判断<code>pi / 3, pi * 2 / 3</code>的平行线族的相交情况时不需要从小球初始位置斜着找投影后的长度，可以相对地将初始位置和速度旋转一番，这样就可以化归到对<code>0</code>的情况，而对<code>0</code>的情况很容易考虑，$v_y*t$就是平行线方向的投影。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">double</span> l, x, y, vx, vy; <span class="keyword">int</span> k;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将(x, y)逆时针旋转a度</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">double</span> &amp;x, <span class="keyword">double</span> &amp;y, <span class="keyword">double</span> cx, <span class="keyword">double</span> cy, <span class="keyword">double</span> a)</span></span>&#123;</span><br><span class="line">    x -= cx; y -= cy;</span><br><span class="line">    <span class="keyword">double</span> cosa = <span class="built_in">cos</span>(a), sina = <span class="built_in">sin</span>(a);</span><br><span class="line">    <span class="keyword">double</span> xx = x * cosa + y * -sina;</span><br><span class="line">    <span class="keyword">double</span> yy = x * sina + y * cosa;</span><br><span class="line">    x = xx + cx; y = yy + cy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">double</span> &amp;x, <span class="keyword">double</span> &amp;y, <span class="keyword">double</span> &amp;vx, <span class="keyword">double</span> &amp;vy)</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> cx = <span class="number">0</span>, cy = l / <span class="built_in">sqrt</span>(<span class="number">3</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">rotate</span>(x, y, cx, cy, -pi * <span class="number">2</span> / <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">rotate</span>(vx, vy, <span class="number">0</span>, <span class="number">0</span>, -pi * <span class="number">2</span> / <span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">double</span> t, <span class="keyword">double</span> h = <span class="number">0</span>)</span></span>&#123;</span><br><span class="line">    ll cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> L = l / <span class="number">2</span> * <span class="built_in">sqrt</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">        h = <span class="built_in">abs</span>(vy) * t;</span><br><span class="line">        <span class="keyword">if</span>(vy &lt; <span class="number">0</span>) cnt += h &lt; y? <span class="number">0</span>: <span class="number">1</span> + (ll)((h - y) / L);</span><br><span class="line">        <span class="keyword">else</span> cnt += h &lt; L - y? <span class="number">0</span>: <span class="number">1</span> + (ll)((h - (L - y)) / L);</span><br><span class="line">        <span class="built_in">fun</span>(x, y, vx, vy);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt &lt; k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//    Fastin;</span></span><br><span class="line">    <span class="keyword">int</span> t; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t); <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lf %lf %lf %lf %lf %d&quot;</span>, &amp;l, &amp;x, &amp;y, &amp;vx, &amp;vy, &amp;k);</span><br><span class="line">        <span class="keyword">double</span> left = <span class="number">0</span>, right = <span class="number">1e10</span>, middle;</span><br><span class="line">        <span class="keyword">while</span>(left + eps &lt; right)&#123;</span><br><span class="line">            middle = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">check</span>(middle)) left = middle;</span><br><span class="line">            <span class="keyword">else</span> right = middle;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%.10f\n&quot;</span>, left);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算几何 </tag>
            
            <tag> 图论 </tag>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020-牛客多校-5</title>
      <link href="/2020/07/27/2020-%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A1-5/"/>
      <url>/2020/07/27/2020-%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A1-5/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><p>坑</p><span id="more"></span><h2 id="I-数学构造题"><a href="#I-数学构造题" class="headerlink" title="I 数学构造题"></a>I 数学构造题</h2><p>想这类题的时候不能太过于从有限的角度去考虑无穷的角度，如果用有限的面积拓展到无限的面积，那么最多大概也就1/2, 5/9的情况，这不是最优的。应该用无限的观点去尝试构造，考虑一个金块最多可以贡献出4个信标，一个炼丹炉最多也可以贡献4个信标，并且认为这一个金块和一个炼丹炉都能在平均的意义下满足4个信标的放置条件，那么最好的情况就是4/6 = 2/3。</p><p>下面给出一种构造方式，斜着放两串1，2、3交替填充在凹槽里即可。</p><h2 id="E-置换与大数LCM"><a href="#E-置换与大数LCM" class="headerlink" title="E 置换与大数LCM"></a>E 置换与大数LCM</h2><p>求出每个环长度的LCM即可，得用高精度，手写大数/JAVA</p><p>因为要找所有的序列，可以通过若干次的置换成为有序序列，那么就等价于将有序序列<code>[1, 2, ...,n]</code>通过反向置换可以得到的不同序列的个数，转化完后显然就是求所有环长度的LCM了。</p><h2 id="D-LIS"><a href="#D-LIS" class="headerlink" title="D LIS"></a>D LIS</h2><p>仔细观察题目给的两种操作后发现就是将一个数移动到另一个位置会花费一次代价，要使得移动次数最少使得成为一个有序数列，那么只要找所有起点开始LIS最长是多少即可。复杂度$O(n^2logn)$</p><h2 id="B-异或MST"><a href="#B-异或MST" class="headerlink" title="B 异或MST"></a>B 异或MST</h2><p>容易发现，不管之前是否有进行过删边加边操作，连接两个点的边的权值不变。</p><p>那么dfs一遍原图，用根节点到当前节点路径上所有边权的异或和作为点权，跑完全图的异或MST即可。</p><p>异或MST已经更新到模版template中，速度飞快，常数较小$O(n<em>log</em>log)$</p><p>总体算法思想是boruvka算法，利用切分定理进行多路增广，这样保证最多只要增广logn次即可合并到一个联通块。而在异或图中找增广则可以On枚举某一个联通块中所有节点，利用01trie在其余节点中Olog的找最小的边权进行相连。</p><p>虽然可以朴素地在trie中删去当前联通块中所有点、查询最短边、加回之前联通块中所有点（常数巨大）来处理，但是在牛客会TLE掉，真的非常慢。。</p><p>一种很快的办法是在01Trie上做暴力搜索。可以料想，因为要使得异或后边权最小，所以在01trie上一定是子树的孩子之间会配对到最优的连边情况。因而递归处理，当处理完某个节点的左子树和右子树后，暴力枚举一边的子树，在另一端用01trie的性质贪心地找最短的边，从而完成左右子树的合并。可以动态维护vector，也可以比较漂亮地（而且速度快一倍orz）利用循环来划分左右子树，具体代码参见template。</p><p><del>这道题虽然有个异或MST的知识点，但是能想到最开始的结论其实也不容易qaq。</del></p><h2 id="C-生成函数-amp-构造"><a href="#C-生成函数-amp-构造" class="headerlink" title="C 生成函数&amp;构造"></a>C 生成函数&amp;构造</h2><p>根据生成函数理论，对于函数$f(x, y) = (x^1 + x^2 + …)^k (y^1+y^2+…)^k$，展开式中单项式$x^ny^m$的系数就是满足$\sum a_i = n, \sum b_i=m$的所有可能的序列个数。我们将序列拆分成k组$(x^1+x^2…)(y^1+y^2+…)$来看，假设该序列对答案贡献出了单项式$x^iy^j$，那么此时其系数贡献显然只有1，题目要求每一对$a_i, b_i$都要贡献出$min(a_i, b_i)$次，那么我们考虑构造出一种办法，可以让每一组$(x^1+x^2…)(y^1+y^2+…)$都能贡献出$min(i, j)$次$x^iy^j$个单项式。可以采取如下精妙的办法：将其修改为$(x^1+x^2…)(y^1+y^2+…)(1+xy+x^2y^2+…)$，这样在原先序列中的$x^iy^j, x^{i-1}y^{j-1},x^{i-2}y^{j-2},…$都会通过$(1+xy+x^2y^2+…)$中的某一项映射到$x^iy^j$,而序列$\{x^iy^j,x^{i-1}y^{k-1}, …x^0y^{j-i}\}$的个数就是$min(i, j)$，这样，这$min(i, j)$个单项式都会贡献出1，总共贡献就是$min(i,j)$。</p><p>将所有的项叠加起来即可得到最终的结果.。</p><p>最终要求的积式$\prod min(a_i, b_i) $的值就是$(x^1 + x^2 + …)^k (y^1+y^2+…)^k(1+xy+x^2y^2+…)^k$中$x^ny^m$的系数。</p><p>根据组合公式，易知其结果为$\sum_{i=0}^{min(n-k, m-k)}(^{i+k-1}_{k-1})(^{n-i-1}_{k-1})(^{m-i-1}_{k-1})$</p><p>预处理一下$C(n,k-1)$即可，复杂度$O(Tn)$</p>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 构造 </tag>
            
            <tag> LCM </tag>
            
            <tag> LIS </tag>
            
            <tag> Boruvka </tag>
            
            <tag> 异或MST </tag>
            
            <tag> 生成函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020-牛客多校-6</title>
      <link href="/2020/07/27/2020-%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A1-6/"/>
      <url>/2020/07/27/2020-%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A1-6/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><p>有坑待补 具体数学 约瑟夫的Ok做法</p><span id="more"></span><h2 id="B-线性无关的n维01向量个数"><a href="#B-线性无关的n维01向量个数" class="headerlink" title="B 线性无关的n维01向量个数"></a>B 线性无关的n维01向量个数</h2><p>考虑每次加入元素时可取的元素个数。</p><p>假设当前已经取了i个线性无关向量，则它们可以张出一共$2^i$个向量，所以第i + 1个向量只有$2^n - 2 ^ i$种可取办法。</p><p>因而$f(n) = \prod_{i=0}^{n - 1}(2^n-2^i)/2^n$</p><p>推导可得递推关系:</p><p>$f(n) = (1 - 1/2^n)*f(n - 1)$</p><p>线性处理出来O1查询即可。</p><h2 id="J-约瑟夫变换与置换"><a href="#J-约瑟夫变换与置换" class="headerlink" title="J 约瑟夫变换与置换"></a>J 约瑟夫变换与置换</h2><p>考虑一个<code>k-约瑟夫变换</code>，指的是将序列<code>1, 2, ..., n</code>变换到<code>p1, p2, ..., pn</code>，其中<code>pi</code>表示在约瑟夫过程中第i个出局的人的标号。</p><p>那么只要处理出k-约瑟夫变换的置换方案，就可以On地得知进行1e9次k-约瑟夫变换的结果。</p><p><del>所以为什么一直认为置换的幂次一定要倍增来nlogn的做出来qaq</del></p><p>因为nm &lt;= 1e6,所以总共$O(nmlogn)$即可。</p><p>之前不会做<a href="http://acm.xidian.edu.cn/problem.php?id=1009">xdoj1009</a>，这次场上还是不会，不然这道题其实可以飞快的过掉。</p><p>wmx用了splay带大常数的处理出了一次k-约瑟夫变换的结果，然后TLE了牛客。</p><p>事实上可以用线段树直接更小常数的查询：</p><p>线段树维护每个元素存在的情况，存在则节点值为1，不然则值为0；支持单点修改和查询当前仍存在于线段树中的第k个元素。</p><p>如果当前有n个元素，需要查询从前往后第cnt个，直接用线段树就可以$O(logn)$查询出谁是下一个被淘汰出局的；接下来要更新$cnt$的值，淘汰完一人后在新的$n -1$长度的序列中被淘汰的人是该新序列的第几个，稍微推导研究一下就可以知道$cnt’ = (cnt + k - 2)\% (n - i) + 1$，从1开始编号。反复进行上述操作即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls (p &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs ((p &lt;&lt; 1) | 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mid ((l + r) &gt;&gt; 1)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> itn maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> st[maxn &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;st[p] = st[ls] + st[rs];&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k, <span class="keyword">int</span> op)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r &amp;&amp; l == k)&#123;</span><br><span class="line">        st[p] += op;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(k &lt;= mid) <span class="built_in">update</span>(ls, l, mid, k, op);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">update</span>(rs, mid + <span class="number">1</span>, r, k, op);</span><br><span class="line">    <span class="built_in">up</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查询第k个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r)&#123; <span class="keyword">return</span> l;&#125;</span><br><span class="line">    <span class="keyword">if</span>(st[ls] &lt; k) <span class="keyword">return</span> <span class="built_in">query</span>(rs, mid + <span class="number">1</span>, r, k - st[ls]);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">query</span>(ls, l, mid, k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> vis[maxn];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line"><span class="keyword">int</span> p[maxn], nxt[maxn][N];</span><br><span class="line"><span class="keyword">int</span> a[maxn], temp[maxn], c[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(st[<span class="number">0</span>]) * <span class="number">4</span> * n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        c[i] = i;</span><br><span class="line">        <span class="built_in">update</span>(<span class="number">1</span>, <span class="number">1</span>, n, i, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> cnt = k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        p[i] = <span class="built_in">query</span>(<span class="number">1</span>, <span class="number">1</span>, n, cnt);</span><br><span class="line">        <span class="built_in">update</span>(<span class="number">1</span>, <span class="number">1</span>, n, p[i], <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(i != n) cnt = (cnt + k - <span class="number">2</span>) % (n - i) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) nxt[i][<span class="number">0</span>] = p[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i++) <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">        nxt[j][i] = nxt[nxt[j][i - <span class="number">1</span>]][i - <span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) vis[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">if</span>(!vis[i])&#123;</span><br><span class="line">        vec.<span class="built_in">clear</span>(); vec.<span class="built_in">push_back</span>(i);</span><br><span class="line">        <span class="keyword">int</span> now = i;</span><br><span class="line">        <span class="keyword">while</span>(p[now] != i)&#123;</span><br><span class="line">            now = p[now]; vis[now] = <span class="number">1</span>;</span><br><span class="line">            vec.<span class="built_in">push_back</span>(now);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> len = (<span class="keyword">int</span>)vec.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> step = x % len;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x: vec)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = N - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) <span class="keyword">if</span>(step &amp; <span class="number">1</span> &lt;&lt; j)&#123;</span><br><span class="line">                c[x] = nxt[c[x]][j];</span><br><span class="line">            &#125;</span><br><span class="line">            temp[x] = a[c[x]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) a[i] = temp[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//    Fastin;</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) a[i] = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> _ = <span class="number">1</span>; _ &lt;= m; _++)&#123;</span><br><span class="line">        <span class="keyword">int</span> k, x; <span class="built_in">scnaf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;k, &amp;x);</span><br><span class="line">        <span class="built_in">update</span>(k, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="J-gt-XDOJ-1018"><a href="#J-gt-XDOJ-1018" class="headerlink" title="J-&gt;XDOJ 1018"></a>J-&gt;XDOJ 1018</h3><p>留坑待补《 具体数学》</p>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线性空间 </tag>
            
            <tag> 约瑟夫环 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020-hdu多校-2</title>
      <link href="/2020/07/23/2020-hdu%E5%A4%9A%E6%A0%A1-2/"/>
      <url>/2020/07/23/2020-hdu%E5%A4%9A%E6%A0%A1-2/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><span id="more"></span><h1 id="6763-1001-并查集"><a href="#6763-1001-并查集" class="headerlink" title="6763  1001 并查集"></a>6763  1001 并查集</h1><p>题目出锅了 虽然开局一堆人A的飞快，但是应该都是假算法？<del>主要是出题人给的题解是假的</del></p><p>如果从每次都尽可能删除极大联通块的策略来考虑，那么可以用并查集维护信息。显然在一个极大联通块中可以将每个节点删去所有权值中的最小值，之后该点断裂，将原联通块分成若干个小联通块，反复进行上述操作即可。我们用并查集反向维护这个过程：将所有节点按照权值从大到小进行遍历，如果当前点$u$连有边$<u,v>$并且有$w[v] &gt; w[u]$，那么就在并查集中连$<root[v]->u&gt;$ 。这样， 我们最终就会得到一颗有根树，其上节点的父子关系也给出了删去权值的方案。最终只需要用<code>w[x] - w[par[x]]​</code>去更新答案即可。</p><p>因为使用路径压缩的并查集，所以要额外存一个数组，表示真正的拓扑结构上的父节点，用于最后更新答案。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">star</span>&#123;</span><span class="keyword">int</span> to, next;&#125;;</span><br><span class="line"><span class="keyword">int</span> n, m, head[maxn], top = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> w[maxn];</span><br><span class="line">star edge[maxn &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    edge[top].to = v;</span><br><span class="line">    edge[top].next = head[u];</span><br><span class="line">    head[u] = top++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> w[a] &gt; w[b];&#125;</span><br><span class="line"><span class="keyword">int</span> id[maxn], vis[maxn];;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> par[maxn], f[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> x == par[x]? x: par[x] = <span class="built_in">find</span>(par[x]);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//    Fastin;</span></span><br><span class="line">    <span class="keyword">int</span> t; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t); <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">clr</span>(head, <span class="number">-1</span>); top = <span class="number">0</span>; <span class="built_in">clr</span>(vis, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, w + i);</span><br><span class="line">            id[i] = i; par[i] = i; f[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> u, v; <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;u, &amp;v); <span class="built_in">add</span>(u, v); <span class="built_in">add</span>(v, u);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(id + <span class="number">1</span>, id + n + <span class="number">1</span>, cmp);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            vis[id[i]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = head[id[i]]; ~j; j = edge[j].next)&#123;</span><br><span class="line">                <span class="keyword">int</span> to = edge[j].to; <span class="keyword">if</span>(vis[to])&#123;</span><br><span class="line">                    <span class="keyword">int</span> r = <span class="built_in">find</span>(to);</span><br><span class="line">                    <span class="keyword">if</span>(r != id[i]) par[r] = f[r] = id[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) ans += w[i] - w[f[i]];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="1012"><a href="#1012" class="headerlink" title="1012"></a>1012</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">char</span> s[maxn], t[<span class="number">30</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> nxt[maxn][<span class="number">26</span>], temp[<span class="number">26</span>];</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">30</span>][<span class="number">30</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//    Fastin;</span></span><br><span class="line">    <span class="keyword">int</span> __; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;__); <span class="keyword">while</span>(__--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s %s&quot;</span>, s + <span class="number">1</span>, t + <span class="number">1</span>); n = (<span class="keyword">int</span>)<span class="built_in">strlen</span>(s + <span class="number">1</span>); m = (<span class="keyword">int</span>)<span class="built_in">strlen</span>(t + <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) temp[i] = inf;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>; j++) nxt[i][j] = temp[j];</span><br><span class="line">            <span class="keyword">if</span>(i) temp[s[i] - <span class="string">&#x27;a&#x27;</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> q; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;q); <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; q; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> l, r; <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;l, &amp;r);</span><br><span class="line">            <span class="comment">//dp[i][j]表示处理t串的第i位后，已经有lcs长为j时，s串中最短的前缀位置</span></span><br><span class="line">            dp[<span class="number">1</span>][<span class="number">0</span>] = l - <span class="number">1</span>; dp[<span class="number">1</span>][<span class="number">1</span>] = s[l] == t[<span class="number">1</span>]? l: nxt[l][t[<span class="number">1</span>] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= m; i++) dp[<span class="number">1</span>][i] = inf;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= m; i++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++)&#123;</span><br><span class="line">                    dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>]; dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">                    <span class="keyword">if</span>(dp[i - <span class="number">1</span>][j - <span class="number">1</span>] &lt;= r &amp;&amp; nxt[dp[i - <span class="number">1</span>][j - <span class="number">1</span>]][t[i] - <span class="string">&#x27;a&#x27;</span>] &lt;= r)</span><br><span class="line">                        dp[i][j] = <span class="built_in">min</span>(dp[i][j], nxt[dp[i - <span class="number">1</span>][j - <span class="number">1</span>]][t[i] - <span class="string">&#x27;a&#x27;</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= m; j++) dp[i][j] = inf;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">int</span> lcs = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) <span class="keyword">if</span>(dp[m][i] &lt;= r) lcs = i;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, r - l + <span class="number">1</span> + m - <span class="number">2</span> * lcs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;random&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line">   </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> itn int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fro for</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> scnaf scanf</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sacnf scanf</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Fastin freopen(<span class="meta-string">&quot;in.txt&quot;</span>, <span class="meta-string">&quot;r&quot;</span>, stdin)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Fastout freopen(<span class="meta-string">&quot;out.txt&quot;</span>, <span class="meta-string">&quot;w&quot;</span>, stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> manx maxn</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) ((x) &amp; (-x))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ceil(n, p) (((n) +(p) - 1) / (p))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DBG(x) (void)(cout &lt;&lt; <span class="meta-string">&quot;L&quot;</span> &lt;&lt; __LINE__ &lt;&lt; <span class="meta-string">&quot;: &quot;</span> &lt;&lt; #x &lt;&lt; <span class="meta-string">&quot; = &quot;</span> &lt;&lt;( x) &lt;&lt; <span class="meta-string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clr(a, x) memset((a), x, sizeof (a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> min(a, b) ((a) &lt; (b)? (a): (b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> max(a, b) ((a) &gt; (b)? (a): (b))</span></span><br><span class="line">   </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> ng=<span class="number">0</span>,x=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">   <span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span> || ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) ng|=ch==<span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">   <span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span> &amp;&amp; ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+ch-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">   <span class="keyword">return</span> ng?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*------------------------------------------------------------------------------------*/</span></span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll x, ll y)</span></span>&#123;<span class="keyword">return</span> !x? y: <span class="built_in">gcd</span>(y % x, x);&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exgcd</span><span class="params">(ll a, ll b, ll &amp;x, ll &amp;y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!b)&#123;x = <span class="number">1</span>; y = <span class="number">0</span>;<span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="built_in">exgcd</span>(b, a % b, y, x); y -= a / b * x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">qp</span><span class="params">(ll a, ll p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    ll ans = <span class="number">1</span>; <span class="keyword">while</span>(p)&#123;<span class="keyword">if</span>(p &amp; <span class="number">1</span>) ans = ans * a ; a = a * a; p &gt;&gt;= <span class="number">1</span>;&#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">qp</span><span class="params">(ll a, ll p, ll M)</span></span>&#123;</span><br><span class="line">    ll ans = <span class="number">1</span>; <span class="keyword">while</span>(p)&#123; <span class="keyword">if</span>(p &amp; <span class="number">1</span>) ans = ans * a % M; a = a * a % M; p &gt;&gt;= <span class="number">1</span>;&#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*------------------------------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> manx = <span class="number">2e4</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">star</span>&#123;</span><span class="keyword">int</span> to, next, a, b;&#125;;</span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line"><span class="keyword">int</span> head[maxn], top = <span class="number">0</span>;</span><br><span class="line">star edge[maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    edge[top].to = v;</span><br><span class="line">    edge[top].next = head[u];</span><br><span class="line">    edge[top].a = a; edge[top].b = b;</span><br><span class="line">    head[u] = top++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//检验树直径&lt;=x 的可能性</span></span><br><span class="line">ll dp[maxn][<span class="number">25</span>], middle, h[<span class="number">25</span>], size[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> par)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pre = <span class="number">0</span>; dp[now][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> id = head[now]; ~id; id = edge[id].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> to = edge[id].to; <span class="keyword">if</span>(to == par) <span class="keyword">continue</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">dfs</span>(to, now);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= k &amp;&amp; i &lt;= pre + size[to]; i++) h[i] = middle + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= pre; i++) <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; size[to] &amp;&amp; j + i &lt;= k; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[now][i] + dp[to][j] + edge[id].a &lt;= middle)</span><br><span class="line">                h[i + j + <span class="number">1</span>] = <span class="built_in">min</span>(h[i + j + <span class="number">1</span>], <span class="built_in">max</span>(dp[now][i], dp[to][j] + edge[id].a));</span><br><span class="line">            <span class="keyword">if</span>(dp[now][i] + dp[to][j] + edge[id].b &lt;= middle)</span><br><span class="line">                h[i + j] = <span class="built_in">min</span>(h[i + j], <span class="built_in">max</span>(dp[now][i], dp[to][j] + edge[id].b));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= pre + size[to]; i++) dp[now][i] = h[i];</span><br><span class="line">        pre += size[to];</span><br><span class="line">    &#125;</span><br><span class="line">    size[now] = pre + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//    Fastin;</span></span><br><span class="line">    <span class="keyword">int</span> _; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;_); <span class="keyword">while</span>(_--)&#123;</span><br><span class="line">        top = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;k); <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span> * n; i++) head[i] = <span class="number">-1</span>;</span><br><span class="line">        ll M =<span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> u, v, a, b;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d %d&quot;</span>, &amp;u, &amp;v, &amp;a, &amp;b);</span><br><span class="line">            <span class="built_in">add</span>(u, v, a, b);</span><br><span class="line">            <span class="built_in">add</span>(v, u, a, b);</span><br><span class="line">            M += <span class="built_in">max</span>(a, b);</span><br><span class="line">        &#125;</span><br><span class="line">        ll left = <span class="number">1</span>, right = M;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            middle = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span>(dp[<span class="number">1</span>][k] &lt;= middle) right = middle;</span><br><span class="line">            <span class="keyword">else</span> left = middle + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2020-hdu多校-1</title>
      <link href="/2020/07/22/2020-hdu%E5%A4%9A%E6%A0%A1-1/"/>
      <url>/2020/07/22/2020-hdu%E5%A4%9A%E6%A0%A1-1/</url>
      
        <content type="html"><![CDATA[<h3 id="1006"><a href="#1006" class="headerlink" title="1006"></a>1006</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> itn maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, w[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">star</span>&#123;</span><span class="keyword">int</span> to, next;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[maxn], top = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> du[maxn], K;</span><br><span class="line">star edge[maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    edge[top].to = v;</span><br><span class="line">    edge[top].next = head[u];</span><br><span class="line">    head[u] = top++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp[maxn];</span><br><span class="line">unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; conv;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> c[<span class="number">700</span>][maxn], bitcnt = <span class="number">0</span>, zero[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> i, <span class="keyword">int</span> x, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= n)&#123; c[id][i] += x; i += <span class="built_in">lowbit</span>(i);&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i)&#123;ans += c[id][i]; i -= <span class="built_in">lowbit</span>(i);&#125; <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bitupdate</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> key, <span class="keyword">int</span> op)</span></span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(conv.<span class="built_in">count</span>(u) == <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> id = conv[u]; <span class="built_in">add</span>(id, key, op, du[u]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将u节点的邻接权值key的数量 += op</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> key, <span class="keyword">int</span> op)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(key &gt; du[u]) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//特判断0</span></span><br><span class="line">    <span class="keyword">if</span>(key == <span class="number">0</span>)&#123;</span><br><span class="line">        zero[u] += op; <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mp[u][key] += op;</span><br><span class="line">    <span class="comment">// 1 - &gt;0</span></span><br><span class="line">    <span class="keyword">if</span>(mp[u][key] == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">bitupdate</span>(u, key, <span class="number">-1</span>);</span><br><span class="line">        mp[u].<span class="built_in">erase</span>(key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//0 -&gt; 1</span></span><br><span class="line">    <span class="keyword">if</span>(mp[u][key] == <span class="number">1</span> &amp;&amp; op == <span class="number">1</span>) <span class="built_in">bitupdate</span>(u, key, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//检查u节点的邻点中 权值x及其之前是否填满</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(zero[u] == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="built_in">query</span>(conv[u], x);</span><br><span class="line">    <span class="keyword">return</span> x == cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> temp[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mex</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(du[u] &lt; K)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= du[u]; i++) temp[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; ~i; i = edge[i].next)&#123;</span><br><span class="line">            <span class="keyword">if</span>(w[edge[i].to] &gt; du[u]) <span class="keyword">continue</span>;</span><br><span class="line">            temp[w[edge[i].to]] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= du[u]; i++) <span class="keyword">if</span>(!temp[i]) <span class="keyword">return</span> i;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(zero[u] == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = du[u], middle;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            middle = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">check</span>(u, middle)) left = middle + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> right = middle;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">unordered_set&lt;<span class="keyword">int</span>&gt; vec[maxn];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NODE</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="built_in">NODE</span>(<span class="keyword">int</span> _x, <span class="keyword">int</span> _y)&#123;</span><br><span class="line">        x = <span class="built_in">min</span>(_x, _y);</span><br><span class="line">        y = <span class="built_in">max</span>(_x, _y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> NODE &amp;b)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x != b.x) <span class="keyword">return</span> x &lt; b.x;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> y &lt; b.y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">set&lt;NODE&gt; EDGE;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//    Fastin;</span></span><br><span class="line">    <span class="keyword">int</span> t; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t); <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">clr</span>(head, <span class="number">-1</span>); top = <span class="number">0</span>; <span class="built_in">clr</span>(du, <span class="number">0</span>); <span class="built_in">clr</span>(zero, <span class="number">0</span>); bitcnt = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        n = <span class="built_in">read</span>(); m = <span class="built_in">read</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) mp[i].<span class="built_in">clear</span>(); conv.<span class="built_in">clear</span>();</span><br><span class="line">        </span><br><span class="line">        K = <span class="built_in">sqrt</span>(m);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            w[i] = <span class="built_in">read</span>(); vec[i].<span class="built_in">clear</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        EDGE.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> u, v; u = <span class="built_in">read</span>(); v = <span class="built_in">read</span>();</span><br><span class="line">            EDGE.<span class="built_in">insert</span>(<span class="built_in">NODE</span>(u, v));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> edge: EDGE)&#123;</span><br><span class="line">            <span class="keyword">if</span>(edge.x != edge.y)&#123;</span><br><span class="line">                <span class="built_in">add</span>(edge.x, edge.y); <span class="built_in">add</span>(edge.y, edge.x);</span><br><span class="line">                du[edge.x]++; du[edge.y]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">add</span>(edge.x, edge.y);</span><br><span class="line">                du[edge.x]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//只有O(sqrt(m))个点的度&gt;= K = sqrt(m)</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">if</span>(du[i] &gt;= K)&#123;</span><br><span class="line">            <span class="built_in">memset</span>(c[bitcnt], <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span> (c[bitcnt]));</span><br><span class="line">            conv[i] = bitcnt++;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = head[i]; ~j; j = edge[j].next)&#123;</span><br><span class="line">                <span class="keyword">int</span> to = edge[j].to; vec[to].<span class="built_in">insert</span>(i);</span><br><span class="line">                <span class="built_in">update</span>(i, w[to], <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> q; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;q); <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">            itn op, x, y; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;op);</span><br><span class="line">            <span class="keyword">if</span>(op == <span class="number">1</span>)&#123;</span><br><span class="line">                x = <span class="built_in">read</span>(); y = <span class="built_in">read</span>();</span><br><span class="line">                <span class="comment">//w[x] := y;</span></span><br><span class="line">                <span class="comment">//v是所有的相邻大度点</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> v: vec[x])&#123;</span><br><span class="line">                    <span class="built_in">update</span>(v, w[x], <span class="number">-1</span>);</span><br><span class="line">                    <span class="built_in">update</span>(v, y, <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                w[x] = y;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                x = <span class="built_in">read</span>();</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">mex</span>(x));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分块 </tag>
            
            <tag> 树状数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络流</title>
      <link href="/2020/07/14/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
      <url>/2020/07/14/%E7%BD%91%E7%BB%9C%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<p>两个定理的证明</p><p><a href="https://www.cnblogs.com/cniwoq/p/9245813.html">https://www.cnblogs.com/cniwoq/p/9245813.html</a></p><p>spfa的一些说明</p><p><a href="https://blog.csdn.net/xiazdong/article/details/8193680">https://blog.csdn.net/xiazdong/article/details/8193680</a></p><p>dinic</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> itn maxn = <span class="number">1200</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxe = <span class="number">120000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> ll inf = <span class="number">1ll</span> &lt;&lt; <span class="number">60</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">star</span>&#123;</span><span class="keyword">int</span> to, next, w;&#125;;</span><br><span class="line"><span class="keyword">int</span> head[maxn], top = <span class="number">0</span>;</span><br><span class="line">star edge[maxe &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    edge[top].to = v;</span><br><span class="line">    edge[top].next = head[u];</span><br><span class="line">    edge[top].w = w;</span><br><span class="line">    head[u] = top++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> d[maxn], cur[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t, ll flow)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(flow == <span class="number">0</span> || s == t) <span class="keyword">return</span> flow;</span><br><span class="line">    </span><br><span class="line">    ll res = <span class="number">0</span>, f;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = cur[s]; ~i; i = edge[i].next)&#123;</span><br><span class="line">        cur[s] = i;</span><br><span class="line">        <span class="keyword">if</span>(d[edge[i].to] == d[s] + <span class="number">1</span>)&#123;</span><br><span class="line">            f = <span class="built_in">dfs</span>(edge[i].to, t, <span class="built_in">min</span>(flow, (ll)edge[i].w));</span><br><span class="line">            edge[i].w -= f; edge[i ^ <span class="number">1</span>].w += f; res += f; flow -= f;</span><br><span class="line">            <span class="keyword">if</span>(flow == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">queue&lt;<span class="keyword">int</span>&gt; q, q0;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="built_in">clr</span>(d, <span class="number">0</span>);</span><br><span class="line">    q = q0; q.<span class="built_in">push</span>(s);</span><br><span class="line">    cur[s] = head[s]; d[s] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">int</span> now = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = head[now]; ~i; i = edge[i].next) <span class="keyword">if</span>(!d[edge[i].to] &amp;&amp; edge[i].w &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            cur[edge[i].to] = head[edge[i].to]; d[edge[i].to] = d[now] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(edge[i].to == t) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            q.<span class="built_in">push</span>(edge[i].to);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">dinic</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">bfs</span>(s, t)) ans += <span class="built_in">dfs</span>(s, t, inf);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//    Fastin;</span></span><br><span class="line">    <span class="built_in">clr</span>(head, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">int</span> n, m, s, t; <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d %d&quot;</span>, &amp;n, &amp;m, &amp;s, &amp;t);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, u, v, w; i &lt; m; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line">        <span class="built_in">add</span>(u, v, w); <span class="built_in">add</span>(v, u, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">dinic</span>(s, t));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>isap</p><p><a href="https://www.cnblogs.com/owenyu/p/6852664.html">https://www.cnblogs.com/owenyu/p/6852664.html</a></p><p>这个博主好像有一篇带花树的讲解，之后看一下</p><p>较全面的网络流</p><p><a href="https://blog.csdn.net/A_Comme_Amour/article/details/79356220">https://blog.csdn.net/A_Comme_Amour/article/details/79356220</a></p><p>MCMF</p><p><a href="https://blog.csdn.net/lym940928/article/details/90209172">https://blog.csdn.net/lym940928/article/details/90209172</a></p><p>isap</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> itn maxn = <span class="number">1200</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxe = <span class="number">120000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> ll inf = <span class="number">1ll</span> &lt;&lt; <span class="number">60</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">star</span>&#123;</span><span class="keyword">int</span> to, next, w;&#125;;</span><br><span class="line"><span class="keyword">int</span> n, m, s, t;</span><br><span class="line"><span class="keyword">int</span> head[maxn], top = <span class="number">0</span>;</span><br><span class="line">star edge[maxe &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    edge[top].to = v;</span><br><span class="line">    edge[top].next = head[u];</span><br><span class="line">    edge[top].w = w;</span><br><span class="line">    head[u] = top++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> d[maxn], cur[maxn], gap[maxn];</span><br><span class="line"></span><br><span class="line">queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    q.<span class="built_in">push</span>(t); gap[d[t] = <span class="number">1</span>]++; cur[t] = head[t];</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">int</span> now = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = head[now]; ~i; i = edge[i].next) <span class="keyword">if</span>(!d[edge[i].to])&#123;</span><br><span class="line">            gap[d[edge[i].to] = d[now] + <span class="number">1</span>]++;</span><br><span class="line">            cur[edge[i].to] = head[edge[i].to];</span><br><span class="line">            q.<span class="built_in">push</span>(edge[i].to);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> s, <span class="keyword">int</span> t, ll flow)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x == t) <span class="keyword">return</span> flow;</span><br><span class="line">    </span><br><span class="line">    ll res = <span class="number">0</span>, f;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = cur[x]; ~i; i = edge[i].next)&#123;</span><br><span class="line">        cur[x] = i;</span><br><span class="line">        <span class="keyword">if</span>(d[x] == d[edge[i].to] + <span class="number">1</span>)&#123;</span><br><span class="line">            f = <span class="built_in">dfs</span>(edge[i].to, s, t, <span class="built_in">min</span>(flow, (ll)edge[i].w));</span><br><span class="line">            edge[i].w -= f; edge[i ^ <span class="number">1</span>].w += f; flow -= f; res += f;</span><br><span class="line">            <span class="keyword">if</span>(flow == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!(gap[d[x]]--)) d[s] = n + <span class="number">1</span>;</span><br><span class="line">    gap[++d[x]]++; cur[x] = head[x];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">isap</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="built_in">bfs</span>(s, t);</span><br><span class="line">    ll ans = <span class="built_in">dfs</span>(s, s, t, inf);</span><br><span class="line">    <span class="keyword">while</span>(d[s] &lt;= n) ans += <span class="built_in">dfs</span>(s, s, t, inf);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//    Fastin;</span></span><br><span class="line">    <span class="built_in">clr</span>(head, <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d %d&quot;</span>, &amp;n, &amp;m, &amp;s, &amp;t);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, u, v, w; i &lt; m; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line">        <span class="built_in">add</span>(u, v, w); <span class="built_in">add</span>(v, u, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">isap</span>(s, t));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>dinic的优化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="comment">//loj.ac/submission/321069</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020-牛客多校-1</title>
      <link href="/2020/07/12/2020-%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A1-1/"/>
      <url>/2020/07/12/2020-%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A1-1/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><span id="more"></span><hr><h3 id="F-Periodicity-Lemma"><a href="#F-Periodicity-Lemma" class="headerlink" title="F Periodicity Lemma"></a>F Periodicity Lemma</h3><p>叉姐知乎专栏 <a href="https://zhuanlan.zhihu.com/which-way-did-the-bicycle-go">https://zhuanlan.zhihu.com/which-way-did-the-bicycle-go</a></p><p>另一篇证明 <a href="https://zhuanlan.zhihu.com/p/89385360">https://zhuanlan.zhihu.com/p/89385360</a></p><p>原文 <a href="http://www.karlin.mff.cuni.cz/~holub/soubory/FineWilf.pdf">http://www.karlin.mff.cuni.cz/~holub/soubory/FineWilf.pdf</a></p><p>定理如下：</p><p>长为n的字符串S有循环节p、q，且满足p + q - gcd(p, q) &lt;= n，那么有gcd(p, q)也是S的循环节。</p><p>已知上述结论后，那么为了比较$s^∞$与$t^∞$的字典序就可以只比较$|s| + |t| - gcd(|s|, |t|)$次。</p><p><del>真是高级的结论，证明及其数学思想留坑待补</del></p><p>J</p><p>伽马函数</p><p>Wallis’ integrals</p><p>I</p><p>一般图最大匹配？</p>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2016-icpc-beijing</title>
      <link href="/2020/07/07/2016-icpc-beijing/"/>
      <url>/2020/07/07/2016-icpc-beijing/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><span id="more"></span><hr><p><strong>H</strong></p><p>二分答案然后跑<strong>圆的k次交</strong>即可。</p><p>因为学习完k次交后精疲力竭就不写完整这道题了。</p><p>贴一下用自己的码风写的板子。已更新入模版中。</p><p>给出n个圆的平面坐标和半径，能够获得所有圆k次交的面积。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> manx = <span class="number">1e2</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-8</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">sgn</span><span class="params">(<span class="keyword">double</span> x)</span></span>&#123;<span class="keyword">return</span> x &lt; -eps? <span class="number">-1</span>: x &gt; eps? <span class="number">1</span>: <span class="number">0</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">sqr</span><span class="params">(<span class="keyword">double</span> x)</span></span>&#123;<span class="keyword">return</span> x * x;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CIRCLE</span>&#123;</span></span><br><span class="line">    <span class="keyword">double</span> x, y, r, angle;</span><br><span class="line">    <span class="keyword">int</span> d;</span><br><span class="line">    <span class="built_in">CIRCLE</span>()&#123;d = <span class="number">1</span>; angle = <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="built_in">CIRCLE</span>(<span class="keyword">double</span> _x, <span class="keyword">double</span> _y, <span class="keyword">double</span> _angle = <span class="number">0</span>, <span class="keyword">int</span> _d = <span class="number">0</span>)&#123;</span><br><span class="line">        x = _x; y = _y; angle = _angle; d = _d; r = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> CIRCLE &amp;b)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sgn</span>(r - b.r) == <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">dis</span><span class="params">(CIRCLE a, CIRCLE b)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">sqrt</span>(<span class="built_in">sqr</span>(a.x - b.x) + <span class="built_in">sqr</span>(a.y - b.y));&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">cross</span><span class="params">(CIRCLE a, CIRCLE b, CIRCLE c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//有两个交点返回true，以及两个交点的坐标和方位角，p1按照顺时针，p2按照逆时针</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cir_inter_cir</span><span class="params">(CIRCLE a, CIRCLE b, CIRCLE &amp;p1, CIRCLE &amp;p2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> d = <span class="built_in">dis</span>(a, b);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">sgn</span>(d - a.r - b.r) &gt;= <span class="number">0</span> || <span class="built_in">sgn</span>(<span class="built_in">abs</span>(b.r - a.r) - d) &gt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">double</span> cosa = (<span class="built_in">sqr</span>(a.r) + <span class="built_in">sqr</span>(d) - <span class="built_in">sqr</span>(b.r)) / (<span class="number">2</span> * a.r * d);</span><br><span class="line">    <span class="keyword">double</span> sina = <span class="built_in">sqrt</span>(<span class="built_in">max</span>(<span class="number">0.</span>, <span class="number">1.</span> - <span class="built_in">sqr</span>(cosa)));</span><br><span class="line">    <span class="comment">//旋转矩阵 [cosa, -sina; sina, cosa]</span></span><br><span class="line">    p1 = p2 = a;</span><br><span class="line">    p1.x += a.r / d * ((b.x - a.x) * cosa + (b.y - a.y) * -sina);</span><br><span class="line">    p1.y += a.r / d * ((b.x - a.x) * sina + (b.y - a.y) * cosa);</span><br><span class="line">    p2.x += a.r / d * ((b.x - a.x) * cosa + (b.y - a.y) * sina);</span><br><span class="line">    p2.y += a.r / d * ((b.x - a.x) * -sina + (b.y - a.y) * cosa);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> CIRCLE &amp;a, <span class="keyword">const</span> CIRCLE &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">sgn</span>(a.angle - b.angle)) <span class="keyword">return</span> <span class="built_in">sgn</span>(a.angle - b.angle) == <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> a.d &gt; b.d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">cal</span><span class="params">(CIRCLE a, CIRCLE p1, CIRCLE p2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> ans = <span class="built_in">sqr</span>(a.r) * (p2.angle - p1.angle) - <span class="built_in">cross</span>(a, p1, p2) + <span class="built_in">cross</span>(<span class="built_in">CIRCLE</span>(<span class="number">0</span>, <span class="number">0</span>), p1, p2);</span><br><span class="line">    <span class="keyword">return</span> ans / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CIRCLE dot[maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">double</span> area[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cirunion</span><span class="params">(CIRCLE cir[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(cir, cir + n);</span><br><span class="line">    <span class="comment">//记录每个圆被完全覆盖的次数，初始值显然为1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">sgn</span>(<span class="built_in">dis</span>(cir[i], cir[j]) + cir[i].r - cir[j].r) &lt;= <span class="number">0</span>) cir[i].d++;</span><br><span class="line">    CIRCLE p1, p2;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="comment">//针对每一个圆考虑它与所有其他圆的交</span></span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>, top = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == j) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">cir_inter_cir</span>(cir[i], cir[j], p1, p2)) <span class="keyword">continue</span>;</span><br><span class="line">            p1.angle = <span class="built_in">atan2</span>(p1.y - cir[i].y, p1.x - cir[i].x);</span><br><span class="line">            p2.angle = <span class="built_in">atan2</span>(p2.y - cir[i].y, p2.x - cir[i].x);</span><br><span class="line">            p1.d = <span class="number">-1</span>; p2.d = <span class="number">1</span>;</span><br><span class="line">            dot[top++] = p1; dot[top++] = p2;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">sgn</span>(p2.angle - p1.angle) == <span class="number">1</span>) cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//加入起点终点位置</span></span><br><span class="line">        dot[top++] = <span class="built_in">CIRCLE</span>(cir[i].x - cir[i].r, cir[i].y, -pi, <span class="number">-2</span>);</span><br><span class="line">        dot[top++] = <span class="built_in">CIRCLE</span>(cir[i].x - cir[i].r, cir[i].y, pi, <span class="number">2</span>);</span><br><span class="line">        <span class="built_in">sort</span>(dot, dot + top, cmp);</span><br><span class="line">        <span class="keyword">int</span> now = cir[i].d + cnt;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; top; j++)&#123;</span><br><span class="line">            area[now] += <span class="built_in">cal</span>(cir[i], dot[j - <span class="number">1</span>], dot[j]);</span><br><span class="line">            now += dot[j].d;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CIRCLE cir[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//    Fastin;</span></span><br><span class="line">    <span class="keyword">int</span> t; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t); <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">clr</span>(area, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%lf %lf %lf&quot;</span>, &amp;cir[i].x, &amp;cir[i].y, &amp;cir[i].r);</span><br><span class="line">        <span class="built_in">cirunion</span>(cir, n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">printf</span>(<span class="string">&quot;%.5f\n&quot;</span>, area[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><del>因为网上基本没有讲解只有代码..oi-wiki甚至好像都没有收录这个算法，所以我学了好久才…</del></p><p>下面是简单的个人理解</p><p>在主算法<code>cirunion</code>中，先将圆按照半径从小到大排序，接下来顺序遍历这些圆，$O(n^2)$地找出每个圆被另外的圆完全包含的次数，为后面的计算作准备。然后枚举每一个圆，考虑这个圆参与的重叠面积的求解：遍历其他所有圆，记录所有的交点，同时计算出这些交点对于圆心的角度(angle)，给每一个交点一个标记(d)用来之后处理重叠的次数。最后对这些交点排序，按照逆时针顺序遍历交点，更新area。</p><p>总体思路如上，但是具体细节我扣了很久。</p><ul><li>在计算交点的时候，通过余弦定理获得角度，然后根据旋转的矩阵变换得到两个方向（逆时针和顺时针）的交点。</li><li>atan的值域只有<code>(-pi/2, pi/2)</code>，所以采用了<code>atan2(int y, int x)</code>，记录复数的幅角，范围为<code>(-pi, pi]</code>。</li><li>我们按照幅角angle排序，那么遍历的时候就是进行逆时针的遍历，从而如果遇到了通过逆时针操作得到的交点应该置d为1，表示此后的这段区域多一个圆重叠，而遇到了顺时针操作得到的交点应该置d为-1，表示此后这个弧就不再相交了，重叠的圆少一个。</li><li>在最后的更新的时候，维护当前重叠的圆的个数。我们从-pi的位置开始逆时针转，因为不知道最开始有多少个弧已经经过了-pi这个位置，所以之前在更新的时候要记录cnt值。而cnt值是这样产生的：因为在上述算法中p1是顺时针构造出的交点，p2是逆时针构造出的交点，所以如果不存在<code>(-pi, pi]</code>的限制p1的角度总是大于p2的，但是因为有了这个限制，所以如果这两个角度跨越了-pi，就会出现p2的角度大于p1，因而就可以根据p2的角度是否大于p1来判断这一条弧是否跨越了-pi。但是cnt值只能表示跨越了-pi的弧个数，实际在-pi处不一定有一个交点，言下之意就是起点不一定从-pi开始，那么cnt值难道根据第一个点的角度动态变化？实际上并不需要，我们添加两个冗余交点，坐标均为<code>(x - r, y)</code>，半径无关紧要，角度分别为-pi, pi, d值分别为2, -2。这样就可以保证在cmp比较符下这两个点一定是这个序列的第一个数和最后一个数。那么从这个-pi点开始的话，就可以通过cnt轻而易举的得知相交的那些弧的个数，再加上完全覆盖当前圆的个数，就得到了初值。之后遇到一个交点就根据它的标记更新当前重叠的个数即可。</li><li>最后一点是，如何根据遍历相邻的点对来获得重叠面积。这一个问题我想了非常久，因为之前没有计算几何的基础，所以百思不得其解。观察cal函数，前两项<code>sqr(a.r) * (p2.angle - p1.angle) - cross(a, p1, p2)</code>得到了弓形面积（钝角时因为cross是有向面积所以最终结果也是弓形），但是第三项…后来忽然意识到，多边形的面积好像就是通过不断地对一个固定点求有向面积最终求和即可，那么这边也就受到了启发：如果某个区域有若干的圆重叠得到，那么可以预想将那些相邻的交点相连，除去所有的弓形，剩下的就是一个多边形的面积，而这个面积就可以通过对一个定点求有向面积得到。但是这里并不是一次性求出来所有的邻边对应的有向面积，因为该算法遍历所有的圆，并且上述的每一个邻边上的两个点一定属于?</li></ul>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算几何 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2016-icpc-qingdao</title>
      <link href="/2020/06/30/2016-icpc-qingdao/"/>
      <url>/2020/06/30/2016-icpc-qingdao/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><p>参考说明：</p><p><a href="https://github.com/ftiasch/icpc-camp-wiki/commit/83642c220274db20ae5f86caa958029b2cbb2f9c">added saltyfish/2016 ACM/ICPC Asia Regional Qingdao Onsite.page</a></p><p><a href="https://github.com/ftiasch/icpc-camp-wiki/blob/364abdcbedef99104107d01e64152fa0e492bade/post/Post%20640.page">Fibnacci</a></p><hr><h2 id="D-概率"><a href="#D-概率" class="headerlink" title="D 概率"></a>D 概率</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">qp</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(p)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p &amp; <span class="number">1</span>) ans *= a;</span><br><span class="line">        a *= a; p &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> num[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">double</span> p[<span class="number">20</span>], ans[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//除了x硬币其余硬币活不到第k轮的概率</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">sove</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == x) <span class="keyword">continue</span>;</span><br><span class="line">        ans *= <span class="built_in">qp</span>((<span class="number">1</span> - <span class="built_in">qp</span>(p[i], k)), num[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//    Fastin;</span></span><br><span class="line">    <span class="keyword">int</span> t; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t); <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">        <span class="built_in">fro</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d %lf&quot;</span>, num + i, p + i);</span><br><span class="line">            ans[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;1.000000\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//实验100轮</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++) <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; n; x++)&#123;</span><br><span class="line">                ans[x] += (<span class="built_in">sove</span>(x, i) - <span class="built_in">sove</span>(x, i - <span class="number">1</span>)) * (<span class="number">1</span> - <span class="built_in">qp</span>((<span class="number">1</span> - <span class="built_in">qp</span>(p[x], i)), num[x]));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%.6f&quot;</span>, ans[i]);</span><br><span class="line">                <span class="keyword">if</span>(i != n - <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">                <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>考虑所有三元组，图是若干个团之并的充要条件是不存在某个三元组中有两条边（实际上就是要满足传递性），于是任取一个有两条边的三元组，枚举加上剩下的边或者删除现有两条边之一，修改一条边之后会有$O(n)$个三元组受影响，暴力修改这些三元组，同时用一个队列+时间戳维护当前有两条边的三元组，搜$10$步即可，复杂度是$O(n^3+n3^{10})$</p>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 概率 </tag>
            
            <tag> 图论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2017-ICPC-jakarta</title>
      <link href="/2020/06/27/2017-ICPC-jakarta/"/>
      <url>/2020/06/27/2017-ICPC-jakarta/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><span id="more"></span><hr><h2 id="B-动态维护两个序列之间的最小差值"><a href="#B-动态维护两个序列之间的最小差值" class="headerlink" title="B 动态维护两个序列之间的最小差值"></a>B 动态维护两个序列之间的最小差值</h2><p>尝试将图二分染色。如果不能二分染色，那么两人无论初始处于什么位置一定都有某种策略走到同一个节点；如果能够二分染色，题目则等价转化求$min\{|u - v|\}, u∈A, v∈B$，并且支持在线修改，这种情况是我们要着重处理的问题。</p><p>为此，利用multiset作为一个<strong>有序容器</strong>来实现这个功能。</p><p>初始时将所有的<code>&lt;节点权值，节点类型&gt;</code>存入set，按照节点权值从小到大排序。显然最优的答案只可能出现在这个set中相邻的两个不同类型节点之间，因而再开设另一个multiset记录ans，ans纯粹作为一个多重集合使用。</p><p>有了如上的准备工作，每次查询只需要找出ans第一个元素即可；而修改则复杂一些：log地找到将要被修改的元素在set中的迭代器位置，检查其是否已经和左右两个节点配对并在ans中贡献过了答案，如果贡献过则应该在ans中删去一个该答案，再检查是否该位置被移除后左右两个节点互相配对产生答案，如果有可能则应该据此更新ans；处理完之前的影响后就可以在set中删除该值，插入新值；接下来考虑插入新值对set的影响，如果插入的值将之前两个配对的节点隔开了，则应该将ans中对应的答案删去，如果插入的值和左右两个节点有配对，也应该相应地更新答案。</p><p>总而言之，对于修改的操作必须要保证ans集合中是一一对应地存set中<strong>位置相邻且类型不同的节点的差值</strong> 。</p><p>因为是log复杂度，所以可以飞快地通过这道题。</p><p>然而最开始没有保证ans集合满足上述性质，在插入新值的时候认为旧值不会影响到最优解，就贪图方便没有删除被隔断的值；事实上，这样子就无法使得删去旧值时保证所有与该值配对的答案全部在ans中被删除，会残留一些更小的但本不应该存在的值。</p><p>另一个坑点是，multiset的erase支持迭代器删除和按键值删除；使用迭代器删除只会删除指向的这一项，<strong>而按键值删除会把所有等于该值的元素全部删除！</strong><del>qaq</del></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> itn maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span><span class="keyword">int</span> to, next;&#125;edge[maxn &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> head[maxn], top = <span class="number">0</span>, w[maxn];;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    edge[top].to = v;</span><br><span class="line">    edge[top].next = head[u];</span><br><span class="line">    head[u] = top++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-1表示未染色。</span></span><br><span class="line"><span class="keyword">int</span> c[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> op)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(c[now] != <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(c[now] != op) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    c[now] = op;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[now]; ~i; i = edge[i].next)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">check</span>(edge[i].to, !op)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NODE</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> key, type;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> NODE &amp;b)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(key != b.key) <span class="keyword">return</span> key &lt; b.key;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> type &lt; b.type;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">multiset&lt;NODE&gt; s;</span><br><span class="line">multiset&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 如果要修改一个数，在s中找到它的迭代器，将它可能的已经产生的差值(一左一右)从ans中删去</span></span><br><span class="line"><span class="comment"> 删去这个数，插入新数。</span></span><br><span class="line"><span class="comment"> 不需要考虑新数对原有结构的影响，直接用新数左右两端的信息更新ans</span></span><br><span class="line"><span class="comment"> UPD: 这是错的！必须要考虑！</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> 如果要查询，看类型、flag等相关信息直接查询就行了...</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//    Fastin;</span></span><br><span class="line">    <span class="built_in">clr</span>(c, <span class="number">-1</span>); <span class="built_in">clr</span>(head, <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, w + i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, u, v; i &lt; m; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">        <span class="built_in">add</span>(u, v); <span class="built_in">add</span>(v, u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="built_in">check</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    multiset&lt;NODE&gt;::iterator p, q;</span><br><span class="line">    <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) s.<span class="built_in">insert</span>(&#123;w[i], c[i]&#125;);</span><br><span class="line">        p = s.<span class="built_in">begin</span>(); q = s.<span class="built_in">begin</span>(); q++;</span><br><span class="line">        <span class="keyword">for</span>(; q != s.<span class="built_in">end</span>(); p++, q++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;type != q-&gt;type)&#123;</span><br><span class="line">                ans.<span class="built_in">insert</span>(<span class="built_in">abs</span>(p-&gt;key - q-&gt;key));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> query; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;query); <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; query; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> op, x, y; <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;op, &amp;x, &amp;y);</span><br><span class="line">        <span class="keyword">if</span>(!flag)&#123;</span><br><span class="line">            <span class="keyword">if</span>(op) <span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(op == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//w[x] := y;</span></span><br><span class="line">            p = s.<span class="built_in">find</span>(&#123;w[x], c[x]&#125;);</span><br><span class="line">            NODE t1, t2; t1.type = t2.type = <span class="number">-1</span>;</span><br><span class="line">            q = p; q--; <span class="keyword">if</span>(p != s.<span class="built_in">begin</span>())&#123;</span><br><span class="line">                t1 = *q;</span><br><span class="line">                <span class="keyword">if</span>(t1.type != c[x]) ans.<span class="built_in">erase</span>(ans.<span class="built_in">find</span>(<span class="built_in">abs</span>(w[x] - t1.key)));</span><br><span class="line">            &#125;</span><br><span class="line">            q = p; q++; <span class="keyword">if</span>(q != s.<span class="built_in">end</span>())&#123;</span><br><span class="line">                t2 = *q;</span><br><span class="line">                <span class="keyword">if</span>(t2.type != c[x]) ans.<span class="built_in">erase</span>(ans.<span class="built_in">find</span>(<span class="built_in">abs</span>(w[x] - t2.key)));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(t1.type != <span class="number">-1</span> &amp;&amp; t2.type != <span class="number">-1</span> &amp;&amp; t1.type != t2.type) ans.<span class="built_in">insert</span>(<span class="built_in">abs</span>(t1.key - t2.key));</span><br><span class="line">            </span><br><span class="line">            s.<span class="built_in">erase</span>(p); w[x] = y; s.<span class="built_in">insert</span>(&#123;y, c[x]&#125;);</span><br><span class="line">            t1.type = t2.type = <span class="number">-1</span>; p = s.<span class="built_in">find</span>(&#123;w[x], c[x]&#125;);</span><br><span class="line">            q = p; q--; <span class="keyword">if</span>(p != s.<span class="built_in">begin</span>())&#123;</span><br><span class="line">                t1 = *q;</span><br><span class="line">                <span class="keyword">if</span>(t1.type != c[x]) ans.<span class="built_in">insert</span>(<span class="built_in">abs</span>(w[x] - t1.key));</span><br><span class="line">            &#125;</span><br><span class="line">            q = p; q++; <span class="keyword">if</span>(q != s.<span class="built_in">end</span>())&#123;</span><br><span class="line">                t2 = *q;</span><br><span class="line">                <span class="keyword">if</span>(t2.type != c[x]) ans.<span class="built_in">insert</span>(<span class="built_in">abs</span>(w[x] - t2.key));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(t1.type != <span class="number">-1</span> &amp;&amp; t2.type != <span class="number">-1</span> &amp;&amp; t1.type != t2.type) ans.<span class="built_in">erase</span>(ans.<span class="built_in">find</span>(<span class="built_in">abs</span>(t1.key - t2.key)));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(c[x] == c[y]) <span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *ans.<span class="built_in">begin</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="C-贪心构造"><a href="#C-贪心构造" class="headerlink" title="C 贪心构造"></a>C 贪心构造</h2><p>如果没有等于号，最坏的构造一下，最后判断一下是否确实不存在等于的情况。</p><p>如果有等于号，考虑从最坏的为基准开始构造：</p><p>因为每次从两端开始询问会使得可能的答案个数-1，因而如果全部最坏询问，可能的答案个数就是<code>n - [询问次数]</code> 。</p><p>考虑每一次二分都尽可能多排除一些可能答案，使得剩余的可能答案尽快为1。那么显而易见，每次根据不等号方向确定区间收缩方向，进而确定最远收缩的位置。如果收缩到最远位置仍然有不止一个可能答案那么就最优的选择这里，不然的话就可以选择恰好为1个答案的位置进行收缩。当剩余答案仅为1时，每次就不需要多排除答案了，最坏的进行排除答案即可。</p><p>因为读题有误没有注意到奇数长度的中点保证返回’&lt;’<del>以及vj上这道题的评测机炸了</del>所以吃了1000发WA</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">5e4</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">char</span> s[maxn];</span><br><span class="line"></span><br><span class="line">ll n, k;</span><br><span class="line">vector&lt;ll&gt; vec;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//    Fastin;</span></span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%lld %lld&quot;</span>, &amp;n, &amp;k))&#123;</span><br><span class="line">        vec.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s); <span class="keyword">int</span> top = (<span class="keyword">int</span>)<span class="built_in">strlen</span>(s);</span><br><span class="line">        <span class="keyword">if</span>(top == k &amp;&amp; s[top - <span class="number">1</span>] != <span class="string">&#x27;=&#x27;</span>)&#123;</span><br><span class="line">            ll left = <span class="number">1</span>, right = n;</span><br><span class="line">            itn fail = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; top; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i] == <span class="string">&#x27;&lt;&#x27;</span>)&#123;</span><br><span class="line">                    vec.<span class="built_in">push_back</span>(right); right--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    vec.<span class="built_in">push_back</span>(left); left++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(left &gt; right)&#123;</span><br><span class="line">                    fail = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(fail) <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> x: vec) <span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>, x); <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//猜到了</span></span><br><span class="line">            ll r = n - top;</span><br><span class="line">            <span class="keyword">if</span>(r &lt; <span class="number">0</span>) <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                ll left = <span class="number">1</span>, right = n;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; top - <span class="number">1</span>; i++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(s[i] == <span class="string">&#x27;&gt;&#x27;</span>)&#123;</span><br><span class="line">                        ll M = (right + left - <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">if</span>(M - left &gt;= r)&#123;</span><br><span class="line">                            vec.<span class="built_in">push_back</span>(left + r);</span><br><span class="line">                            left = left + r + <span class="number">1</span>;</span><br><span class="line">                            r = <span class="number">0</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span>&#123;</span><br><span class="line">                            vec.<span class="built_in">push_back</span>(M);</span><br><span class="line">                            r -= M - left;</span><br><span class="line">                            left = M + <span class="number">1</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        ll m = (left + right + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">if</span>(right - m &gt;= r)&#123;</span><br><span class="line">                            vec.<span class="built_in">push_back</span>(right - r);</span><br><span class="line">                            right = right - r - <span class="number">1</span>;</span><br><span class="line">                            r = <span class="number">0</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span>&#123;</span><br><span class="line">                            vec.<span class="built_in">push_back</span>(m);</span><br><span class="line">                            r -= right - m;</span><br><span class="line">                            right = m - <span class="number">1</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(left != right) <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    vec.<span class="built_in">push_back</span>(left);</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">auto</span> x: vec) <span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>, x); <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><p>也是读题有误，从签到题到ak题</p><p>没有注意到给出的每一条边都是有向边，所以最开始不知道用哪一端去粘，就gg了</p><p>知道了的话随便记录一下剩余可用的度数即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> itn maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line">unordered_map&lt;ll, <span class="keyword">int</span>&gt; tong;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NODE</span>&#123;</span></span><br><span class="line">    ll u, v, w;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> NODE &amp;b)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> w &lt; b.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;node[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//    Fastin;</span></span><br><span class="line">    <span class="keyword">int</span> n, m; <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%lld %lld %lld&quot;</span>, &amp;node[i].u, &amp;node[i].v, &amp;node[i].w);</span><br><span class="line">    <span class="built_in">sort</span>(node, node + n);</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">fro</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(tong.<span class="built_in">count</span>(node[i].u) == <span class="number">0</span> || tong[node[i].u] == <span class="number">0</span>)&#123;</span><br><span class="line">            ans++;</span><br><span class="line">            tong[node[i].u] = m - <span class="number">1</span>;</span><br><span class="line">            tong[node[i].v] += m;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            tong[node[i].u]--;</span><br><span class="line">            tong[node[i].v] += m;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="F-期望dp"><a href="#F-期望dp" class="headerlink" title="F 期望dp"></a>F 期望dp</h2><p><del>确实是个没有写过的方法qaq</del></p><p>具体有哪几个数出现过我们不用关心，我们只需要记录状态(x, y, z)分别表示出现0次、1次、不少于2次的数的总个数即可。</p><p>设<code>dp[x][y][z]</code>表示从当前状态开始到停机所需要的次数的期望。</p><p>容易有递推关系</p><p>$dp[x][y][z] = 1 + \frac xn dp[x-1][y+1][z] + \frac yndp[x][y-1][z+1] + \frac zndp[x][y][z]$</p><p>最开始看到这个式子感到非常神奇</p><p>仔细想了一下感觉确实很符合期望的表达</p><p>当前状态操作1次分别有$\frac xn \frac yn \frac zn$的几率转移到上述三种状态，因而加权(即转移的概率)求和再加1后就得到当前的操作期望。</p><p><del>虽然具体所以然说不真切，但是感觉上还是很精妙的</del></p><p><del>留个期望dp的坑待补</del></p><p>之后做两个优化：</p><ul><li>由$x + y + z = n$ 从3维优化到2位</li><li>化简后发现期望之间的转移关系与$n$成正比，启示我们求解$\frac {dp}n$ 的状态，将复杂度从$O(nT)$降低到$O(n)$</li></ul><p>化简后得到L10-12行所示的公式，因为hexo-next好像不太支持\frac和其他一些公式的组合嵌套，所以就不放乱码上来了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> itn maxn = <span class="number">3e3</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> dp[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> tong[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//    Fastin;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; maxn; j++) dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j - <span class="number">1</span>] + <span class="number">1.0</span> / j;</span><br><span class="line">    <span class="built_in">fro</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; maxn; i++) <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; i + j &lt; maxn; j++)&#123;</span><br><span class="line">        dp[i][j] = <span class="number">1</span> + i * dp[i - <span class="number">1</span>][j + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(j &gt;= <span class="number">1</span>) dp[i][j] += j * dp[i][j - <span class="number">1</span>];</span><br><span class="line">        dp[i][j] = dp[i][j] * <span class="number">1.0</span> / (i + j);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> t; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t); <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">clr</span>(tong, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> n, k; <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;k);</span><br><span class="line">        <span class="keyword">int</span> cnt0 = <span class="number">0</span>, cnt1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, x; i &lt; k; i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x); tong[x]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(tong[i] == <span class="number">0</span>) cnt0++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(tong[i] == <span class="number">1</span>) cnt1++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%.15f\n&quot;</span>, n * dp[cnt0][cnt1]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="L-状态压缩-amp-容斥"><a href="#L-状态压缩-amp-容斥" class="headerlink" title="L 状态压缩 &amp; 容斥"></a>L 状态压缩 &amp; 容斥</h2><p>题目要求每行都有至少一个稻草人，相邻两列至少有一个稻草人。</p><p>思想与校赛类似，先优先考虑一个，之后利用朴素的容斥满足另一个。</p><p>枚举行的子集，求解这些行只考虑列方向上的约束关系的排列个数。可以用dp进行$O(m)$的求解:</p><p>$dp[i][0] = dp[i - 1][1]$</p><p>$dp[i][1] = (dp[i - 1][0] + dp[i -1][1]) * (2^{cnt_i} - 1),$</p><p>其中$cnt_i$表示第$i$列拥有空地的个数。</p><p>这里注意总列数为1的时候有<code>dp[0][0] = 0</code>，其余情况下都有<code>dp[0][0] = 1</code>，需要特判一下。</p><p>因为仅满足了列上的约束，所以求得的dp值满足行上要求的行个数至多为r，r是当前枚举的行的子集的大小。</p><p>为了要求恰有n行，可以从&lt;=n行减去所有&lt;=n-1行的情况，这样仅保证所有恰为n-1的情况都被不重不漏得减去，但是&lt;=n-2的情况会被重复剪去，因而要加上所有的&lt;=n-2的情况…之后一加一减以此类推</p><p>不过这样说明是不严谨的，应该用容斥原理说明。</p><p><del>之前就没有补完知识点，现在还是，所以就先继续🐦着了。</del></p><p>时间复杂度必须压缩在$O(2^r*C)$，再多个$r$就爆了，必须要妥善的预处理才行。</p><p>另外空间也有点紧(？)评测机说可以512MB，本地跑下来300MB还是内存溢出。不过后来意识到没有必要存储每次的dp值最后再遍历，直接在处理完当前状态后实时将结果添加到答案中就行了。这样就可以AC了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">15</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">1e3</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> pow2[maxn];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">char</span> mp[maxn][maxm];</span><br><span class="line"><span class="keyword">int</span> cnt[<span class="number">1</span> &lt;&lt; maxn][maxm], vis[<span class="number">1</span> &lt;&lt; maxn];</span><br><span class="line">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; nxt[<span class="number">1</span> &lt;&lt; maxn];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; order[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count_1</span><span class="params">(<span class="keyword">int</span> sts)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="keyword">if</span>(sts &amp; <span class="number">1</span> &lt;&lt; i) cnt++;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ini</span><span class="params">(<span class="keyword">int</span> sts)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(vis[sts]) <span class="keyword">return</span>; vis[sts] = <span class="number">1</span>;</span><br><span class="line">    order[<span class="built_in">count_1</span>(sts)].<span class="built_in">push_back</span>(sts);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="keyword">if</span>((sts &amp; <span class="number">1</span> &lt;&lt; i) == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nxt[sts].first == <span class="number">-1</span>)&#123;</span><br><span class="line">            nxt[sts].first = sts | <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">            nxt[sts].second = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">ini</span>(sts | <span class="number">1</span> &lt;&lt; i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll a[maxm][<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sove</span><span class="params">(<span class="keyword">int</span> sts)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *b = cnt[sts];</span><br><span class="line">    a[<span class="number">0</span>][<span class="number">0</span>] = m == <span class="number">1</span>? <span class="number">0</span>: <span class="number">1</span>;</span><br><span class="line">    a[<span class="number">0</span>][<span class="number">1</span>] = pow2[b[<span class="number">0</span>]] - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++)&#123;</span><br><span class="line">        a[i][<span class="number">0</span>] = a[i - <span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">        a[i][<span class="number">1</span>] = (a[i - <span class="number">1</span>][<span class="number">0</span>] + a[i - <span class="number">1</span>][<span class="number">1</span>]) % M * <span class="number">1ll</span> * (pow2[b[i]] - <span class="number">1</span>) % M;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">sgn</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">return</span> x &amp; <span class="number">1</span>? <span class="number">-1</span>: <span class="number">1</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//    Fastin;</span></span><br><span class="line">    pow2[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">fro</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; maxn; i++) pow2[i] = <span class="number">2</span> * pow2[i - <span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="built_in">clr</span>(nxt, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, mp[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">ini</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> sts = (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; m; c++) <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) cnt[sts][c] += mp[i][c] == <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i--) <span class="keyword">for</span>(<span class="keyword">auto</span> x: order[i])&#123;</span><br><span class="line">        <span class="keyword">if</span>(i != n) <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) cnt[x][i] = cnt[nxt[x].first][i] - (mp[nxt[x].second][i] == <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">        <span class="built_in">sove</span>(x);</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="built_in">count_1</span>(x);</span><br><span class="line">        ans += <span class="built_in">sgn</span>(n - cnt) * (a[m - <span class="number">1</span>][<span class="number">0</span>] + a[m - <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">        ans = (ans % M + M) % M;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> multiset </tag>
            
            <tag> 期望dp </tag>
            
            <tag> 状态压缩 </tag>
            
            <tag> 容斥原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF-1373E</title>
      <link href="/2020/06/27/CF-1373E/"/>
      <url>/2020/06/27/CF-1373E/</url>
      
        <content type="html"><![CDATA[<p>其实是一道比较简单的暴力构造题（？）</p><p>但是因为没有往这方面去考虑所以就…</p><p><del>正如之前看到过 第一个造原子弹的国家才是真正厉害的 因为这是开辟一条从0到1的道路 后面的效仿者已知结果可行再去效仿就容易很多</del></p><span id="more"></span><hr><p>这道题中最麻烦的地方在于如果产生进位会如何影响结果。</p><p>如果一个数末尾有连续k个9，那么对其加1后其数码之和会变化<code>+1 - 9k</code>。</p><p>得知这个规律后就可以将$f(x) + f(x + 1) + …+f(x + k)$写成</p><p>$(k + 1) <em> f(x) + \frac{k </em> (k + 1)}{2} - 9 <em> cnt </em> k$</p><p>其中，$cnt$表示$f(x)…f(x +k)$其中会产生进位的数字的个数，$k$表示进位后会受到影响的9的个数。</p><p>当我们枚举n、k时，可以再枚举<strong>cnt</strong>（因为k已经给定，所以只有末尾数字dig影响cnt的值，因而枚举cnt即枚举dig）以及<strong>k</strong>，每次看是否存在一个$f(x)$满足等式条件。如果满足整除条件，就利用参数$cnt(dig)、k、f(x)$进行构造并更新答案。</p><p>每次构造先用$dig、k$填充低位，然后根据剩余的数码和构造高位。显然优先填够9，让总位数尽可能最小；当剩余数码不超过9时，直接填入该数码即可。有一个要注意的地方，因为枚举的$k$是末尾连续9的个数，所以当填充完$dig$和$k$个9后，下一位不能继续填9，而应该用8去填充作为分割。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">200</span>;</span><br><span class="line"><span class="keyword">const</span> ll inf = <span class="number">1ll</span> &lt;&lt; <span class="number">62</span>;</span><br><span class="line">ll ans[maxn][<span class="number">15</span>];</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">make</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k, <span class="keyword">int</span> last, <span class="keyword">int</span> num, <span class="keyword">int</span> sum)</span></span>&#123;</span><br><span class="line">    sum -= last; sum -= <span class="number">9</span> * num;</span><br><span class="line">    vec.<span class="built_in">clear</span>(); vec.<span class="built_in">push_back</span>(last);</span><br><span class="line">    <span class="keyword">while</span>(num--) vec.<span class="built_in">push_back</span>(<span class="number">9</span>);</span><br><span class="line">    <span class="keyword">if</span>(sum &lt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(sum &gt;= <span class="number">8</span>)&#123;</span><br><span class="line">        <span class="comment">//作为分割符</span></span><br><span class="line">        vec.<span class="built_in">push_back</span>(<span class="number">8</span>);</span><br><span class="line">        sum -= <span class="number">8</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(sum &gt; <span class="number">9</span>)&#123;</span><br><span class="line">        vec.<span class="built_in">push_back</span>(<span class="number">9</span>); sum -= <span class="number">9</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(sum) vec.<span class="built_in">push_back</span>(sum);</span><br><span class="line">    </span><br><span class="line">    ll res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> top = (<span class="keyword">int</span>)vec.<span class="built_in">size</span>(); <span class="keyword">if</span>(top &gt; <span class="number">60</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = top - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        res *= <span class="number">10</span>;</span><br><span class="line">        res += vec[i];</span><br><span class="line">    &#125;</span><br><span class="line">    ans[n][k] = <span class="built_in">min</span>(ans[n][k], res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sove</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> len = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> n = <span class="number">1</span>; n &lt;= <span class="number">150</span>; n++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= <span class="number">9</span>; k++)&#123;</span><br><span class="line">            <span class="comment">//f[x] * (k + 1) + (1 + ... + k) - 9 * 数的个数 * 每个数中末尾连续9的个数 = n。</span></span><br><span class="line">            <span class="comment">//其中k是给定的，数的个数通过调节最后一位来控制，9的个数直接枚举.</span></span><br><span class="line">            <span class="keyword">int</span> now = n - (k + <span class="number">1</span>) * k / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> dig = <span class="number">0</span>; dig &lt;= <span class="number">9</span>; dig++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> num = <span class="number">0</span>; num &lt; len; num++)&#123;</span><br><span class="line">                    <span class="keyword">int</span> cnt = <span class="built_in">max</span>(<span class="number">0</span>, dig + k - <span class="number">10</span> + <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">if</span>((now + <span class="number">9</span> * (num + <span class="number">1</span>) * cnt) % (k + <span class="number">1</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="built_in">make</span>(n, k, dig, num, ((now + <span class="number">9</span> * (num + <span class="number">1</span>) * cnt) / (k + <span class="number">1</span>)));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxn; i++) <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">15</span>; j++) ans[i][j] = inf;</span><br><span class="line">    <span class="built_in">sove</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//    Fastin;</span></span><br><span class="line">    <span class="keyword">int</span> t; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t); <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="keyword">int</span> n, k; <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;k);</span><br><span class="line">        <span class="keyword">if</span>(ans[n][k] - inf) <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans[n][k]);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 构造 </tag>
            
            <tag> 数码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF-#651-div2</title>
      <link href="/2020/06/21/CF-651-div2/"/>
      <url>/2020/06/21/CF-651-div2/</url>
      
        <content type="html"><![CDATA[<p>值得注意的题：<strong>F</strong> 树上二分 &amp; 交互</p><span id="more"></span><hr><p><strong>A</strong></p><p>显然是$floor(n/2)$</p><p><strong>B</strong></p><p>为什么一定存在呢？分奇偶项后就容易说明了。</p><p><strong>C</strong></p><p>最开始读错题了，以为必须要奇素因子…不需要的话只需要分类考虑一下奇数因子的个数和2的个数即可。</p><p><strong>B</strong></p><p>为什么一定存在呢？分奇偶项后就容易说明了。</p><p><strong>C</strong></p><p>最开始读错题了，以为必须要奇素因子…不需要的话只需要分类考虑一下奇数因子的个数和2的个数即可。</p><p><strong>D</strong></p><p>二分答案。</p><p><strong>E</strong></p><p>在一个序列中提取出形如<code>xyxy..xy</code>的子序列，要求这些序列个数最小（即每一个长度尽可能大）。</p><p>最开始只想到循环…模拟…然而时间复杂度上应该是过不去</p><p>后来意识到这nm不就是个傻逼题，直接维护当前以0、1结尾的串的个数。顺序扫一遍上述序列，遇到(比如)0就看是否至少有一个1结尾的串，有的话就将这个串变成0结尾，更新两种串的个数；不然的话ans++新建一个串。</p><p><strong>F</strong></p><p>原来茴香豆的茴真的有四种写法…qaq</p><p>场上打的时候其实没认为自己可以做出来，最后还剩的半个小时忽然意识到好像F1是可以随意二分做出来的，但是当时已经不太写得动了，勉勉强强交了个丑陋的代码T1(忘记fflush了)。</p><p>今天看正解发现之前的算法还是太过于繁琐。可以先找出路径上某一个点作为根，然后二分深度找某一个答案点，因为最深可能到达1e3，所以至多会花费10次二分查询，得到了某个答案点后查询距离它为$l$（$l$是最短路径的长度）的所有点就可以获得另一个答案点。这样的算法总共花费<code>1 + 10 + 1</code>次查询，还得精简掉一次才能符合题目要求。注意到无论得到两个点中的哪一个都可以再花费一次查询找到另一个点，而在这棵树上一定这两个点一定一高一低，故我们可以将二分的范围缩小一倍，这样就可以省下一次从而满足要求。</p><p>事实上上述分析正确无误，我写挂了靠近10发的原因还是在于茴香豆写的不够多。</p><p>在这道题中如果某个深度可以那么应该将left提高到middle，如果不可以则将right降低到middle - 1；</p><p>我平常喜欢的二分方式如下: </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">middle = (left + right + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">if</span>(<span class="built_in">check</span>(middle, ans1)) left = middle;</span><br><span class="line">  <span class="keyword">else</span> right = middle - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这种写法的会多花费若干次的查询。</p><p>如果查询区间<code>[1, 2]</code>，此时<code>middle=2</code>；如果<code>middle</code>成立，那么皆大欢喜，middle所在的状态中答案点得到更新；不然，<code>right</code>下降到1，尽管答案已经夹逼获得，但是我们并不知道在这个深度下哪一个点是我们要的答案点，因而还需要花费一次查询找到答案点。 </p><p>如果查询区间<code>[1, 3]</code>，此时<code>middle=2</code>；如果middle成立，结合上述<code>[1, 2]</code>的情况，至多要花费3次查询。这太不妙了！</p><p>正确的二分方式应该如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">  middle = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">check</span>(middle, ans1)) left = middle + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">else</span> right = middle - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类似的讨论一下区间<code>[1, 2]</code>, <code>[1, 3]</code>的情况会发现，最坏也只需要查询2次就可以获得结果，更大的情况也可以据此分析出来。</p><p>究其原理，我认为是这道题中要求的是最大的满足条件的位置(1 1 1 .. 1 <strong>1</strong> 0 0 0.. 00)，并且我们需要在check的同时求出关于当前位置的某些相关参量，所以就不能采用第一种方法的向上取整、夹逼得到结果的手段，这会使得某些1位置的<strong>答案</strong>是从0夹逼得来，其<strong>参量</strong>却需要花费额外的代价去求解。而采用第二种方法则是不断的从可行状态往后进行压缩，每次的<code>`middle</code>值都是从1状态开始考虑，同时也进行相关参量的求解，这样最终就不需要花费额外的代价得到想要的结果。</p><p><code>AC代码</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e3</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">star</span>&#123;</span><span class="keyword">int</span> to, next;&#125;;</span><br><span class="line"></span><br><span class="line">star edge[maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> n, head[maxn], top = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    edge[top].to = v;</span><br><span class="line">    edge[top].next = head[u];</span><br><span class="line">    head[u] = top++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; ask;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> &amp;d)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;? %d &quot;</span>, (<span class="keyword">int</span>)ask.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x: ask) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, x); <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">fflush</span>(stdout);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;x, &amp;d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> l, ans1, ans2;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ok</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;! %d %d\n&quot;</span>, ans1, ans2);</span><br><span class="line">    <span class="built_in">fflush</span>(stdout);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">judge</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> temp[<span class="number">30</span>]; <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, temp);</span><br><span class="line">    <span class="keyword">if</span>(temp[<span class="number">0</span>] == <span class="string">&#x27;C&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> vis[maxn];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; vec[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> dep)</span></span>&#123;</span><br><span class="line">    vec[dep].<span class="built_in">push_back</span>(now); vis[now] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[now]; ~i; i = edge[i].next)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[edge[i].to]) <span class="built_in">dfs</span>(edge[i].to, dep + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> dep, <span class="keyword">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    ask.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x: vec[dep]) ask.<span class="built_in">push_back</span>(x);</span><br><span class="line">    <span class="keyword">int</span> temp, d; <span class="built_in">query</span>(temp, d);</span><br><span class="line">    <span class="keyword">if</span>(d == l) x = temp;</span><br><span class="line">    <span class="keyword">return</span> d == l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfss</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> dep)</span></span>&#123;</span><br><span class="line">    vis[now] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(dep == l)&#123;</span><br><span class="line">        ask.<span class="built_in">push_back</span>(now);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[now]; ~i; i = edge[i].next)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[edge[i].to]) <span class="built_in">dfss</span>(edge[i].to, dep + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//    Fastin;</span></span><br><span class="line">    <span class="keyword">int</span> t; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t); <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">clr</span>(head, <span class="number">-1</span>); top = <span class="number">0</span>; <span class="built_in">clr</span>(vis, <span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n); <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) vec[i].<span class="built_in">clear</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> u, v; <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">            <span class="built_in">add</span>(u, v); <span class="built_in">add</span>(v, u);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ask.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) ask.<span class="built_in">push_back</span>(i);</span><br><span class="line">        <span class="keyword">int</span> rot; <span class="built_in">query</span>(rot, l);</span><br><span class="line">        <span class="built_in">dfs</span>(rot, <span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//找最远的那个点。</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="built_in">ceil</span>(l, <span class="number">2</span>), right = <span class="number">-1</span>, middle;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="keyword">if</span>(!vec[i].<span class="built_in">empty</span>()) right = i; right = <span class="built_in">min</span>(right, l);</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            middle = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">check</span>(middle, ans1)) left = middle + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> right = middle - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        if(ans1 == -1) check(left, ans1);</span></span><br><span class="line">        ask.<span class="built_in">clear</span>(); <span class="built_in">clr</span>(vis, <span class="number">0</span>); <span class="built_in">dfss</span>(ans1, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">query</span>(ans2, l);</span><br><span class="line">        <span class="built_in">ok</span>(); <span class="built_in">judge</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><del>qaq我居然🍊了…真的没有想到🍊了…</del></p><p>过年的magic小目标算是忽然实现了，接下来还是要好好训练努力保持在橙名qaq</p>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树上二分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>0619-weekly-test-B</title>
      <link href="/2020/06/19/0619-weekly-test-B/"/>
      <url>/2020/06/19/0619-weekly-test-B/</url>
      
        <content type="html"><![CDATA[<p>题目要求我们写一个指定语法的程序，要求这个程序能够输出指定fibnacci数列中的某一项，询问至多不超过30项。</p><!--- more ---><p>这道题目还是蛮新颖的，虽然不算很难，但是因为坑到我了…所以还是写篇简短的博客记录一番。</p><p>这道题目可行的程序很多<del>以至于WA了之后不知道怎么改</del>，我的算法是初始化<code>[n, 0, 1]</code>之后循环判断当前n是否为1，不是的话将<code>[n, y, x]</code>变成<code>[n - 1, x, x + y]</code>，然后再次jump到判断语句处。主要分成三个模块：判断是否为1，对n减一，变换<code>[y, x]</code>成为<code>[x, x + y]</code>。结合操作随意构造一番即可。</p><p>坑点在于，题目费了很大的劲说了约束条件，约束了程序执行的最大次数1e3..如果我们循环的次数超过33次的话，就无法在1000行以内跑完项数最大30的情况，也是这里导致我WA到自闭QAQ…优化算法之后即可成功AC。</p><p>以后读题目一定要仔细关注条件，不然总是死在奇奇怪怪的地方…</p><p><del>当时以为自己程序错了还写了个解释器却发现结果符合的很好qaq</del></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; x; i++) <span class="built_in">printf</span>(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">50</span>;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; vec = &#123;</span><br><span class="line">    <span class="number">4</span>, <span class="number">7</span>, <span class="number">8</span>,</span><br><span class="line">    <span class="number">8</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">12</span>, <span class="number">5</span>, <span class="number">3</span>, inf, <span class="number">6</span>,</span><br><span class="line">    <span class="number">7</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">13</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">12</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">6</span>,</span><br><span class="line">    <span class="number">7</span>, <span class="number">9</span>, <span class="number">11</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">1</span>,</span><br><span class="line">    <span class="number">8</span>, <span class="number">11</span>, <span class="number">6</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//    Fastin;</span></span><br><span class="line">    <span class="keyword">int</span> size = (<span class="keyword">int</span>)vec.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)&#123;</span><br><span class="line">        <span class="built_in">fun</span>(vec[i]);</span><br><span class="line">        <span class="keyword">if</span>(i != size - <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模拟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对拍程序</title>
      <link href="/2020/06/18/%E5%AF%B9%E6%8B%8D%E7%A8%8B%E5%BA%8F/"/>
      <url>/2020/06/18/%E5%AF%B9%E6%8B%8D%E7%A8%8B%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p>因为今天打比赛队友对拍出了一个错误结果，所以我也趁机自己写了一番这个一直没有实现的技术，用起来还是很舒爽的。</p><span id="more"></span><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;g++ ~/Desktop/data/data/main.cpp -std=c++11 -o data.out&quot;</span>);</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;g++ ~/Desktop/T/T/main.cpp -std=c++11 -o T.out&quot;</span>);</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;g++ ~/Desktop/ttt/ttt/main.cpp -std=c++11 -o ttt.out&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> times = <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;times);</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(times != <span class="number">0</span>)&#123;</span><br><span class="line">        times--;</span><br><span class="line">        <span class="built_in">system</span>(<span class="string">&quot;./data.out &gt;~/Desktop/in.txt&quot;</span>);</span><br><span class="line">        <span class="built_in">system</span>(<span class="string">&quot;./T.out &lt; ~/Desktop/in.txt &gt; ~/Desktop/out.txt&quot;</span>);</span><br><span class="line">        <span class="built_in">system</span>(<span class="string">&quot;./ttt.out &lt; ~/Desktop/in.txt &gt; ~/Desktop/ans.txt&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">system</span>(<span class="string">&quot;diff ~/Desktop/out.txt ~/Desktop/ans.txt&quot;</span>))&#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;Differences occur!&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;No.%d&#x27;s OK.\n&quot;</span>, cnt++);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 对拍 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>template</title>
      <link href="/2020/06/17/template/"/>
      <url>/2020/06/17/template/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><span id="more"></span><div STYLE="page-break-after: always;"></div><div STYLE="page-break-after: always;"></div><h2 id="1-字符串"><a href="#1-字符串" class="headerlink" title="1 字符串"></a>1 字符串</h2><h3 id="trie树"><a href="#trie树" class="headerlink" title="trie树"></a>trie树</h3><p>实现一：数组实现的按键查找</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxsize = <span class="number">26</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TRIE</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> ch[maxn][maxsize];</span><br><span class="line">    <span class="keyword">int</span> flag[maxn];</span><br><span class="line">    <span class="keyword">int</span> top = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//按照实际条件进行修改</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getid</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;<span class="keyword">return</span> c - <span class="string">&#x27;a&#x27;</span>;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//插入长度为n的字符串s[0,..n - 1]</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span> s[maxn], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> u = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> id = <span class="built_in">getid</span>(s[i]);</span><br><span class="line">            <span class="keyword">if</span>(!ch[u][id]) ch[u][id] = top++;</span><br><span class="line">            u = ch[u][id];</span><br><span class="line">        &#125;</span><br><span class="line">        flag[u] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">query</span><span class="params">(<span class="keyword">char</span> s[maxn], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> u = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> id = <span class="built_in">getid</span>(s[i]);</span><br><span class="line">            <span class="keyword">if</span>(!ch[u][id]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            u = ch[u][id];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag[u]) <span class="keyword">return</span> <span class="literal">true</span>; <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>实现二：数组实现的按边查找（左儿子右兄弟优化）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxsize = <span class="number">26</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxnode = maxn * maxsize;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TRIE</span>&#123;</span></span><br><span class="line"><span class="comment">//    vector&lt;int&gt; head, next;</span></span><br><span class="line"><span class="comment">//    vector&lt;char&gt; ch;</span></span><br><span class="line">    <span class="keyword">int</span> head[maxnode], next[maxnode];</span><br><span class="line">    <span class="keyword">char</span> ch[maxnode];</span><br><span class="line">    <span class="keyword">bool</span> flag[maxnode];</span><br><span class="line">    <span class="keyword">int</span> top = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span> s[maxn], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> u = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> find = <span class="number">0</span>, v;</span><br><span class="line">            <span class="keyword">for</span>(v = head[u]; v; v = next[v]) <span class="keyword">if</span>(ch[v] == s[i])&#123;</span><br><span class="line">                find = <span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!find)&#123;</span><br><span class="line">                v = top++;</span><br><span class="line">                ch[v] = s[i];</span><br><span class="line">                next[v] = head[u];</span><br><span class="line">                head[u] = v;</span><br><span class="line">            &#125;</span><br><span class="line">            u = v;</span><br><span class="line">        &#125;</span><br><span class="line">        flag[u] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">query</span><span class="params">(<span class="keyword">char</span> s[maxn], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> u = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> find = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> v = head[u]; v; v = next[v]) <span class="keyword">if</span>(ch[v] == s[i])&#123;</span><br><span class="line">                find = <span class="number">1</span>; u = v; <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!find) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag[u]) <span class="keyword">return</span> <span class="literal">true</span>; <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>实现二倒是第一次见，与实现一的区别大概就是邻接表与邻接矩阵的区别。</p><p>在对于空间要求更加特殊的环境中可以用<code>实现二</code>优化空间<del>然而总感觉不用vector的话空间消耗比实现一更大？</del>，具体的情况等以后遇到了再修改板子。</p><h3 id="Manacher"><a href="#Manacher" class="headerlink" title="Manacher"></a>Manacher</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> Manacher算法</span></span><br><span class="line"><span class="comment"> 读入一个字符串temp及其长度n;</span></span><br><span class="line"><span class="comment"> 该算法构造出s并赋予截断标志, 自动初始化、获得数组p[i];</span></span><br><span class="line"><span class="comment"> 对于某个位置i∈[0, 2 * n], 以i为中心的回文串的参数如下:</span></span><br><span class="line"><span class="comment">    int start = (i / 2) - (p[i] / 2) + (i &amp; 1), d = p[i] - 1;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">char</span> temp[maxn], s[maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> p[maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">manacher</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//scanf(&quot;%s&quot;, temp);</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        s[i &lt;&lt; <span class="number">1</span>] = <span class="string">&#x27;#&#x27;</span>; s[i &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] = temp[i];</span><br><span class="line">    &#125;</span><br><span class="line">    s[n &lt;&lt; <span class="number">1</span>] = <span class="string">&#x27;#&#x27;</span>; s[n &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> id = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n &lt;&lt; <span class="number">1</span>; i++) p[i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n &lt;&lt; <span class="number">1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt;= right) p[i] = <span class="built_in">min</span>(right - i + <span class="number">1</span>, p[<span class="number">2</span> * id - i]);</span><br><span class="line">        <span class="keyword">while</span>(i + p[i] &lt;= <span class="number">2</span> * n &amp;&amp; i - p[i] &gt;= <span class="number">0</span> &amp;&amp; s[i + p[i]] == s[i - p[i]])</span><br><span class="line">            p[i]++;</span><br><span class="line">        <span class="keyword">if</span>(right &lt; i + p[i] - <span class="number">1</span>)&#123;</span><br><span class="line">            id = i; right = i + p[i] - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意，从1开始编号！</span></span><br><span class="line"><span class="keyword">int</span> nxt[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kmp</span><span class="params">(<span class="keyword">char</span> s[maxn], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(nxt, <span class="number">0</span>, <span class="keyword">sizeof</span> nxt); </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> p = nxt[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span>(p &gt; <span class="number">0</span> &amp;&amp; s[p + <span class="number">1</span>] != s[i]) p = nxt[p];</span><br><span class="line">        <span class="keyword">if</span>(s[p + <span class="number">1</span>] == s[i]) p++;</span><br><span class="line">        nxt[i] = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AC自动机"><a href="#AC自动机" class="headerlink" title="AC自动机"></a>AC自动机</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[maxn * <span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> ch[maxn][N], top = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> fail[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> pos[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span> *s, <span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; s[i]; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!ch[p][s[i] - <span class="string">&#x27;a&#x27;</span>]) ch[p][s[i] - <span class="string">&#x27;a&#x27;</span>] = top++;</span><br><span class="line">        p = ch[p][s[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    pos[id] = p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getfail</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) <span class="keyword">if</span>(ch[<span class="number">0</span>][i])&#123;</span><br><span class="line">        fail[ch[<span class="number">0</span>][i]] = <span class="number">0</span>;</span><br><span class="line">        q.<span class="built_in">push</span>(ch[<span class="number">0</span>][i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">int</span> now = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ch[now][i])&#123;</span><br><span class="line">                fail[ch[now][i]] = ch[fail[now]][i];</span><br><span class="line">                q.<span class="built_in">push</span>(ch[now][i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> ch[now][i] = ch[fail[now]][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">star</span>&#123;</span><span class="keyword">int</span> to, next;&#125;edge[maxn];</span><br><span class="line"><span class="keyword">int</span> head[maxn], _top = <span class="number">0</span>, sze[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    edge[_top].to = v;</span><br><span class="line">    edge[_top].next = head[u];</span><br><span class="line">    head[u] = _top++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> now)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[now]; ~i; i = edge[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> to = edge[i].to; <span class="built_in">dfs</span>(to);</span><br><span class="line">        sze[now] += sze[to];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//    Fastin;</span></span><br><span class="line">    <span class="built_in">clr</span>(head, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s); <span class="built_in">insert</span>(s, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">getfail</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, p = <span class="number">0</span>; s[i]; i++)&#123;</span><br><span class="line">        p = ch[p][s[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        sze[p]++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; top; i++) <span class="built_in">add</span>(fail[i], i); <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, sze[pos[i]]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查询在主串中所有模式串出现的次数。</p><p>不能暴力跳fail进行匹配，对于主串的每一个位置有可能fail遍历所有深度（如aaaaaaa)，因而建fail树记录并每一个节点被直接访问的次数，最后dfs求得节点所在的子树总共的访问次数即可。</p><h3 id="回文树"><a href="#回文树" class="headerlink" title="回文树"></a>回文树</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">3e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">26</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">char</span> s[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> len[maxn], fail[maxn];</span><br><span class="line"><span class="keyword">int</span> ch[maxn][N], top;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ini</span><span class="params">()</span></span>&#123;fail[<span class="number">1</span>] = fail[<span class="number">0</span>] = <span class="number">1</span>; len[<span class="number">1</span>] = <span class="number">-1</span>; top = <span class="number">2</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入字符s[n]</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getfail</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(s[n - <span class="number">1</span> - len[x]] != s[n]) x = fail[x];</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//下标从1开始</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">char</span> s[maxn])</span></span>&#123;</span><br><span class="line">    <span class="built_in">ini</span>();</span><br><span class="line">    <span class="comment">//选取一个保证不会出现的字符。</span></span><br><span class="line">    s[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//last维护了以s[n - 1]结尾的最长回文子串的节点标号。</span></span><br><span class="line">    <span class="keyword">int</span> last = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; s[i]; i++)&#123;</span><br><span class="line">        s[i] -= <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">int</span> p = <span class="built_in">getfail</span>(last, i);</span><br><span class="line">        <span class="keyword">if</span>(!ch[p][s[i]])&#123;</span><br><span class="line">            len[top] = len[p] + <span class="number">2</span>;</span><br><span class="line">            fail[top] = ch[<span class="built_in">getfail</span>(fail[p], i)][s[i]];</span><br><span class="line">            ch[p][s[i]] = top;</span><br><span class="line">            top++;</span><br><span class="line">        &#125;</span><br><span class="line">        last = ch[p][s[i]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-计算几何"><a href="#2-计算几何" class="headerlink" title="2 计算几何"></a>2 计算几何</h2><h3 id="已知平面圆上三点求圆心及其半径"><a href="#已知平面圆上三点求圆心及其半径" class="headerlink" title="已知平面圆上三点求圆心及其半径"></a>已知平面圆上三点求圆心及其半径</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cal</span><span class="params">(<span class="keyword">double</span> x1, <span class="keyword">double</span> y1, <span class="keyword">double</span> x2, <span class="keyword">double</span> y2, <span class="keyword">double</span> x3, <span class="keyword">double</span> y3)</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> a, b, c, d, e, f;</span><br><span class="line">    a = <span class="number">2</span> * (x2 - x1);</span><br><span class="line">    b = <span class="number">2</span> * (y2 - y1);</span><br><span class="line">    c = x2 * x2 + y2 * y2 - x1 * x1 - y1 * y1;</span><br><span class="line">    d = <span class="number">2</span> * (x3 - x2);</span><br><span class="line">    e = <span class="number">2</span> * (y3 - y2);</span><br><span class="line">    f = x3 * x3 + y3 * y3 - x2 * x2 - y2 * y2;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">double</span> x, y, r;</span><br><span class="line">    x = (b * f - e * c)/(b * d - e * a);</span><br><span class="line">    y = (d * c - a * f)/(b * d - e * a);</span><br><span class="line">    r = <span class="built_in">sqrt</span>((x - x1) * (x - x1) + (y - y1) * (y - y1));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>证明方法是做差解二元一次方程的行列式表达。</p><p>根据实际需要将函数中的<code>x, y, r</code>的值进行转移(<del>要是再加入3个替身变量就好长的列表</del>)。</p><h3 id="平面上圆的k次交"><a href="#平面上圆的k次交" class="headerlink" title="平面上圆的k次交"></a>平面上圆的k次交</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> manx = <span class="number">1e2</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-8</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">sgn</span><span class="params">(<span class="keyword">double</span> x)</span></span>&#123;<span class="keyword">return</span> x &lt; -eps? <span class="number">-1</span>: x &gt; eps? <span class="number">1</span>: <span class="number">0</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">sqr</span><span class="params">(<span class="keyword">double</span> x)</span></span>&#123;<span class="keyword">return</span> x * x;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CIRCLE</span>&#123;</span></span><br><span class="line">    <span class="keyword">double</span> x, y, r, angle;</span><br><span class="line">    <span class="keyword">int</span> d;</span><br><span class="line">    <span class="built_in">CIRCLE</span>()&#123;d = <span class="number">1</span>; angle = <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="built_in">CIRCLE</span>(<span class="keyword">double</span> _x, <span class="keyword">double</span> _y, <span class="keyword">double</span> _angle = <span class="number">0</span>, <span class="keyword">int</span> _d = <span class="number">0</span>)&#123;</span><br><span class="line">        x = _x; y = _y; angle = _angle; d = _d; r = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> CIRCLE &amp;b)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sgn</span>(r - b.r) == <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">dis</span><span class="params">(CIRCLE a, CIRCLE b)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">sqrt</span>(<span class="built_in">sqr</span>(a.x - b.x) + <span class="built_in">sqr</span>(a.y - b.y));&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">cross</span><span class="params">(CIRCLE a, CIRCLE b, CIRCLE c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//有两个交点返回true，以及两个交点的坐标和方位角，p1按照顺时针，p2按照逆时针</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cir_inter_cir</span><span class="params">(CIRCLE a, CIRCLE b, CIRCLE &amp;p1, CIRCLE &amp;p2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> d = <span class="built_in">dis</span>(a, b);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">sgn</span>(d - a.r - b.r) &gt;= <span class="number">0</span> || <span class="built_in">sgn</span>(<span class="built_in">abs</span>(b.r - a.r) - d) &gt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">double</span> cosa = (<span class="built_in">sqr</span>(a.r) + <span class="built_in">sqr</span>(d) - <span class="built_in">sqr</span>(b.r)) / (<span class="number">2</span> * a.r * d);</span><br><span class="line">    <span class="keyword">double</span> sina = <span class="built_in">sqrt</span>(<span class="built_in">max</span>(<span class="number">0.</span>, <span class="number">1.</span> - <span class="built_in">sqr</span>(cosa)));</span><br><span class="line">    <span class="comment">//旋转矩阵 [cosa, -sina; sina, cosa]</span></span><br><span class="line">    p1 = p2 = a;</span><br><span class="line">    p1.x += a.r / d * ((b.x - a.x) * cosa + (b.y - a.y) * -sina);</span><br><span class="line">    p1.y += a.r / d * ((b.x - a.x) * sina + (b.y - a.y) * cosa);</span><br><span class="line">    p2.x += a.r / d * ((b.x - a.x) * cosa + (b.y - a.y) * sina);</span><br><span class="line">    p2.y += a.r / d * ((b.x - a.x) * -sina + (b.y - a.y) * cosa);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> CIRCLE &amp;a, <span class="keyword">const</span> CIRCLE &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">sgn</span>(a.angle - b.angle)) <span class="keyword">return</span> <span class="built_in">sgn</span>(a.angle - b.angle) == <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> a.d &gt; b.d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">cal</span><span class="params">(CIRCLE a, CIRCLE p1, CIRCLE p2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> ans = <span class="built_in">sqr</span>(a.r) * (p2.angle - p1.angle) - <span class="built_in">cross</span>(a, p1, p2) + <span class="built_in">cross</span>(<span class="built_in">CIRCLE</span>(<span class="number">0</span>, <span class="number">0</span>), p1, p2);</span><br><span class="line">    <span class="keyword">return</span> ans / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CIRCLE dot[maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">double</span> area[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cirunion</span><span class="params">(CIRCLE cir[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(cir, cir + n);</span><br><span class="line">    <span class="comment">//记录每个圆被完全覆盖的次数，初始值显然为1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">sgn</span>(<span class="built_in">dis</span>(cir[i], cir[j]) + cir[i].r - cir[j].r) &lt;= <span class="number">0</span>) cir[i].d++;</span><br><span class="line">    CIRCLE p1, p2;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="comment">//针对每一个圆考虑它与所有其他圆的交</span></span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>, top = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == j) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">cir_inter_cir</span>(cir[i], cir[j], p1, p2)) <span class="keyword">continue</span>;</span><br><span class="line">            p1.angle = <span class="built_in">atan2</span>(p1.y - cir[i].y, p1.x - cir[i].x);</span><br><span class="line">            p2.angle = <span class="built_in">atan2</span>(p2.y - cir[i].y, p2.x - cir[i].x);</span><br><span class="line">            p1.d = <span class="number">-1</span>; p2.d = <span class="number">1</span>;</span><br><span class="line">            dot[top++] = p1; dot[top++] = p2;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">sgn</span>(p2.angle - p1.angle) == <span class="number">1</span>) cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//加入起点终点位置</span></span><br><span class="line">        dot[top++] = <span class="built_in">CIRCLE</span>(cir[i].x - cir[i].r, cir[i].y, -pi, <span class="number">-2</span>);</span><br><span class="line">        dot[top++] = <span class="built_in">CIRCLE</span>(cir[i].x - cir[i].r, cir[i].y, pi, <span class="number">2</span>);</span><br><span class="line">        <span class="built_in">sort</span>(dot, dot + top, cmp);</span><br><span class="line">        <span class="keyword">int</span> now = cir[i].d + cnt;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; top; j++)&#123;</span><br><span class="line">            area[now] += <span class="built_in">cal</span>(cir[i], dot[j - <span class="number">1</span>], dot[j]);</span><br><span class="line">            now += dot[j].d;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CIRCLE cir[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//    Fastin;</span></span><br><span class="line">    <span class="keyword">int</span> t; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t); <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">clr</span>(area, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%lf %lf %lf&quot;</span>, &amp;cir[i].x, &amp;cir[i].y, &amp;cir[i].r);</span><br><span class="line">        <span class="built_in">cirunion</span>(cir, n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">printf</span>(<span class="string">&quot;%.5f\n&quot;</span>, area[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="凸包周长"><a href="#凸包周长" class="headerlink" title="凸包周长"></a>凸包周长</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e2</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-9</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">POINT</span>&#123;</span></span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line">    POINT <span class="keyword">operator</span> - (<span class="keyword">const</span> POINT &amp;b)&#123;</span><br><span class="line">        POINT temp;</span><br><span class="line">        temp.x = x - b.x;</span><br><span class="line">        temp.y = y - b.y;</span><br><span class="line">        <span class="keyword">return</span> tmep;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;p[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">cross</span><span class="params">(POINT a, POINT b)</span></span>&#123; <span class="keyword">return</span> a.x * b.y - a.y * b.x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dis</span><span class="params">(POINT a)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">sqrt</span>(a.x * a.x + a.y * a.y);&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sgn</span><span class="params">(<span class="keyword">double</span> x)</span></span>&#123;<span class="keyword">return</span> x &lt; -eps? <span class="number">-1</span>: x &gt; eps? <span class="number">1</span>: <span class="number">0</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(POINT a, POINT b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="built_in">sgn</span>(<span class="built_in">cross</span>(a, b));</span><br><span class="line">    <span class="keyword">if</span>(flag == <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">dis</span>(a) &lt; <span class="built_in">dis</span>(b);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> flag == <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sta[maxn], top = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;sta[top++] = x;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// Fastin;</span></span><br><span class="line">    <span class="keyword">int</span> n; <span class="keyword">while</span>(~<span class="built_in">scnaf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n) &amp;&amp; n)&#123;</span><br><span class="line">        top = <span class="number">0</span>; <span class="keyword">int</span> id = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n ; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> x, y; <span class="built_in">scnaf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">            p[i].x = x; p[i].y = y;</span><br><span class="line">            <span class="keyword">if</span>(id == <span class="number">-1</span> || (p[id].x &gt; p[i].x) || (p[id].x == p[i].x &amp;&amp; p[id].y &gt; p[i].y)) id = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//不特判计算几何的都是xx!</span></span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;<span class="built_in">puts</span>(<span class="string">&quot;0.00&quot;</span>); <span class="keyword">continue</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">2</span>)&#123;<span class="built_in">printf</span>(<span class="string">&quot;%.2f\n&quot;</span>, <span class="built_in">dis</span>(p[<span class="number">1</span>] - p[<span class="number">2</span>])); <span class="keyword">continue</span>;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">if</span>(i != id) p[i] = p[i] - p[id];</span><br><span class="line">        p[id].x = p[id].y = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">sort</span>(p + <span class="number">1</span>, p + <span class="number">1</span> + n, cmp);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">push</span>(<span class="number">1</span>); <span class="built_in">push</span>(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">sgn</span>(<span class="built_in">cross</span>(p[i] - p[sta[top - <span class="number">2</span>]], p[i] - p[sta[top - <span class="number">1</span>]])) &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="built_in">push</span>(i); <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> top--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">double</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; top; i++) ans += <span class="built_in">dis</span>(p[sta[i]] - p[sta[i - <span class="number">1</span>]]);</span><br><span class="line">        ans += <span class="built_in">dis</span>(p[sta[<span class="number">0</span>]] - p[sta[top - <span class="number">1</span>]]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%.2f\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复杂度$O(nlogn)$</p><p>求周长需要循环地求一遍栈中相邻两个元素的距离！不要漏求sta[0]与sta[top - 1]！</p><h2 id="3-图论"><a href="#3-图论" class="headerlink" title="3 图论"></a>3 图论</h2><h3 id="最短路"><a href="#最短路" class="headerlink" title="最短路"></a>最短路</h3><h4 id="01bfs"><a href="#01bfs" class="headerlink" title="01bfs"></a>01bfs</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(双端队列非空)&#123;</span><br><span class="line">  取出队首元素<span class="function">now</span></span><br><span class="line"><span class="function">  <span class="title">for</span><span class="params">(now的相邻节点)</span></span>&#123;</span><br><span class="line">    更新距离</span><br><span class="line">    <span class="keyword">if</span>(边权为<span class="number">0</span>) 添加到队首</span><br><span class="line">    <span class="keyword">else</span> 添加到队尾</span><br><span class="line">  &#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>当图中边权仅为0或1时，可以使用01bfs解决单源最短路问题。</p><p>时间复杂度$O(V+E)$</p><h3 id="tarjan"><a href="#tarjan" class="headerlink" title="tarjan"></a>tarjan</h3><h4 id="scc"><a href="#scc" class="headerlink" title="scc"></a>scc</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">star edge[maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> head[manx], top = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    edge[top].to = v;</span><br><span class="line">    edge[top].next = head[u];</span><br><span class="line">    head[u] = top++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">stack&lt;<span class="keyword">int</span>&gt; sta;</span><br><span class="line"><span class="keyword">int</span> dfn[maxn], low[maxn], cnt = <span class="number">1</span>, in[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    dfn[u] = low[u] = cnt++;</span><br><span class="line">    sta.<span class="built_in">push</span>(u); in[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; ~i; i = edge[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> to = edge[i].to;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[to])&#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(to);</span><br><span class="line">            low[u] = <span class="built_in">min</span>(low[to], low[u]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(in[to])&#123;</span><br><span class="line">            low[u] = <span class="built_in">min</span>(low[u], dfn[to]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出以u节点为根的scc</span></span><br><span class="line">    <span class="keyword">if</span>(dfn[u] == low[u])&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">assert</span>(!sta.<span class="built_in">empty</span>());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> v = sta.<span class="built_in">top</span>(); sta.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, v); in[v] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(v == u)&#123;<span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>); <span class="keyword">break</span>;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// Fastin;</span></span><br><span class="line">    <span class="built_in">clr</span>(head, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">int</span> n, m; <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i&lt; m; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> u, v; <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">        <span class="built_in">add</span>(u, v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">tarjan</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="异或MST-（Boruvka算法）"><a href="#异或MST-（Boruvka算法）" class="headerlink" title="异或MST （Boruvka算法）"></a>异或MST （Boruvka算法）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = ~<span class="number">0u</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, w[maxn], c[maxn];;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ch[maxn * N][<span class="number">2</span>], sze = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = N - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="keyword">int</span> id = (x &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(ch[p][id] == <span class="number">0</span>) ch[p][id] = sze++;</span><br><span class="line">        p = ch[p][id];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = N - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="keyword">int</span> id = (x &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(ch[p][id] &gt; <span class="number">0</span>) p = ch[p][id];</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            ans |= <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">            p = ch[p][id ^ <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll ans = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sove</span><span class="params">(<span class="keyword">int</span> d, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &lt; <span class="number">1</span> || r &gt; n || l &gt; r || d &lt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> L = l - <span class="number">1</span>, R = r + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = l; i &lt;= r; i++)</span><br><span class="line">        <span class="keyword">if</span>(w[i] &amp; <span class="number">1</span> &lt;&lt; d) c[--R] = w[i];</span><br><span class="line">        <span class="keyword">else</span> c[++L] = w[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = l; i &lt;= r; i++) w[i] = c[i];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">sove</span>(d - <span class="number">1</span>, l, L);</span><br><span class="line">    <span class="built_in">sove</span>(d - <span class="number">1</span>, R, r);</span><br><span class="line">    <span class="keyword">if</span>(L &lt; l || R &gt; r) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = l; i &lt;= L; i++) <span class="built_in">insert</span>(w[i]);</span><br><span class="line">    <span class="keyword">int</span> m = inf;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = R; i &lt;= r; i++) m = <span class="built_in">min</span>(m, <span class="built_in">query</span>(w[i]));</span><br><span class="line">    ans += m;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sze; i++) ch[i][<span class="number">0</span>] = ch[i][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    sze = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//    Fastin;</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n); <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, w + i);</span><br><span class="line">    <span class="built_in">sove</span>(N - <span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>模板规定节点从1开始标号，点权$w_i&lt;2^{30}$，具体题目应该结合范围进行具体分析。</p><h3 id="图的匹配"><a href="#图的匹配" class="headerlink" title="图的匹配"></a>图的匹配</h3><h4 id="二分图最大匹配"><a href="#二分图最大匹配" class="headerlink" title="二分图最大匹配"></a>二分图最大匹配</h4><h5 id="匈牙利算法"><a href="#匈牙利算法" class="headerlink" title="匈牙利算法"></a>匈牙利算法</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> manx = <span class="number">510</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, n1, n2, m;</span><br><span class="line"><span class="keyword">int</span> head[maxn &lt;&lt; <span class="number">1</span>], top = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">star</span>&#123;</span><span class="keyword">int</span> to, next;&#125;;</span><br><span class="line">star edge[maxn * maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    edge[top].to = v;</span><br><span class="line">    edge[top].next = head[u];</span><br><span class="line">    head[u] = top++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> vis[maxn &lt;&lt; <span class="number">1</span>], match[maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; ~i; i = edge[i].next) <span class="keyword">if</span>(!vis[edge[i].to])&#123;</span><br><span class="line">        <span class="keyword">int</span> to = edge[i].to; vis[to] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(!match[to] || <span class="built_in">find</span>(match[to]))&#123;</span><br><span class="line">            match[to] = u;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hungary</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="built_in">clr</span>(vis, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">find</span>(i)) ans++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//    Fastin;</span></span><br><span class="line">    <span class="built_in">clr</span>(head, <span class="number">-1</span>);</span><br><span class="line"> <span class="comment">//读入n1, n2, m, 表示两边点集的数量和边数，取n = max(n1, n2)作为序号的偏移量。</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;n1, &amp;n2, &amp;m); n = <span class="built_in">max</span>(n1, n2);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> u, v; <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">        <span class="built_in">add</span>(u, v + n);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">hungary</span>());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n2; i++) ans[match[i + n]] = i;</span><br><span class="line">    <span class="built_in">prt</span>(ans + <span class="number">1</span>, n1);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>匈牙利算法，两边点集大小均为maxn，因而有关数组需要开至2倍甚至更多。</p><p>复杂度$O(nm)$</p><p><strong>每次为ai分配路径的时候都要对vis数组初始化，多组数据的时候复杂度会变成O(Tmaxn), 记得改掉memset！</strong></p><h5 id="最大流-Dinic实现"><a href="#最大流-Dinic实现" class="headerlink" title="最大流(Dinic实现)"></a>最大流(Dinic实现)</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> itn maxn = <span class="number">1200</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxe = <span class="number">120000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> ll inf = <span class="number">1ll</span> &lt;&lt; <span class="number">60</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">star</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next, w;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> head[maxn], top = <span class="number">0</span>;</span><br><span class="line">star edge[maxe &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    edge[top].to = v;</span><br><span class="line">    edge[top].next = head[u];</span><br><span class="line">    edge[top].w = w;</span><br><span class="line">    head[u] = top++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> d[maxn], cur[maxn];</span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t, ll flow)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (flow == <span class="number">0</span> || s == t)</span><br><span class="line">        <span class="keyword">return</span> flow;</span><br><span class="line"></span><br><span class="line">    ll res = <span class="number">0</span>, f;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = cur[s]; ~i; i = edge[i].next) &#123;</span><br><span class="line">        cur[s] = i;</span><br><span class="line">        <span class="keyword">if</span> (d[edge[i].to] == d[s] + <span class="number">1</span>) &#123;</span><br><span class="line">            f = <span class="built_in">dfs</span>(edge[i].to, t, <span class="built_in">min</span>(flow, (ll)edge[i].w));</span><br><span class="line">            edge[i].w -= f;</span><br><span class="line">            edge[i ^ <span class="number">1</span>].w += f;</span><br><span class="line">            res += f;</span><br><span class="line">            flow -= f;</span><br><span class="line">            <span class="keyword">if</span> (flow == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">queue&lt;<span class="keyword">int</span>&gt; q, q0;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">clr</span>(d, <span class="number">0</span>);</span><br><span class="line">    q = q0;</span><br><span class="line">    q.<span class="built_in">push</span>(s);</span><br><span class="line">    cur[s] = head[s];</span><br><span class="line">    d[s] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">int</span> now = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[now]; ~i; i = edge[i].next)</span><br><span class="line">            <span class="keyword">if</span> (!d[edge[i].to] &amp;&amp; edge[i].w &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                cur[edge[i].to] = head[edge[i].to];</span><br><span class="line">                d[edge[i].to] = d[now] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (edge[i].to == t)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(edge[i].to);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">dinic</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">bfs</span>(s, t)) ans += <span class="built_in">dfs</span>(s, t, inf);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//    Fastin;</span></span><br><span class="line">    <span class="built_in">clr</span>(head, <span class="number">-1</span>);</span><br><span class="line">     <span class="comment">//读入n1, n2, m, 表示两边点集的数量和边数，取n = max(n1, n2)作为序号的偏移量。</span></span><br><span class="line">    <span class="keyword">int</span> n1, n2, m, n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;n1, &amp;n2, &amp;m); n = <span class="built_in">max</span>(n1, n2);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> u, v; <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">        <span class="built_in">add</span>(u, v + n, <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">add</span>(v + n, u, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n1; i++)&#123;<span class="built_in">add</span>(<span class="number">0</span>, i, <span class="number">1</span>); <span class="built_in">add</span>(i, <span class="number">0</span>, <span class="number">0</span>);&#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n2; i++)&#123;<span class="built_in">add</span>(i + n, <span class="number">2</span> * n + <span class="number">1</span>, <span class="number">1</span>); <span class="built_in">add</span>(<span class="number">2</span> * n + <span class="number">1</span>, i + n, <span class="number">0</span>);&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">dinic</span>(<span class="number">0</span>, <span class="number">2</span> * n + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以证明，Dinic实现二分图的最大流复杂度$O(\sqrt n m)$，比朴素的匈牙利算法要快上一些。</p><p>不过如果使用了网络流算法可能就不能找出匹配方案了。</p><h4 id="二分图最大权匹配"><a href="#二分图最大权匹配" class="headerlink" title="二分图最大权匹配"></a>二分图最大权匹配</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">410</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> match[maxn];</span><br><span class="line"><span class="keyword">int</span> ex[<span class="number">2</span>][maxn], vis[<span class="number">2</span>][maxn];;</span><br><span class="line"><span class="keyword">int</span> slack[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> now)</span></span>&#123;</span><br><span class="line">    vis[<span class="number">0</span>][now] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="keyword">if</span>(!vis[<span class="number">1</span>][i])&#123;</span><br><span class="line">        <span class="keyword">int</span> gap = ex[<span class="number">0</span>][now] + ex[<span class="number">1</span>][i] - a[now][i];</span><br><span class="line">        <span class="keyword">if</span>(gap == <span class="number">0</span>)&#123;</span><br><span class="line">            vis[<span class="number">1</span>][i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(match[i] == <span class="number">-1</span> || <span class="built_in">dfs</span>(match[i]))&#123; match[i] = now; <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> slack[i] = <span class="built_in">min</span>(slack[i], gap);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">km</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;match[i] = <span class="number">-1</span>; ex[<span class="number">0</span>][i] = ex[<span class="number">1</span>][i] = <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) ex[<span class="number">0</span>][i] = <span class="built_in">max</span>(ex[<span class="number">0</span>][i], a[i][j]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) slack[i] = inf;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) vis[<span class="number">0</span>][i] = vis[<span class="number">1</span>][i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">dfs</span>(i)) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> d = inf; <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="keyword">if</span>(!vis[<span class="number">1</span>][i]) d = <span class="built_in">min</span>(d, slack[i]);</span><br><span class="line">            <span class="keyword">int</span> pos = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(vis[<span class="number">0</span>][i]) ex[<span class="number">0</span>][i] -= d;</span><br><span class="line">                <span class="keyword">if</span>(vis[<span class="number">1</span>][i]) ex[<span class="number">1</span>][i] += d;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    slack[i] -= d;</span><br><span class="line">                    <span class="keyword">if</span>(slack[i] == <span class="number">0</span>) pos = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">assert</span>(pos != <span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">if</span>(match[pos] == <span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">int</span> u = match[pos];</span><br><span class="line">            vis[<span class="number">0</span>][u] = vis[<span class="number">1</span>][pos] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="keyword">if</span>(!vis[<span class="number">1</span>][i]) slack[i] = <span class="built_in">min</span>(slack[i], ex[<span class="number">0</span>][u] + ex[<span class="number">1</span>][i] - a[u][i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) vis[<span class="number">0</span>][i] = vis[<span class="number">1</span>][i] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    ll res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) res += a[match[i]][i];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//    Fastin;</span></span><br><span class="line">    <span class="keyword">int</span> n1, n2, m; <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;n1, &amp;n2, &amp;m);</span><br><span class="line">    n = <span class="built_in">max</span>(n1, n2);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> u, v, w; <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line">        u--; v--; a[u][v] = w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">km</span>());</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n2; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(match[i] == <span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[match[i]][i] == <span class="number">0</span>) ans[match[i]] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> ans[match[i]] = i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n1; i++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, ans[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>读入左右点数和边数，接下来跟m行有向边及其边权。</p><p>点数范围400，边权1e9。</p><p><strong>找增广路径的dfs不能放在while循环中，不然成为假算法$O(n^4)$。</strong></p><p>为了修改标记使一条可行增广路存在只需要修改slack tag即可，因为只需要在while循环中更新slack即可。</p><h3 id="流算法"><a href="#流算法" class="headerlink" title="流算法"></a>流算法</h3><h4 id="最大流"><a href="#最大流" class="headerlink" title="最大流"></a>最大流</h4><h5 id="dinic-当前弧优化"><a href="#dinic-当前弧优化" class="headerlink" title="dinic (当前弧优化)"></a>dinic (当前弧优化)</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> itn maxn = <span class="number">1200</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxe = <span class="number">120000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> ll inf = <span class="number">1ll</span> &lt;&lt; <span class="number">60</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">star</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next, w;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> head[maxn], top = <span class="number">0</span>;</span><br><span class="line">star edge[maxe &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    edge[top].to = v;</span><br><span class="line">    edge[top].next = head[u];</span><br><span class="line">    edge[top].w = w;</span><br><span class="line">    head[u] = top++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> d[maxn], cur[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t, ll flow)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (flow == <span class="number">0</span> || s == t)</span><br><span class="line">        <span class="keyword">return</span> flow;</span><br><span class="line"></span><br><span class="line">    ll res = <span class="number">0</span>, f;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = cur[s]; ~i; i = edge[i].next) &#123;</span><br><span class="line">        cur[s] = i;</span><br><span class="line">        <span class="keyword">if</span> (d[edge[i].to] == d[s] + <span class="number">1</span>) &#123;</span><br><span class="line">            f = <span class="built_in">dfs</span>(edge[i].to, t, <span class="built_in">min</span>(flow, (ll)edge[i].w));</span><br><span class="line">            edge[i].w -= f;</span><br><span class="line">            edge[i ^ <span class="number">1</span>].w += f;</span><br><span class="line">            res += f;</span><br><span class="line">            flow -= f;</span><br><span class="line">            <span class="keyword">if</span> (flow == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">queue&lt;<span class="keyword">int</span>&gt; q, q0;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">clr</span>(d, <span class="number">0</span>);</span><br><span class="line">    q = q0;</span><br><span class="line">    q.<span class="built_in">push</span>(s);</span><br><span class="line">    cur[s] = head[s];</span><br><span class="line">    d[s] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">int</span> now = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[now]; ~i; i = edge[i].next)</span><br><span class="line">            <span class="keyword">if</span> (!d[edge[i].to] &amp;&amp; edge[i].w &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                cur[edge[i].to] = head[edge[i].to];</span><br><span class="line">                d[edge[i].to] = d[now] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (edge[i].to == t)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(edge[i].to);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">dinic</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">bfs</span>(s, t)) ans += <span class="built_in">dfs</span>(s, t, inf);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//    Fastin;</span></span><br><span class="line">    <span class="built_in">clr</span>(head, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">int</span> n, m, s, t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d %d&quot;</span>, &amp;n, &amp;m, &amp;s, &amp;t);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, u, v, w; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line">        <span class="built_in">add</span>(u, v, w);</span><br><span class="line">        <span class="built_in">add</span>(v, u, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">dinic</span>(s, t));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$O(n^2  m)$</p><h5 id="isap-gap优化"><a href="#isap-gap优化" class="headerlink" title="isap (gap优化)"></a>isap (gap优化)</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> itn maxn = <span class="number">1200</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxe = <span class="number">120000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> ll inf = <span class="number">1ll</span> &lt;&lt; <span class="number">60</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">star</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next, w;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> n, m, s, t;</span><br><span class="line"><span class="keyword">int</span> head[maxn], top = <span class="number">0</span>;</span><br><span class="line">star edge[maxe &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    edge[top].to = v;</span><br><span class="line">    edge[top].next = head[u];</span><br><span class="line">    edge[top].w = w;</span><br><span class="line">    head[u] = top++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> d[maxn], cur[maxn], gap[maxn];</span><br><span class="line"></span><br><span class="line">queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    q.<span class="built_in">push</span>(t);</span><br><span class="line">    gap[d[t] = <span class="number">1</span>]++;</span><br><span class="line">    cur[t] = head[t];</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">int</span> now = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[now]; ~i; i = edge[i].next)</span><br><span class="line">            <span class="keyword">if</span> (!d[edge[i].to]) &#123;</span><br><span class="line">                gap[d[edge[i].to] = d[now] + <span class="number">1</span>]++;</span><br><span class="line">                cur[edge[i].to] = head[edge[i].to];</span><br><span class="line">                q.<span class="built_in">push</span>(edge[i].to);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> s, <span class="keyword">int</span> t, ll flow)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == t)</span><br><span class="line">        <span class="keyword">return</span> flow;</span><br><span class="line"></span><br><span class="line">    ll res = <span class="number">0</span>, f;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = cur[x]; ~i; i = edge[i].next) &#123;</span><br><span class="line">        cur[x] = i;</span><br><span class="line">        <span class="keyword">if</span> (d[x] == d[edge[i].to] + <span class="number">1</span>) &#123;</span><br><span class="line">            f = <span class="built_in">dfs</span>(edge[i].to, s, t, <span class="built_in">min</span>(flow, (ll)edge[i].w));</span><br><span class="line">            edge[i].w -= f;</span><br><span class="line">            edge[i ^ <span class="number">1</span>].w += f;</span><br><span class="line">            flow -= f;</span><br><span class="line">            res += f;</span><br><span class="line">            <span class="keyword">if</span> (flow == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!(gap[d[x]]--))</span><br><span class="line">        d[s] = n + <span class="number">1</span>;</span><br><span class="line">    gap[++d[x]]++;</span><br><span class="line">    cur[x] = head[x];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">isap</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">bfs</span>(s, t);</span><br><span class="line">    ll ans = <span class="built_in">dfs</span>(s, s, t, inf);</span><br><span class="line">    <span class="keyword">while</span> (d[s] &lt;= n) ans += <span class="built_in">dfs</span>(s, s, t, inf);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//    Fastin;</span></span><br><span class="line">    <span class="built_in">clr</span>(head, <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d %d&quot;</span>, &amp;n, &amp;m, &amp;s, &amp;t);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, u, v, w; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line">        <span class="built_in">add</span>(u, v, w);</span><br><span class="line">        <span class="built_in">add</span>(v, u, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">isap</span>(s, t));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$O(n^2  m)$</p><h5 id="最高标号预流推进HLPP"><a href="#最高标号预流推进HLPP" class="headerlink" title="最高标号预流推进HLPP"></a>最高标号预流推进HLPP</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = INT_MAX;</span><br><span class="line"><span class="keyword">const</span> ll INF = (<span class="number">0x3f3f3f3f3f3f3f3f</span>ll);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1.2e3</span> + <span class="number">5</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HLPP</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> v, rev;</span><br><span class="line">        ll cap;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">int</span> n, sp, tp, lim, ht, lcnt;</span><br><span class="line">    ll exf[maxn];</span><br><span class="line">    vector&lt;Edge&gt; G[maxn];</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; hq[maxn], gap[maxn], h, sum;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> nn, <span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        sp = s, tp = t, n = nn, lim = n + <span class="number">1</span>, ht = lcnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) G[i].<span class="built_in">clear</span>(), exf[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, ll cap)</span> </span>&#123;</span><br><span class="line">        G[u].<span class="built_in">push_back</span>(&#123; v, <span class="built_in"><span class="keyword">int</span></span>(G[v].<span class="built_in">size</span>()), cap &#125;);</span><br><span class="line">        G[v].<span class="built_in">push_back</span>(&#123; u, <span class="built_in"><span class="keyword">int</span></span>(G[u].<span class="built_in">size</span>()) - <span class="number">1</span>, <span class="number">0</span> &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> nh)</span> </span>&#123;</span><br><span class="line">        ++lcnt;</span><br><span class="line">        <span class="keyword">if</span> (h[u] != lim)</span><br><span class="line">            --sum[h[u]];</span><br><span class="line">        h[u] = nh;</span><br><span class="line">        <span class="keyword">if</span> (nh == lim)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        ++sum[ht = nh];</span><br><span class="line">        gap[nh].<span class="built_in">push_back</span>(u);</span><br><span class="line">        <span class="keyword">if</span> (exf[u] &gt; <span class="number">0</span>)</span><br><span class="line">            hq[nh].<span class="built_in">push_back</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">relabel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= lim; ++i) hq[i].<span class="built_in">clear</span>(), gap[i].<span class="built_in">clear</span>();</span><br><span class="line">        h.<span class="built_in">assign</span>(lim, lim), sum.<span class="built_in">assign</span>(lim, <span class="number">0</span>), q.<span class="built_in">push</span>(tp);</span><br><span class="line">        lcnt = ht = h[tp] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span> (Edge &amp;e : G[u])</span><br><span class="line">                <span class="keyword">if</span> (h[e.v] == lim &amp;&amp; G[e.v][e.rev].cap)</span><br><span class="line">                    <span class="built_in">update</span>(e.v, h[u] + <span class="number">1</span>), q.<span class="built_in">push</span>(e.v);</span><br><span class="line">            ht = h[u];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> u, Edge &amp;e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!exf[e.v])</span><br><span class="line">            hq[h[e.v]].<span class="built_in">push_back</span>(e.v);</span><br><span class="line">        ll df = <span class="built_in">min</span>(exf[u], e.cap);</span><br><span class="line">        e.cap -= df, G[e.v][e.rev].cap += df;</span><br><span class="line">        exf[u] -= df, exf[e.v] += df;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">discharge</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> nh = lim;</span><br><span class="line">        <span class="keyword">if</span> (h[u] == lim)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span> (Edge &amp;e : G[u]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!e.cap)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (h[u] == h[e.v] + <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="built_in">push</span>(u, e);</span><br><span class="line">                <span class="keyword">if</span> (exf[u] &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nh &gt; h[e.v] + <span class="number">1</span>)</span><br><span class="line">                nh = h[e.v] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sum[h[u]] &gt; <span class="number">1</span>)</span><br><span class="line">            <span class="built_in">update</span>(u, nh);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (; ht &gt;= h[u]; gap[ht--].<span class="built_in">clear</span>())</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> &amp;i : gap[ht]) <span class="built_in">update</span>(i, lim);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ll <span class="title">hlpp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        exf[sp] = INF, exf[tp] = -INF, <span class="built_in">relabel</span>();</span><br><span class="line">        <span class="keyword">for</span> (Edge &amp;e : G[sp]) <span class="built_in">push</span>(sp, e);</span><br><span class="line">        <span class="keyword">for</span> (; ~ht; --ht) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!hq[ht].<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                <span class="keyword">int</span> u = hq[ht].<span class="built_in">back</span>();</span><br><span class="line">                hq[ht].<span class="built_in">pop_back</span>();</span><br><span class="line">                <span class="built_in">discharge</span>(u);</span><br><span class="line">                <span class="keyword">if</span> (lcnt &gt; (n &lt;&lt; <span class="number">2</span>))</span><br><span class="line">                    <span class="built_in">relabel</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> exf[tp] + INF;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; hp;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> n, m, s, t, u, v, w;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; s &gt;&gt; t;</span><br><span class="line">    hp.<span class="built_in">init</span>(n, s, t);</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        hp.<span class="built_in">add_edge</span>(u, v, w);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; hp.<span class="built_in">hlpp</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>loj127 </p><p>偷其板，不知其所以然。</p><p><del>甚至不知其然qaq</del></p><p>$O(n^2 \sqrt m)$</p><h4 id="费用流-dijstra"><a href="#费用流-dijstra" class="headerlink" title="费用流 (dijstra)"></a>费用流 (dijstra)</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ll inf = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">410</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxe = <span class="number">2e4</span> + <span class="number">10</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">star</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> from, to, next; ll c, w;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> head[maxn], top = <span class="number">0</span>;</span><br><span class="line">star edge[maxe &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c, <span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    edge[top].from = u;</span><br><span class="line">    edge[top].to = v;</span><br><span class="line">    edge[top].c = c;</span><br><span class="line">    edge[top].w = w;</span><br><span class="line">    edge[top].next = head[u];</span><br><span class="line">    head[u] = top++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll dis[maxn], h[maxn];</span><br><span class="line"><span class="keyword">int</span> pre[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NODE</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u; ll d;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> NODE &amp;b)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> d &gt; b.d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;NODE&gt; pq, pq0;</span><br><span class="line"><span class="function">ll <span class="title">mcmf</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t, ll f, ll &amp;flow)</span></span>&#123;</span><br><span class="line">    ll res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(f)&#123;</span><br><span class="line">        <span class="built_in">clr</span>(dis, <span class="number">0x3f</span>); dis[s] = <span class="number">0</span>;</span><br><span class="line">        pq = pq0; pq.<span class="built_in">push</span>(&#123;s, dis[s]&#125;);</span><br><span class="line">        <span class="keyword">while</span>(!pq.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            NODE temp = pq.<span class="built_in">top</span>(); pq.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">int</span> u = temp.u; ll d = temp.d;</span><br><span class="line">            <span class="keyword">if</span>(dis[u] &lt; d) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; ~i; i = edge[i].next)&#123;</span><br><span class="line">                <span class="keyword">int</span> to = edge[i].to;</span><br><span class="line">                <span class="keyword">if</span>(edge[i].c &gt; <span class="number">0</span> &amp;&amp; dis[to] &gt; dis[u] + edge[i].w + h[u] - h[to])&#123;</span><br><span class="line">                    dis[to] = dis[u] + edge[i].w + h[u] - h[to];</span><br><span class="line">                    pre[to] = i;</span><br><span class="line">                    pq.<span class="built_in">push</span>(&#123;to, dis[to]&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dis[t] == inf) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) h[i] += dis[i];</span><br><span class="line">        </span><br><span class="line">        ll d = f;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> now = t; now != s; now = edge[pre[now]].from) d = <span class="built_in">min</span>(d, edge[pre[now]].c);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> now = t; now != s; now = edge[pre[now]].from)&#123;</span><br><span class="line">            edge[pre[now]].c -= d;</span><br><span class="line">            edge[pre[now] ^ <span class="number">1</span>].c += d;</span><br><span class="line">        &#125;</span><br><span class="line">        f -= d; flow += d; res += d * h[t];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//    Fastin;</span></span><br><span class="line">    <span class="built_in">clr</span>(head, <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> u, v, c, w; <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d %d&quot;</span>, &amp;u, &amp;v, &amp;c, &amp;w);</span><br><span class="line">        <span class="built_in">add</span>(u, v, c, w); <span class="built_in">add</span>(v, u, <span class="number">0</span>, -w);</span><br><span class="line">    &#125;</span><br><span class="line">    ll flow = <span class="number">0</span>;</span><br><span class="line">    ll res = <span class="built_in">mcmf</span>(<span class="number">1</span>, n, inf, flow);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld %lld\n&quot;</span>, flow, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>loj102 单组数据最慢700ms左右</p><p>$V&lt;=400, E&lt;=15000$</p><p>时间复杂度$O(FElogV)$</p><h3 id="线段树优化建图"><a href="#线段树优化建图" class="headerlink" title="线段树优化建图"></a>线段树优化建图</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mid ((l + r) &gt;&gt; 1)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">5e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxe = <span class="number">4e7</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> M;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, p;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span><span class="keyword">int</span> to, next, w;&#125;edge[maxe];</span><br><span class="line"><span class="keyword">int</span> head[maxe], top = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    edge[top].to = v;</span><br><span class="line">    edge[top].w = w;</span><br><span class="line">    edge[top].next = head[u];</span><br><span class="line">    head[u] = top++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>, pos[maxn], ls[maxn &lt;&lt; <span class="number">3</span>], rs[maxn &lt;&lt; <span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> now = cnt++;</span><br><span class="line">    <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">        <span class="built_in">add</span>(now, now + M, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> pos[l] = now;</span><br><span class="line">    &#125;</span><br><span class="line">    ls[now] = <span class="built_in">build</span>(l, mid);</span><br><span class="line">    <span class="built_in">add</span>(now, ls[now], <span class="number">0</span>); <span class="built_in">add</span>(ls[now] + M, now + M, <span class="number">0</span>);</span><br><span class="line">    rs[now] = <span class="built_in">build</span>(mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="built_in">add</span>(now, rs[now], <span class="number">0</span>); <span class="built_in">add</span>(rs[now] + M, now + M, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> now;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> u, <span class="keyword">int</span> type)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R)&#123;</span><br><span class="line">        <span class="keyword">if</span>(type) <span class="built_in">add</span>(p + M, u, <span class="number">1</span>); <span class="keyword">else</span> <span class="built_in">add</span>(u, p, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= mid) <span class="built_in">update</span>(ls[p], l, mid, L, R, u, type);</span><br><span class="line">    <span class="keyword">if</span>(R &gt; mid) <span class="built_in">update</span>(rs[p], mid + <span class="number">1</span>, r, L, R, u, type);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dis[<span class="number">5000000</span>];</span><br><span class="line">deque&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">clr</span>(dis, <span class="number">0x3f</span>);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) q.<span class="built_in">pop_back</span>();</span><br><span class="line">    </span><br><span class="line">    dis[pos[p]] = <span class="number">0</span>; q.<span class="built_in">push_back</span>(pos[p]);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">int</span> now = q.<span class="built_in">front</span>(); q.<span class="built_in">pop_front</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = head[now]; ~i; i = edge[i].next)&#123;</span><br><span class="line">            <span class="keyword">int</span> to = edge[i].to; <span class="keyword">if</span>(dis[to] != <span class="number">0x3f3f3f3f</span>) <span class="keyword">continue</span>;</span><br><span class="line">            dis[to] = dis[now] + edge[i].w;</span><br><span class="line">            <span class="keyword">if</span>(edge[i].w) q.<span class="built_in">push_back</span>(to);</span><br><span class="line">            <span class="keyword">else</span> q.<span class="built_in">push_front</span>(to);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//    Fastin;</span></span><br><span class="line">    <span class="built_in">clr</span>(head, <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;n, &amp;m, &amp;p);</span><br><span class="line">    M = n &lt;&lt; <span class="number">2</span>; <span class="built_in">build</span>(<span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> a, b, c, d; <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d %d&quot;</span>, &amp;a, &amp;b, &amp;c, &amp;d);</span><br><span class="line">        <span class="comment">//加入虚点i + 2M与i + 1 + 2M;</span></span><br><span class="line">        <span class="built_in">update</span>(<span class="number">0</span>, <span class="number">1</span>, n, a, b, <span class="number">2</span> * i + <span class="number">2</span> * M, <span class="number">1</span>); <span class="built_in">update</span>(<span class="number">0</span>, <span class="number">1</span>, n, c, d, <span class="number">2</span> * i + <span class="number">2</span> * M, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">update</span>(<span class="number">0</span>, <span class="number">1</span>, n, c, d, <span class="number">2</span> * i + <span class="number">2</span> * M + <span class="number">1</span>, <span class="number">1</span>); <span class="built_in">update</span>(<span class="number">0</span>, <span class="number">1</span>, n, a, b, <span class="number">2</span> * i + <span class="number">2</span> * M + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">bfs</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, dis[pos[i]]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>给出n个节点、m种边。</p><p>对于某一种边而言，有4个参数：a, b, c, d，表示对于所有的$a \leq x \leq b, c \leq y \leq d$都有一条无向边$<x, y>$相连。</p><p>询问对于某个指定点p而言，到其他所有点的最短距离</p><p>数据范围 $n \leq 5e5, m \leq 1e5$</p><h2 id="4-可持久化"><a href="#4-可持久化" class="headerlink" title="4 可持久化"></a>4 可持久化</h2><h3 id="可持久化01-Trie"><a href="#可持久化01-Trie" class="headerlink" title="可持久化01-Trie"></a>可持久化01-Trie</h3><p>最基本的版本如下，根据不同的题目可以添加不同的辅助数组。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">const</span> itn maxn = <span class="number">1e5</span> * N  +<span class="number">10</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TRIE</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> version = <span class="number">0</span>, top = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ch[maxn][<span class="number">2</span>], root[maxn];;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rot = root[version];</span><br><span class="line">        root[++version] = ++top;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = N - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">int</span> id = (x &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line">            ch[top][id] = top + <span class="number">1</span>; <span class="comment">//新建</span></span><br><span class="line">            ch[top][!id] = ch[rot][!id]; <span class="comment">//继承</span></span><br><span class="line">            top++; rot = ch[rot][id];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>多维护一个size数组记录当前节点下有多少个串，可用于在任意区间中查找区间中某个数异或上某个给定x的最大值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">24</span>;</span><br><span class="line"><span class="keyword">const</span> itn maxn = <span class="number">1e5</span>  +<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TRIE</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> version = <span class="number">0</span>, top = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ch[maxn][<span class="number">2</span>], root[maxn];;</span><br><span class="line">    <span class="keyword">int</span> size[maxn];</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rot = root[version];</span><br><span class="line">        root[++version] = ++top;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = N - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">int</span> id = (x &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line">            ch[top][id] = top + <span class="number">1</span>;</span><br><span class="line">            ch[top][!id] = ch[rot][!id];</span><br><span class="line">            size[top] = size[rot] + <span class="number">1</span>;</span><br><span class="line">            top++; rot = ch[rot][id];</span><br><span class="line">        &#125;</span><br><span class="line">        size[top] = size[rot] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//查找[L + 1, R]的结果</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R, itn x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = root[L], r = root[R];</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = N - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">int</span> id = (x &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(size[ch[r][!id]] - size[ch[l][!id]] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                ans |= <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">                r = ch[r][!id]; l = ch[l][!id];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                r = ch[r][id];</span><br><span class="line">                l = ch[l][id];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="可持久化权值线段树-静态区间第k大查询"><a href="#可持久化权值线段树-静态区间第k大查询" class="headerlink" title="可持久化权值线段树 静态区间第k大查询"></a>可持久化权值线段树 静态区间第k大查询</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mid ((l + r) &gt;&gt; 1)</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn], c[maxn];</span><br><span class="line">unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line"><span class="keyword">int</span> ls[maxn &lt;&lt; N], rs[maxn &lt;&lt; N], root[maxn], num[maxn &lt;&lt; N], top = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = top++;</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span> p;</span><br><span class="line">    ls[p] = <span class="built_in">build</span>(l, mid);</span><br><span class="line">    rs[p] = <span class="built_in">build</span>(mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> now = top++;</span><br><span class="line">    ls[now] = ls[p]; rs[now] = rs[p]; num[now] = num[p] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span> now;</span><br><span class="line">    <span class="keyword">if</span>(k &lt;= mid) ls[now] = <span class="built_in">update</span>(ls[p], l, mid, k);</span><br><span class="line">    <span class="keyword">else</span> rs[now] = <span class="built_in">update</span>(rs[p], mid + <span class="number">1</span>, r, k);</span><br><span class="line">    <span class="keyword">return</span> now;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> r1, <span class="keyword">int</span> r2, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="comment">//[L + 1, R]</span></span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span> l;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> x = num[ls[r2]] - num[ls[r1]];</span><br><span class="line">    <span class="keyword">if</span>(k &lt;= x) <span class="keyword">return</span> <span class="built_in">query</span>(ls[r1], ls[r2], l, mid, k);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">query</span>(rs[r1], rs[r2], mid + <span class="number">1</span>, r, k - x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//    Fastin;</span></span><br><span class="line">    <span class="keyword">int</span> n, m; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, a + i);</span><br><span class="line">        c[i] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(c + <span class="number">1</span>, c + <span class="number">1</span> + n);</span><br><span class="line">    <span class="keyword">int</span> N = (<span class="keyword">int</span>)(<span class="built_in">unique</span>(c + <span class="number">1</span>, c + <span class="number">1</span> + n) - (c + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++) mp[c[i]] = i;</span><br><span class="line">    </span><br><span class="line">    root[<span class="number">0</span>] = <span class="built_in">build</span>(<span class="number">1</span>, N);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        root[i] = <span class="built_in">update</span>(root[i - <span class="number">1</span>], <span class="number">1</span>, N, mp[a[i]]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> l, r, k; <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;l, &amp;r, &amp;k);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, c[<span class="built_in">query</span>(root[l - <span class="number">1</span>], root[r], <span class="number">1</span>, N, k)]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="BIT套权值线段树-带单点修改的区间第k大查询"><a href="#BIT套权值线段树-带单点修改的区间第k大查询" class="headerlink" title="BIT套权值线段树 带单点修改的区间第k大查询"></a>BIT套权值线段树 带单点修改的区间第k大查询</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">6e4</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, N;</span><br><span class="line"><span class="keyword">int</span> a[maxn], b[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NODE</span>&#123;</span><span class="keyword">int</span> type, x, y, z;&#125;;</span><br><span class="line">NODE node[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hsh</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> (<span class="keyword">int</span>)(<span class="built_in">lower_bound</span>(b + <span class="number">1</span>, b + N, x) - b);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> s[maxn], rt[maxn], ls[maxn &lt;&lt; <span class="number">5</span>], rs[maxn &lt;&lt; <span class="number">5</span>], st[maxn &lt;&lt; <span class="number">5</span>], top = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> now = top++, mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span> now;</span><br><span class="line">    ls[now] = <span class="built_in">build</span>(l, mid);</span><br><span class="line">    rs[now] = <span class="built_in">build</span>(mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="keyword">return</span> now;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//旧版本的节点标号为p，拥有区间[l, r]；现要在k位置加入x，返回新节点的标号</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> now = top++;</span><br><span class="line">    ls[now] = ls[p]; rs[now] = rs[p]; st[now] = st[p] + x;</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span> now;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(k &lt;= mid) ls[now] = <span class="built_in">update</span>(ls[p], l, mid, k, x);</span><br><span class="line">    <span class="keyword">else</span> rs[now] = <span class="built_in">update</span>(rs[p], mid + <span class="number">1</span>, r, k, x);</span><br><span class="line">    <span class="keyword">return</span> now;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> use[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)&#123;</span><br><span class="line">        res += st[ls[use[x]]];</span><br><span class="line">        x -= <span class="built_in">lowbit</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当前在线段树的[l, r]位置上，左、右根节点分别为r1、r2，查询下标在(L, R]第k小的数字</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> r1, <span class="keyword">int</span> r2, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span> l;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="built_in">sum</span>(R) - <span class="built_in">sum</span>(L) + st[ls[r2]] - st[ls[r1]];</span><br><span class="line">    <span class="keyword">if</span>(k &lt;= res)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = L; i; i -= <span class="built_in">lowbit</span>(i)) use[i] = ls[use[i]];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = R; i; i -= <span class="built_in">lowbit</span>(i)) use[i] = ls[use[i]];</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(l, mid, ls[r1], ls[r2], L, R, k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = L; i; i -= <span class="built_in">lowbit</span>(i)) use[i] = rs[use[i]];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = R; i; i -= <span class="built_in">lowbit</span>(i)) use[i] = rs[use[i]];</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(mid + <span class="number">1</span>, r, rs[r1], rs[r2], L, R, k - res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> k, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= N)&#123;</span><br><span class="line">        s[i] = <span class="built_in">update</span>(s[i], <span class="number">1</span>, N, k, x);</span><br><span class="line">        i += <span class="built_in">lowbit</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//    Fastin;</span></span><br><span class="line">    TTT&#123;</span><br><span class="line">        top = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, a + i);</span><br><span class="line">            b[i] = a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        N = n + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> op[<span class="number">2</span>]; <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, op);</span><br><span class="line">            <span class="keyword">int</span> x, y, z;</span><br><span class="line">            <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">&#x27;Q&#x27;</span>)&#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;x, &amp;y, &amp;z);</span><br><span class="line">                node[i] = &#123;<span class="number">0</span>, x, y, z&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">                node[i] = &#123;<span class="number">1</span>, x, y&#125;;</span><br><span class="line">                b[N++] = y;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(b + <span class="number">1</span>, b + N);</span><br><span class="line">        N = (<span class="keyword">int</span>)(<span class="built_in">unique</span>(b + <span class="number">1</span>, b + N) - (b + <span class="number">1</span>));</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        rt[<span class="number">0</span>] = <span class="built_in">build</span>(<span class="number">1</span>, N);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            rt[i] = <span class="built_in">update</span>(rt[i - <span class="number">1</span>], <span class="number">1</span>, N, <span class="built_in">hsh</span>(a[i]), <span class="number">1</span>);</span><br><span class="line">            s[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="comment">//修改node[i].x位置的值为node[i].y;</span></span><br><span class="line">            <span class="keyword">if</span>(node[i].type)&#123;</span><br><span class="line">                <span class="built_in">update</span>(node[i].x, <span class="built_in">hsh</span>(a[node[i].x]), <span class="number">-1</span>);</span><br><span class="line">                <span class="built_in">update</span>(node[i].x, <span class="built_in">hsh</span>(node[i].y), <span class="number">1</span>);</span><br><span class="line">                a[node[i].x] = node[i].y;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//查询[node[i].x, node[i].y]中第k小的值</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> l = node[i].x - <span class="number">1</span>, r = node[i].y;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = l; i; i -= <span class="built_in">lowbit</span>(i)) use[i] = s[i];</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = r; i; i -= <span class="built_in">lowbit</span>(i)) use[i] = s[i];</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, b[<span class="built_in">query</span>(<span class="number">1</span>, N, rt[l], rt[r], l, r, node[i].z)]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a href="https://zoj.pintia.cn/problem-sets/91827364500/problems/91827365611">ZOJ 2112</a></p><p>在rt[0]构建一个空线段树，构建两串权值线段树，L96-99构建原始版本的静态的、前缀的权值线段树；另一串构建$Δ$线段树，利用bit进行维护这一串线段树。更新时对log个线段树进行单点更新，总花费$O(log^2n)$；查询时一层一层进行查询：查询bit上log个线段树节点所有的左儿子，如果这一层差值的和与静态值之和小于等于k，就将bit上log个子树的节点标号向左儿子移动，递归地类似于普通第k大查询进行处理即可。</p><p><strong>实际使用时注意仔细研究一下数据范围！</strong></p><h2 id="5-树"><a href="#5-树" class="headerlink" title="5 树"></a>5 树</h2><h3 id="树链剖分"><a href="#树链剖分" class="headerlink" title="树链剖分"></a>树链剖分</h3><h4 id="求lca"><a href="#求lca" class="headerlink" title="求lca"></a>求lca</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">5e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, q, rot;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">star</span>&#123;</span><span class="keyword">int</span> from, to, next;&#125;;</span><br><span class="line"><span class="keyword">int</span> head[manx];</span><br><span class="line">star edge[maxn &lt;&lt; <span class="number">1</span>]; <span class="keyword">int</span> top = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(itn u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    edge[top].from = u;</span><br><span class="line">    edge[top].to = v;</span><br><span class="line">    edge[top].next = head[u];</span><br><span class="line">    head[u] = top++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//默认标号从1开始，给重儿子打上标记。</span></span><br><span class="line"><span class="keyword">int</span> son[maxn], par[maxn], sze[maxn], dep[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tag</span><span class="params">(<span class="keyword">int</span> now)</span></span>&#123;</span><br><span class="line">    sze[now] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[now]; ~i; i = edge[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> to = edge[i].to; <span class="keyword">if</span>(to == par[now]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        par[to] = now; dep[to] = dep[now] + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">tag</span>(to); </span><br><span class="line">        sze[now] += sze[to];</span><br><span class="line">        <span class="keyword">if</span>(sze[to] &gt; sze[son[now]]) son[now] = to;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将该重链的起点作为dsu中一个联通块的根节点</span></span><br><span class="line"><span class="keyword">int</span> tp[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="comment">//存在儿子，即非叶子</span></span><br><span class="line">    tp[now] = t;</span><br><span class="line">    <span class="keyword">if</span>(son[now]) <span class="built_in">build</span>(son[now], t);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[now]; ~i; i = edge[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> to = edge[i].to; <span class="keyword">if</span>(to == par[now] || to == son[now]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">build</span>(to, to);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(tp[u] != tp[v])&#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[tp[u]] &gt; dep[tp[v]]) u = par[tp[u]];</span><br><span class="line">        <span class="keyword">else</span> v = par[tp[v]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dep[u] &lt; dep[v]? u: v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// Fastin;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">clr</span>(head, <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;n, &amp;q, &amp;rot);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> u, v; <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">        <span class="built_in">add</span>(u, v); <span class="built_in">add</span>(v, u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">tag</span>(rot); <span class="built_in">build</span>(rot, rot);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; q; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> u, v; <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">lca</span>(u, v));</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>速度很快，应该是吊打st和倍增。</p><h4 id="支持路径修改-查询、子树修改查询"><a href="#支持路径修改-查询、子树修改查询" class="headerlink" title="支持路径修改/查询、子树修改查询"></a>支持路径修改/查询、子树修改查询</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, q, rot, M;</span><br><span class="line"><span class="keyword">int</span> w[maxn];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">star</span>&#123;</span><span class="keyword">int</span> from, to, next;&#125;;</span><br><span class="line"><span class="keyword">int</span> head[maxn];</span><br><span class="line">star edge[maxn &lt;&lt; <span class="number">1</span>]; <span class="keyword">int</span> top = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(itn u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    edge[top].from = u;</span><br><span class="line">    edge[top].to = v;</span><br><span class="line">    edge[top].next = head[u];</span><br><span class="line">    head[u] = top++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> son[maxn], par[maxn], sze[maxn], dep[maxn];</span><br><span class="line"><span class="comment">//默认标号从1开始，给重儿子打上标记。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getson</span><span class="params">(<span class="keyword">int</span> now)</span></span>&#123;</span><br><span class="line">    sze[now] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[now]; ~i; i = edge[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> to = edge[i].to; <span class="keyword">if</span>(to == par[now]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        par[to] = now; dep[to] = dep[now] + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">getson</span>(to); </span><br><span class="line">        sze[now] += sze[to];</span><br><span class="line">        <span class="keyword">if</span>(sze[to] &gt; sze[son[now]]) son[now] = to;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> tp[maxn];</span><br><span class="line"><span class="comment">//将该重链的起点作为dsu中一个联通块的根节点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getlink</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="comment">//存在儿子，即非叶子</span></span><br><span class="line">    tp[now] = t;</span><br><span class="line">    <span class="keyword">if</span>(son[now]) <span class="built_in">getlink</span>(son[now], t);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[now]; ~i; i = edge[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> to = edge[i].to; <span class="keyword">if</span>(to == par[now] || to == son[now]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">getlink</span>(to, to);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//dfn为dfn序，pos为某个节点在dfn中的位置;</span></span><br><span class="line"><span class="keyword">int</span> r[maxn], pos[maxn], cnt = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> now)</span></span>&#123;</span><br><span class="line">    pos[now] = cnt; cnt++;</span><br><span class="line">    <span class="keyword">if</span>(son[now]) <span class="built_in">dfs</span>(son[now]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[now]; ~i; i = edge[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> to = edge[i].to; <span class="keyword">if</span>(to == par[now] || to == son[now]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(to);</span><br><span class="line">    &#125;</span><br><span class="line">    r[now] = cnt - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls (p &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs ((p &lt;&lt; 1) | 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mid ((l + r) &gt;&gt; 1)</span></span><br><span class="line"><span class="comment">//在dfn上的修改&amp;查询,利用pos映射</span></span><br><span class="line">ll st[maxn &lt;&lt; <span class="number">2</span>], tag[maxn &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;st[p] = st[ls] + st[rs]; st[p] %= M;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tag[p])&#123;</span><br><span class="line">        tag[p] %= M;</span><br><span class="line">        tag[ls] += tag[p]; tag[rs] += tag[p];</span><br><span class="line">        tag[ls] %= M; tag[rs] %= M;</span><br><span class="line">        st[ls] += (mid - l + <span class="number">1</span>) * tag[p] % M; st[ls] %= M;</span><br><span class="line">        st[rs] += (r - mid) * tag[p]; st[rs] %= M;</span><br><span class="line">        tag[p] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(L &lt;= R);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R)&#123;</span><br><span class="line">        st[p] += (r - l + <span class="number">1</span>) * x; st[p] %= M;</span><br><span class="line">        tag[p] += x; tag[p] %= M;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">down</span>(p, l, r);</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= mid) <span class="built_in">update</span>(ls, l, mid, L, R, x);</span><br><span class="line">    <span class="keyword">if</span>(R &gt; mid) <span class="built_in">update</span>(rs, mid + <span class="number">1</span>, r, L, R, x);</span><br><span class="line">    <span class="built_in">up</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R) <span class="keyword">return</span> st[p];</span><br><span class="line">    <span class="built_in">down</span>(p, l, r);</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= mid) ans += <span class="built_in">query</span>(ls, l, mid, L, R); ans %= M;</span><br><span class="line">    <span class="keyword">if</span>(R &gt; mid) ans += <span class="built_in">query</span>(rs, mid + <span class="number">1</span>, r, L, R);</span><br><span class="line">    <span class="keyword">return</span> ans % M;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updatepath</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(tp[u] != tp[v])&#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[tp[u]] &gt; dep[tp[v]])&#123;</span><br><span class="line">            <span class="comment">//u所在的重链更深</span></span><br><span class="line">            <span class="built_in">update</span>(<span class="number">1</span>, <span class="number">0</span>, cnt - <span class="number">1</span>, pos[tp[u]], pos[u], x);</span><br><span class="line">            u = par[tp[u]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">update</span>(<span class="number">1</span>, <span class="number">0</span>, cnt - <span class="number">1</span>, pos[tp[v]], pos[v], x);</span><br><span class="line">            v = par[tp[v]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dep[u] &gt; dep[v]) <span class="built_in">swap</span>(u, v);</span><br><span class="line">    <span class="built_in">udpate</span>(<span class="number">1</span>, <span class="number">0</span>, cnt - <span class="number">1</span>, pos[u], pos[v], x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">pathquery</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(tp[u] != tp[v])&#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[tp[u]] &gt; dep[tp[v]])&#123;</span><br><span class="line">            ans += <span class="built_in">query</span>(<span class="number">1</span>, <span class="number">0</span>, cnt - <span class="number">1</span>, pos[tp[u]], pos[u]);</span><br><span class="line">            ans %= M;</span><br><span class="line">            u = par[tp[u]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            ans += <span class="built_in">query</span>(<span class="number">1</span>, <span class="number">0</span>, cnt - <span class="number">1</span>, pos[tp[v]], pos[v]);</span><br><span class="line">            ans %= M;</span><br><span class="line">            v = par[tp[v]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dep[u] &gt; dep[v]) <span class="built_in">swap</span>(u, v);</span><br><span class="line">    ans += <span class="built_in">query</span>(<span class="number">1</span>, <span class="number">0</span>, cnt - <span class="number">1</span>, pos[u], pos[v]);</span><br><span class="line">    ans %= M;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// Fastin;</span></span><br><span class="line">    <span class="built_in">clr</span>(head, <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d %d&quot;</span>, &amp;n, &amp;q, &amp;rot, &amp;M);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, w + i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> u, v; <span class="built_in">scnaf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">        <span class="built_in">add</span>(u, v); <span class="built_in">add</span>(v, u);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">getson</span>(rot); <span class="built_in">getlink</span>(rot, rot); <span class="built_in">dfs</span>(rot); </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">update</span>(<span class="number">1</span>, <span class="number">0</span>, cnt - <span class="number">1</span>, pos[i], pos[i], w[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; q; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> op; <span class="built_in">scnaf</span>(<span class="string">&quot;%d&quot;</span>, &amp;op);</span><br><span class="line">        <span class="keyword">int</span> x, y, z; </span><br><span class="line">        <span class="keyword">if</span>(op == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;x, &amp;y, &amp;z);</span><br><span class="line">            <span class="built_in">updatepath</span>(x, y, z);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;x, &amp;y); <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">pathquery</span>(x, y) % M);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="number">3</span>)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;x, &amp;y); <span class="built_in">udpate</span>(<span class="number">1</span>, <span class="number">0</span>, cnt - <span class="number">1</span>, pos[x], r[x], y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x); <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">query</span>(<span class="number">1</span>, <span class="number">0</span>, cnt - <span class="number">1</span>, pos[x], r[x]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>为了充分利用重链和dfn序，在dfs时优先遍历重链，这样即可保证重链上的节点在dfn序列上连续。</p><p>修改路径时只需要参考前述求lca的跳点规则，一段段地在线段树上进行区间修改可。</p><p>而修改路径更为简单，只需要记录一下子树在dfn序列上的辖域即可。</p><h3 id="点分治"><a href="#点分治" class="headerlink" title="点分治"></a>点分治</h3><h4 id="计数树上两点之间路径长度为k的对数（开桶加速-多组查询）"><a href="#计数树上两点之间路径长度为k的对数（开桶加速-多组查询）" class="headerlink" title="计数树上两点之间路径长度为k的对数（开桶加速 多组查询）"></a>计数树上两点之间路径长度为k的对数（开桶加速 多组查询）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e4</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">star</span>&#123;</span><span class="keyword">int</span> to, next, w;&#125;;</span><br><span class="line"><span class="keyword">int</span> head[maxn], top = <span class="number">0</span>;</span><br><span class="line">star edge[maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    edge[top].to = v;</span><br><span class="line">    edge[top].next = head[u];</span><br><span class="line">    edge[top].w = w;</span><br><span class="line">    head[u] = top++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用getroot前应该初始化S！！！</span></span><br><span class="line"><span class="keyword">int</span> root = <span class="number">0</span>, S;</span><br><span class="line"><span class="keyword">int</span> vis[maxn], sze[maxn], mx[maxn];;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getroot</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> par)</span></span>&#123;</span><br><span class="line">    sze[u] = <span class="number">1</span>; mx[u] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = haed[u]; ~i; i = edge[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> to = edge[i].to; <span class="keyword">if</span>(vis[to] || to == par) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">getroot</span>(to, u);</span><br><span class="line">        sze[u] += sze[to];</span><br><span class="line">        mx[u] = <span class="built_in">max</span>(mx[u], sze[to]);</span><br><span class="line">    &#125;</span><br><span class="line">    mx[u] = <span class="built_in">max</span>(mx[u], S - sze[u]);</span><br><span class="line">    <span class="keyword">if</span>(mx[u] &lt; mx[root]) root = u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; dis;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> par, <span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(d &gt; <span class="number">10000000</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; ~i; i = edge[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> to = edge[i].to; <span class="keyword">if</span>(vis[to] || to == par) <span class="keyword">continue</span>;</span><br><span class="line">        dis.<span class="built_in">push_back</span>(d + edge[i].w);</span><br><span class="line">        <span class="built_in">dfs</span>(to, u, d + edge[i].w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> tong[<span class="number">10000010</span>];</span><br><span class="line"><span class="keyword">int</span> k[maxn], ans[maxn];</span><br><span class="line"><span class="comment">//获取经过u的答案，路径长度有基础偏移值d</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> d, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    dis.<span class="built_in">clear</span>(); dis.<span class="built_in">push_back</span>(d); <span class="built_in">dfs</span>(u, <span class="number">0</span>, d);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>)dis.<span class="built_in">size</span>(); i++) <span class="keyword">if</span>(dis[i] &lt;= <span class="number">10000000</span>) tong[dis[i]]++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>)dis.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dis[i] + dis[i] &lt; k[j]) ans[j] += (tong[k[j] - dis[i]]) * x;</span><br><span class="line">            <span class="keyword">if</span>(dis[i] + dis[i] == k[j]) ans[j] += (tong[dis[i]] - <span class="number">1</span>) * x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>)dis.<span class="built_in">size</span>(); i++) <span class="keyword">if</span>(dis[i] &lt;= <span class="number">10000000</span>) tong[dis[i]]--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//u是重心，考察以经过u的路径长度</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sove</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="comment">//封锁u节点，分治地寻找子树.</span></span><br><span class="line">    vis[u] = <span class="number">1</span>; <span class="built_in">fun</span>(u, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; ~i; i = edge[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> to = edge[i].to; <span class="keyword">if</span>(vis[to]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">//删去那些根本不经过u的点对</span></span><br><span class="line">        <span class="built_in">fun</span>(to, edge[i].w, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        S = sze[to]; root = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">getroot</span>(to, u);</span><br><span class="line">        <span class="built_in">sove</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//    Fastin;</span></span><br><span class="line">    <span class="built_in">clr</span>(head, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> u, v, w; <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line">        <span class="built_in">add</span>(u, v, w); <span class="built_in">add</span>(v, u, w);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, k + i);</span><br><span class="line"></span><br><span class="line">    mx[<span class="number">0</span>] = n; root = <span class="number">0</span>;</span><br><span class="line">    S = n; <span class="built_in">clr</span>(vis, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">getroot</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">sove</span>(root);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) <span class="built_in">puts</span>(ans[i]? <span class="string">&quot;AYE&quot;</span>: <span class="string">&quot;NAY&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度$O(nlogn)$</p><ul><li>实际使用桶加速时需要根据题意修改桶的大小。</li><li>main函数中对于mx[0]的初始化必不可少</li><li>每次调用getroot前都应对S(当前子树总大小)进行初始化。</li><li>如果<strong>权值过大不能开桶</strong>，可以通过二分查找等方式多一个$log$地进行查询计数</li><li>找重心时S的更新应该如下才对？（不懂.gif</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(sze[to] &lt; sze[u]) S = sze[to];</span><br><span class="line"><span class="keyword">else</span> S = sze[to] - sze[u];</span><br></pre></td></tr></table></figure><h3 id="点分树"><a href="#点分树" class="headerlink" title="点分树"></a>点分树</h3><h4 id="多组查询与某点距离小于等于k的所有点权和-并支持单点修改"><a href="#多组查询与某点距离小于等于k的所有点权和-并支持单点修改" class="headerlink" title="多组查询与某点距离小于等于k的所有点权和 并支持单点修改"></a>多组查询与某点距离小于等于k的所有点权和 并支持单点修改</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mid ((l + r) &gt;&gt; 1)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> manx = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="comment">//根据dfn数组的长度决定N(即N = log2(cnt), cnt = maxn &lt;&lt; 1)</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, q;</span><br><span class="line"><span class="keyword">int</span> w[manx];</span><br><span class="line"><span class="comment">//动态开点的单点修改、区间求和线段树</span></span><br><span class="line"><span class="comment">//维护两个st，一个是u子树对u的贡献，另一个是u子树对par[u]的贡献（如果有的话）</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = maxn * N * <span class="number">4</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SEG</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> root[maxn];</span><br><span class="line">    <span class="keyword">int</span> st[M], ls[M], rs[M], top = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> now = top++;</span><br><span class="line">        <span class="keyword">if</span>(l == r) <span class="keyword">return</span> now;</span><br><span class="line">        ls[now] = <span class="built_in">build</span>(l, mid);</span><br><span class="line">        rs[now] = <span class="built_in">build</span>(mid + <span class="number">1</span>, r);</span><br><span class="line">        <span class="keyword">return</span> now;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;st[p] = st[ls[p]] + st[rs[p]];&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>(k &gt;= l &amp;&amp; k &lt;= r);</span><br><span class="line">        <span class="keyword">if</span>(l == r &amp;&amp; l == k)&#123;</span><br><span class="line">            st[p] += x;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(k &lt;= mid) <span class="built_in">add</span>(ls[p], l, mid, k, x);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">add</span>(rs[p], mid + <span class="number">1</span>, r, k, x);</span><br><span class="line">        <span class="built_in">up</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(R &lt; L) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R) <span class="keyword">return</span> st[p];</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(L &lt;= mid) ans += <span class="built_in">query</span>(ls[p], l, mid, L, R);</span><br><span class="line">        <span class="keyword">if</span>(R &gt; mid) ans += <span class="built_in">query</span>(rs[p], mid + <span class="number">1</span>, r, L, R);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;seg[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; E;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TREE</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> head[maxn], par[manx], top = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">star</span>&#123;</span><span class="keyword">int</span> to, next;&#125;;</span><br><span class="line">    star edge[maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">TREE</span>()&#123;<span class="built_in">clr</span>(head, <span class="number">-1</span>); top = <span class="number">0</span>;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">        edge[top].to = v;</span><br><span class="line">        edge[top].next = head[u];</span><br><span class="line">        head[u] = top++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; &amp;E)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> e: E)&#123;</span><br><span class="line">            <span class="built_in">add</span>(e.first, e.second);</span><br><span class="line">            par[e.second] = e.first;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mx[maxn], sze[maxn], vis[maxn], root = <span class="number">0</span>, S;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getroot</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> par)</span></span>&#123;</span><br><span class="line">        sze[now] = <span class="number">1</span>; mx[now] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = head[now]; ~i; i = edge[i].next)&#123;</span><br><span class="line">            <span class="keyword">int</span> to = edge[i].to; <span class="keyword">if</span>(to == par || vis[to]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">getroot</span>(to, now);</span><br><span class="line">            sze[now] += sze[to];</span><br><span class="line">            mx[now] = <span class="built_in">max</span>(mx[now], sze[to]);</span><br><span class="line">        &#125;</span><br><span class="line">        mx[now] = <span class="built_in">max</span>(mx[now], S - sze[now]);</span><br><span class="line">        <span class="keyword">if</span>(mx[root] &gt; mx[now]) root = now;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当前分治中心为now，封锁住通往par的路径，函数返回重心</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> par)</span></span>&#123;</span><br><span class="line">        root = <span class="number">0</span>; <span class="built_in">getroot</span>(now, par);</span><br><span class="line">        <span class="keyword">int</span> rt = root; vis[rt] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = head[rt]; ~i; i = edge[i].next)&#123;</span><br><span class="line">            <span class="keyword">int</span> to = edge[i].to; <span class="keyword">if</span>(to == par || vis[to]) <span class="keyword">continue</span>;</span><br><span class="line">            S = sze[to];</span><br><span class="line">            E.<span class="built_in">push_back</span>(&#123;rt, <span class="built_in">divide</span>(to, rt)&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将树重构为点分树，点分数的边存放在E中，供tree[1].add调用；返回重构树的根</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rebuild</span><span class="params">()</span></span>&#123;</span><br><span class="line">        S = mx[<span class="number">0</span>] = n;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">divide</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//初始化dfn、pos数组，得到每个节点的深度dep</span></span><br><span class="line">    <span class="keyword">int</span> dfn[maxn &lt;&lt; <span class="number">1</span>], pos[manx], cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> dep[maxn];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> par)</span></span>&#123;</span><br><span class="line">        dfn[cnt] = now; pos[now] = cnt; cnt++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = head[now]; ~i; i = edge[i].next)&#123;</span><br><span class="line">            <span class="keyword">int</span> to = edge[i].to; <span class="keyword">if</span>(to == par) <span class="keyword">continue</span>;</span><br><span class="line">            dep[to] = dep[now] + <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(to, now);</span><br><span class="line">            dfn[cnt++] = now;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> st[maxn &lt;&lt; <span class="number">1</span>][N];</span><br><span class="line">    <span class="comment">//通过深度数组获取st表, st维护区间中深度最小的节点标号</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getst</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt; i++) st[i][<span class="number">0</span>] = dfn[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; N; j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt; i++)&#123;</span><br><span class="line">                <span class="keyword">int</span> nxt = i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>));</span><br><span class="line">                <span class="keyword">if</span>(nxt &gt;= cnt) st[i][j] = st[i][j - <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(dep[st[i][j - <span class="number">1</span>]] &lt; dep[st[nxt][j - <span class="number">1</span>]]) st[i][j] = st[i][j - <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">else</span> st[i][j] = st[nxt][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//O1获取两点之间的距离</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getdis</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == y) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="built_in">min</span>(pos[x], pos[y]), r = <span class="built_in">max</span>(pos[x], pos[y]);</span><br><span class="line">        <span class="keyword">int</span> k = (<span class="keyword">int</span>)(<span class="built_in">log2</span>(r - l) + eps);</span><br><span class="line">        <span class="keyword">int</span> lca = st[l][k];</span><br><span class="line">        <span class="keyword">if</span>(dep[lca] &gt; dep[st[r - (<span class="number">1</span> &lt;&lt; k) + <span class="number">1</span>][k]]) lca = st[r - (<span class="number">1</span> &lt;&lt; k) + <span class="number">1</span>][k];</span><br><span class="line">        <span class="keyword">return</span> dep[x] + dep[y] - <span class="number">2</span> * dep[lca];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取子树大小并初始化线段树</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ini</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> par)</span></span>&#123;</span><br><span class="line">        sze[now] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = head[now]; ~i; i = edge[i].next)&#123;</span><br><span class="line">            <span class="keyword">int</span> to = edge[i].to; <span class="keyword">if</span>(to == par) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">ini</span>(to, now);</span><br><span class="line">            sze[now] += sze[to];</span><br><span class="line">        &#125;</span><br><span class="line">        seg[<span class="number">0</span>].root[now] = seg[<span class="number">0</span>].<span class="built_in">build</span>(<span class="number">0</span>, sze[now]);</span><br><span class="line">        seg[<span class="number">1</span>].root[now] = seg[<span class="number">1</span>].<span class="built_in">build</span>(<span class="number">0</span>, sze[now] + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;tree[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//第k个城市上发生x的增量，当前处理到now节点，保证now节点一定是k的祖先</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> k, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dis = tree[<span class="number">0</span>].<span class="built_in">getdis</span>(now, k);</span><br><span class="line">    seg[<span class="number">0</span>].<span class="built_in">add</span>(seg[<span class="number">0</span>].root[now], <span class="number">0</span>, tree[<span class="number">1</span>].sze[now], dis, x);</span><br><span class="line">    <span class="keyword">if</span>(tree[<span class="number">1</span>].par[now])&#123;</span><br><span class="line">        dis = tree[<span class="number">0</span>].<span class="built_in">getdis</span>(tree[<span class="number">1</span>].par[now], k);</span><br><span class="line">        seg[<span class="number">1</span>].<span class="built_in">add</span>(seg[<span class="number">1</span>].root[now], <span class="number">0</span>, tree[<span class="number">1</span>].sze[now] + <span class="number">1</span>, dis, x);</span><br><span class="line">        <span class="built_in">add</span>(tree[<span class="number">1</span>].par[now], k, x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查询距离k城市距离小于等于x的价值和，当前处理到now</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> k, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> d = tree[<span class="number">0</span>].<span class="built_in">getdis</span>(now, k);</span><br><span class="line">    ans += seg[<span class="number">0</span>].<span class="built_in">query</span>(seg[<span class="number">0</span>].root[now], <span class="number">0</span>, tree[<span class="number">1</span>].sze[now], <span class="number">0</span>, x - d);</span><br><span class="line">    <span class="keyword">if</span>(tree[<span class="number">1</span>].par[now])&#123;</span><br><span class="line">        <span class="keyword">int</span> D = tree[<span class="number">0</span>].<span class="built_in">getdis</span>(tree[<span class="number">1</span>].par[now], k);</span><br><span class="line">        ans -= seg[<span class="number">1</span>].<span class="built_in">query</span>(seg[<span class="number">1</span>].root[now], <span class="number">0</span>, tree[<span class="number">1</span>].sze[now] + <span class="number">1</span>, <span class="number">0</span>, x - D);</span><br><span class="line">        ans += <span class="built_in">query</span>(tree[<span class="number">1</span>].par[now], k, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//     Fastin;</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, w + i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> u, v; <span class="built_in">scnaf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">        tree[<span class="number">0</span>].<span class="built_in">add</span>(u, v); tree[<span class="number">0</span>].<span class="built_in">add</span>(v, u);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    tree[<span class="number">0</span>].<span class="built_in">getst</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> root = tree[<span class="number">0</span>].<span class="built_in">rebuild</span>();</span><br><span class="line">    tree[<span class="number">1</span>].<span class="built_in">add</span>(E);</span><br><span class="line"></span><br><span class="line">    tree[<span class="number">1</span>].<span class="built_in">ini</span>(root, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">add</span>(i, i, w[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">whlie</span>(q--)&#123;</span><br><span class="line">        <span class="keyword">int</span> op, x, y; <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;op, &amp;x, &amp;y);</span><br><span class="line">      <span class="comment">//强制在线</span></span><br><span class="line">        x ^= ans; y ^= ans;</span><br><span class="line">        <span class="keyword">if</span>(op)&#123;</span><br><span class="line">            <span class="built_in">add</span>(x, x, y - w[x]);</span><br><span class="line">            w[x] = y;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans = <span class="built_in">query</span>(x, x, y));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>主要数据结构<ul><li>tree[0]: 原树<ul><li>利用mx[maxn]、sze[maxn]、vis[maxn]、root、S对树进行重构，将重构结果的边暂时保存在vector<pair<int, int>&gt; E中，等待之后存放到tree[1]中</li><li>利用dfn[maxn &lt;&lt; 1]、pos[maxn]、cnt、dep[maxn]、st[maxn &lt;&lt; 1][N]建立st表，提供接口getdis进行O1查询距离。<strong>ST表的大小应当与dfn相同！同时注意建立ST表时边界越界的问题！</strong></li></ul></li><li>tree[1]: 原树重构后得到的点分树<ul><li>利用ini()函数获取点分树上所有子树的大小，将该大小作为线段树的边界，同时完成动态开点的线段树的初始化。</li></ul></li><li>seg[0]: 动态开点的权值线段树(单点修改、区间查询)<ul><li>通过seg[0].root数组作为tree[1]中每个节点的入口</li><li>对于某个节点u而言，权值线段树的值域区间为[0, tree[1].sze[u]]，存储的内容为tree[1]中u节点所有孩子对u的贡献</li><li>需要的空间为n <em> logn </em> 4</li></ul></li><li>seg[1]: 动态开点的权值线段树(单点修改、区间查询)<ul><li>通过seg[1].root数组作为tree[1]中每个节点的入口</li><li>对于某个节点u而言，权值线段树的值域区间为[0, tree[1].sze[u] + 1] (<code>+1</code>是必要的)，存储的内容为tree[1]中u节点所有孩子对<strong>par[u]</strong>（如果存在的话）的贡献</li><li>需要的空间为n <em> logn </em> 4</li></ul></li></ul></li><li>使用指南<ul><li>读入原树到tree[0]后，调用tree[0].getst()初始化st表</li><li>调用tree[0].rebuild()重构原树，新树的边存放在E中，再开变量root存放函数的返回值(即新树的根)</li><li>调用tree[1].add(E)将E中的有向边加入到tree[1]中</li><li>调用tree[1].ini(root)从新树的根开始，完成新树上套线段树的建立</li><li>调用add函数将原树的所有点权加入到线段树中，完成线段树的初始化</li><li>读入q次查询，根据查询的类型调用add/query进行操作即可。</li></ul></li></ul><h3 id="pruefer序列"><a href="#pruefer序列" class="headerlink" title="pruefer序列"></a>pruefer序列</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">5e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> par[maxn], prufer[maxn], du[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">encode</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ptr = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">if</span>(ptr == <span class="number">-1</span> &amp;&amp; du[i] == <span class="number">1</span>) ptr = i;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> leaf = ptr;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">2</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> next = prufer[i] = par[leaf];</span><br><span class="line">        <span class="keyword">if</span>(--du[next] == <span class="number">1</span> &amp;&amp; next &lt; ptr) leaf = next;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            ptr++;</span><br><span class="line">            <span class="keyword">while</span>(du[ptr] != <span class="number">1</span>) ptr++;</span><br><span class="line">            leaf = ptr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rebuild</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ptr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(du[ptr] != <span class="number">1</span>) ptr++;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> leaf = ptr;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">2</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> next = par[leaf] = prufer[i];</span><br><span class="line">        <span class="keyword">if</span>(--du[next] == <span class="number">1</span> &amp;&amp; next &lt; ptr) leaf = next;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            ptr++;</span><br><span class="line">            <span class="keyword">while</span>(du[ptr] != <span class="number">1</span>) ptr++;</span><br><span class="line">            leaf = ptr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    par[leaf] = n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hsh</span><span class="params">(<span class="keyword">int</span> a[maxn], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) ans ^= (i + <span class="number">1</span>) * <span class="number">1ll</span> * a[i];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//    Fastin;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> op;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;op);</span><br><span class="line">    <span class="keyword">if</span>(op == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, par + i);</span><br><span class="line">            du[par[i]]++; du[i]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">encode</span>();</span><br><span class="line">        <span class="built_in">hsh</span>(prufer, n - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) du[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">2</span>; i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, prufer + i);</span><br><span class="line">            du[prufer[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">rebuild</span>();</span><br><span class="line">        <span class="built_in">hsh</span>(par + <span class="number">1</span>, n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用指南</p><ul><li>读入点数n和操作数op</li><li>op = 1 读入节点$[1, …,n-1]$的父亲，调用encode后将prufer序列保存在$prufer[0, n - 2)$中</li><li>op = 2 读入长为n-2的prufer序列，调用rebuild后将节点$[1, …, n -1]$的父亲存储在$par[1, .. n -1]$中</li></ul><p>TIPS</p><ul><li>因为prufer序列构造的特性，节点n一定是留到最后的那个节点，所以程序中读入/输出的par序列均是以n节点为根时的父子关系。</li></ul><h4 id="计数相关定理"><a href="#计数相关定理" class="headerlink" title="计数相关定理"></a>计数相关定理</h4><h5 id="凯莱公式"><a href="#凯莱公式" class="headerlink" title="凯莱公式"></a>凯莱公式</h5><p>完全图$K_n$有$n^{n-2}$棵生成树。</p><p>证明显然。</p><h5 id="图联通方案数"><a href="#图联通方案数" class="headerlink" title="图联通方案数"></a>图联通方案数</h5><p>一个n节点的带标号无向图有k个联通块。添加k-1条边使得图联通的方案数为$n^{k-2} * \prod s_i$.</p><p>证明：</p><p>尝试对k个联通块构造prufer序列。</p><p>由于每个联通块的度未知，因而设$d_i$为联通块i的度。$d_i$满足$\sum d_i = 2(k-1)$</p><p>则对于给定d序列后构造prufer序列的方案数为$(^{\space \space \space \space \space \space \space \space k-2}_{(d_1-1)!…(d_k-1)!})$</p><p>而对于某个联通块$s_i$而言，其连接方式为$s_i^{d_i}$种，因而对于给定d序列后图联通的方案数是$(^{\space \space \space \space \space \space \space \space k-2}_{(d_1-1)!…(d_k-1)!})*s_i^{d_i}$</p><p>接下来枚举d序列，即$\sum_{d_i≥1,\sum d_i=2k-2}(^{\space \space \space \space \space \space \space \space k-2}_{(d_1-1)!…(d_k-1)!})*\prod _{1 \leq i \leq k}s_i^{d_i}$</p><p>利用多元二项式定理: $(x_1+…+x_m)^p=\sum_{c_i≥0, \sum c_i=p}(^{\space \space \space \space p}_{c_1, …, c_m}) * \prod x_i^{c_i}$, 并换元$e_i=d_i-1$。$\sum e_i=k-2$</p><p>则原式成为$\sum _{e_i≥0, \sum e_i = k-2} (^{\space \space k-2}_{e_1, …, e_k})*\prod s_i^{e_i+1}$</p><p>化简得$(s_1+…+s_k)^{k-2} * \prod s_i$</p><p>即$n^{k-2} * \prod s_i$</p><h2 id="6-数学"><a href="#6-数学" class="headerlink" title="6 数学"></a>6 数学</h2><h3 id="异或线性基"><a href="#异或线性基" class="headerlink" title="异或线性基"></a>异或线性基</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">200</span> + <span class="number">10</span>;</span><br><span class="line">ll a[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> L = <span class="number">63</span>;</span><br><span class="line">ll d[L];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">add</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = L - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) <span class="keyword">if</span>(x &amp; <span class="number">1ll</span> &lt;&lt; i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(d[i] == <span class="number">-1</span>)&#123;d[i] = x; <span class="keyword">return</span> <span class="literal">true</span>;&#125;</span><br><span class="line">        x ^= d[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//    Fast;</span></span><br><span class="line">    <span class="keyword">int</span> t; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t); <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(d, <span class="number">-1</span>, <span class="keyword">sizeof</span> d);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, a + i);</span><br><span class="line">        <span class="keyword">char</span> s[maxn]; <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">add</span>(a[i]) &amp;&amp; s[i] == <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, flag);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="多项式"><a href="#多项式" class="headerlink" title="多项式"></a>多项式</h3><h4 id="FTT"><a href="#FTT" class="headerlink" title="FTT"></a>FTT</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">COM</span>&#123;</span></span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line">    COM <span class="keyword">operator</span> *(<span class="keyword">const</span> COM &amp;b)&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;x * b.x - y * b.y, x * b.y + y * b.x&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    COM <span class="keyword">operator</span> -(<span class="keyword">const</span> COM &amp;b)&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;x - b.x, y - b.y&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    COM <span class="keyword">operator</span> +(<span class="keyword">const</span> COM &amp;b)&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;x + b.x, y + b.y&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, sum, N, wei;</span><br><span class="line">COM a[maxn &lt;&lt; <span class="number">2</span>], b[maxn &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> inv[maxn &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//将0到N-1的多项式表示转化为点值表示</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fft</span><span class="params">(COM *a, <span class="keyword">int</span> op)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) <span class="keyword">if</span>(i &lt; inv[i]) <span class="built_in">swap</span>(a[inv[i]], a[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//逆fft将范德蒙德行列式的每一项取共轭再除以n</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = wei - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="keyword">int</span> d = <span class="number">1</span> &lt;&lt; (wei - i);</span><br><span class="line">        COM wn = &#123;<span class="built_in">cos</span>(<span class="number">2</span> * pi / d), op * <span class="built_in">sin</span>(<span class="number">2</span> * pi / d)&#125;;</span><br><span class="line">        <span class="comment">//j遍历第i层的开头</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j += d)&#123;</span><br><span class="line">            <span class="comment">//对j开头的一小段进行更新</span></span><br><span class="line">            COM w = &#123;<span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; d / <span class="number">2</span>; k++)&#123;</span><br><span class="line">                COM x, y;</span><br><span class="line">                x = a[j + k]; y = a[j + k + d / <span class="number">2</span>] * w;</span><br><span class="line">                a[j + k] = x + y; a[j + k + d / <span class="number">2</span>] = x - y;</span><br><span class="line">                w = w * wn;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//#define LOCAL</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>, &amp;a[i].x);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>, &amp;b[i].x);</span><br><span class="line">    </span><br><span class="line">    sum = n + m + <span class="number">1</span>; N = <span class="number">1</span>; wei = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(N &lt; sum)&#123;N *= <span class="number">2</span>; wei++;&#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">1</span> &lt;&lt; wei; j++)</span><br><span class="line">        inv[j] = inv[j &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span> | (j &amp; <span class="number">1</span>) &lt;&lt; (wei - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">fft</span>(a, <span class="number">1</span>); <span class="built_in">fft</span>(b, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) a[i] = a[i] * b[i];</span><br><span class="line">    <span class="built_in">fft</span>(a, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n + m + <span class="number">1</span>; i++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, (<span class="keyword">int</span>)(a[i].x / N + <span class="number">0.5</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输入n、m，接n+1和m+1个整数，分别表示n次多项式和m次多项式从低到高的系数。</p><p>输出n+m+1个系数。</p><h4 id="NTT"><a href="#NTT" class="headerlink" title="NTT"></a>NTT</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> p = <span class="number">3</span>, invp = <span class="number">332748118</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, sum, N, wei;</span><br><span class="line">ll a[maxn &lt;&lt; <span class="number">2</span>], b[maxn &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> inv[maxn &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quick_pow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    ll ans = <span class="number">1</span>, res = a;</span><br><span class="line">    <span class="keyword">while</span>(p)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p &amp; <span class="number">1</span>) ans *= res; ans %= M;</span><br><span class="line">        res *= res; res %= M;</span><br><span class="line">        p &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans % M;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//逆fft将范德蒙德行列式的每一项取共轭再除以n</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fft</span><span class="params">(ll *a, <span class="keyword">int</span> op)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) <span class="keyword">if</span>(i &lt; inv[i]) <span class="built_in">swap</span>(a[inv[i]], a[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = wei - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="keyword">int</span> d = <span class="number">1</span> &lt;&lt; (wei - i);</span><br><span class="line">        ll gn = <span class="built_in">quick_pow</span>(op == <span class="number">1</span>? p: invp, (M - <span class="number">1</span>) / d);</span><br><span class="line">        <span class="comment">//j遍历第i层的开头</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j += d)&#123;</span><br><span class="line">            <span class="comment">//对j开头的小段进行更新</span></span><br><span class="line">            ll g = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; d / <span class="number">2</span>; k++)&#123;</span><br><span class="line">                ll x, y;</span><br><span class="line">                x = a[j + k] % M;</span><br><span class="line">                y = a[j + k + d / <span class="number">2</span>] * g; y %= M;</span><br><span class="line">                a[j + k] = (x + y) % M; a[j + k + d / <span class="number">2</span>] = (x - y + M) % M;</span><br><span class="line">                g = g * gn; g %= M;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//#define LOCAL</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n,  &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, a + i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, b + i);</span><br><span class="line"></span><br><span class="line">    sum = n + m + <span class="number">1</span>; N = <span class="number">1</span>; wei = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(N &lt; sum)&#123;N *= <span class="number">2</span>; wei++;&#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">1</span> &lt;&lt; wei; j++)</span><br><span class="line">        inv[j] = inv[j &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span> | (j &amp; <span class="number">1</span>) &lt;&lt; (wei - <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">fft</span>(a, <span class="number">1</span>); <span class="built_in">fft</span>(b, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) a[i] = (a[i] * b[i]) % M;</span><br><span class="line">    <span class="built_in">fft</span>(a, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">int</span> invn = <span class="built_in">quick_pow</span>(N, M - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n + m + <span class="number">1</span>; i++) <span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>, (a[i] * invn + M) % M);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输入n、m，接n+1和m+1个整数，分别表示n次多项式和m次多项式从低到高的系数。</p><p>输出n+m+1个系数。</p><h3 id="高斯整数"><a href="#高斯整数" class="headerlink" title="高斯整数"></a>高斯整数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">GaussianInteger</span>&#123;</span></span><br><span class="line">    ll x, y;</span><br><span class="line">    <span class="function">ll <span class="title">norm</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> x * x + y * y;&#125;</span><br><span class="line">    GaussianInteger <span class="keyword">operator</span> + (<span class="keyword">const</span> GaussianInteger &amp;b)&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;x + b.x, y + b.y&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    GaussianInteger <span class="keyword">operator</span> - (<span class="keyword">const</span> GaussianInteger &amp;b)&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;x - b.x, y - b.y&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    GaussianInteger <span class="keyword">operator</span> * (<span class="keyword">const</span> GaussianInteger &amp;b)&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;x * b.x - y * b.y, x * b.y + y * b.x&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//(专用! 因为此处b保证大于0)四舍五入除法</span></span><br><span class="line">    <span class="comment">//高斯整数商的实部虚部在某个整数的**(-1/2, 1/2]**区间中。</span></span><br><span class="line">    <span class="function">ll <span class="title">D</span><span class="params">(ll a, ll b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a &gt;= <span class="number">0</span>) <span class="keyword">return</span> (a % b) * <span class="number">2</span> &lt; b? a / b: a / b + <span class="number">1</span>;</span><br><span class="line">        a = -a; <span class="keyword">return</span> -((a % b) * <span class="number">2</span> &lt;= b? a / b: a / b + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    GaussianInteger <span class="keyword">operator</span> / (<span class="keyword">const</span> GaussianInteger &amp;b)&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="built_in">D</span>(x * b.x + y * b.y, x * b.x + y * b.y), <span class="built_in">D</span>(y * b.x - x * b.y, x * b.x + y * b.y)&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    GaussianInteger <span class="keyword">operator</span> % (<span class="keyword">const</span> GaussianInteger &amp;b)&#123;</span><br><span class="line">        GaussianInteger a = &#123;x, y&#125;;</span><br><span class="line">        <span class="keyword">return</span> a - a / b * b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> GaussianInteger NODE;</span><br><span class="line"><span class="function">NODE <span class="title">gcd</span><span class="params">(NODE a, NODE b)</span></span>&#123;<span class="keyword">return</span> !b.<span class="built_in">norm</span>()? a: <span class="built_in">gcd</span>(b, a % b);&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="线性代数"><a href="#线性代数" class="headerlink" title="线性代数"></a>线性代数</h3><h4 id="Gauss-Jordan消元法"><a href="#Gauss-Jordan消元法" class="headerlink" title="Gauss-Jordan消元法"></a>Gauss-Jordan消元法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">使用指南：</span></span><br><span class="line"><span class="comment">    读入&quot;整形&quot;增广矩阵a，修改行列信息equ、var。</span></span><br><span class="line"><span class="comment">    从零开始编号，则行为[0, equ - 1], 列为[0, var];</span></span><br><span class="line"><span class="comment">    返回值：</span></span><br><span class="line"><span class="comment">        返回0说明有整数解，结果存放在x数组中</span></span><br><span class="line"><span class="comment">        返回-2说明有浮点解，需要修改数据类型再运算</span></span><br><span class="line"><span class="comment">        返回-1时无解</span></span><br><span class="line"><span class="comment">        返回正数k时说明有k个自由变元，自由变元存放在flag中；</span></span><br><span class="line"><span class="comment">Tips:</span></span><br><span class="line"><span class="comment">    处理过程可能爆int</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e2</span>;</span><br><span class="line"><span class="comment">//有equ个等式，var个变量，那么增广矩阵有equ行，var + 1列；模版中从0开始标号。</span></span><br><span class="line"><span class="keyword">int</span> equ, var;</span><br><span class="line"><span class="keyword">int</span> a[maxn][maxn];</span><br><span class="line"><span class="comment">//x是解集，flag标记是否自由</span></span><br><span class="line"><span class="keyword">int</span> x[maxn], flag[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gauss</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; equ &amp;&amp; j &lt; var; i++, j++)&#123;</span><br><span class="line">        <span class="keyword">int</span> l = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = i + <span class="number">1</span>; k &lt; equ; k++) <span class="keyword">if</span>(<span class="built_in">abs</span>(a[k][j] &gt; a[l][j])) l = k;</span><br><span class="line">        <span class="keyword">if</span>(l != i) <span class="built_in">swap</span>(a[l], a[i]);</span><br><span class="line">        <span class="comment">//i行及以下的该列全为0，转而处理下一列。</span></span><br><span class="line">        <span class="keyword">if</span>(a[i][j] == <span class="number">0</span>)&#123;</span><br><span class="line">            i--; <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = i + <span class="number">1</span>; k &lt; equ; k++) <span class="keyword">if</span>(a[k][j])&#123;</span><br><span class="line">            <span class="keyword">int</span> lcm = <span class="built_in">abs</span>(a[k][j] * a[i][j]) / <span class="built_in">gcd</span>(<span class="built_in">abs</span>(a[k][j]), <span class="built_in">abs</span>(a[i][j]));</span><br><span class="line">            <span class="keyword">int</span> pa = lcm / a[k][j], pb = lcm / a[i][j];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> col = j; col &lt;= var; col++) a[k][col] = a[k][col] * pa - a[i][col] * pb;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//循环完成后，i是有效行数，也就是秩（？）；</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//(I)存在(0, 0, ... ,0, k!=0)的结构存在，即无解,返回-1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = i; k &lt; equ; k++) <span class="keyword">if</span>(a[k][var] != <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//(II)存在自由变元，返回变元数量，并且在flag数组中标记出所有的自由变元。</span></span><br><span class="line">    <span class="keyword">if</span>(j &lt; var)&#123;</span><br><span class="line">        <span class="comment">//i是秩，[0, i - 1]均为非全零的行</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = i - <span class="number">1</span>; k &gt;= <span class="number">0</span>; k--)&#123;</span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="number">0</span>, free_id = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; var; col++) <span class="keyword">if</span>(a[k][col] &amp;&amp; flag[col])&#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                free_id = col;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//一定存在至少一个自由变元，不然一定会被向下过程消去。</span></span><br><span class="line">            <span class="built_in">assert</span>(free_id != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//有两个及以上变元，那么无法确定这些变元</span></span><br><span class="line">            <span class="keyword">if</span>(cnt &gt;= <span class="number">2</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 注释原因:求解变元会涉及到小数？故注释掉，实际操作时根据具体情况处理</span></span><br><span class="line">            <span class="comment">// //只剩一个变元free_id，可以求解出来。</span></span><br><span class="line">            <span class="comment">// int temp = a[k][var];</span></span><br><span class="line">            <span class="comment">// for(int col = 0; col &lt; var; col++) if(a[k][col] &amp;&amp; col != free_id) temp -= a[k][col] * x[col];</span></span><br><span class="line">            <span class="comment">// x[free_id] = tmep / a[k][free_id];</span></span><br><span class="line"></span><br><span class="line">            flag[free_id] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> var - i;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//(III)求解方程，此时保证有唯一解:如果全部为正整数解，返回0，如果出现浮点数解，返回-2；</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = var - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="keyword">int</span> tmep = a[i][var];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; var; j++) <span class="keyword">if</span>(a[i][j]) tmep -= a[i][j] * x[j];</span><br><span class="line">        <span class="keyword">if</span>(temp % a[i][i]) <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">        x[i] = temp / a[i][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改算法中的+-为异或就可以变成异或加的高斯消元法。</p><h4 id="逆矩阵高斯消元"><a href="#逆矩阵高斯消元" class="headerlink" title="逆矩阵高斯消元"></a>逆矩阵高斯消元</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">使用指南：</span></span><br><span class="line"><span class="comment">    读入矩阵大小n和初始矩阵在a[i][j]中, i ,j ∈[0, ... ,n - 1】</span></span><br><span class="line"><span class="comment">    返回在模M意义下的整数矩阵在a[i][j + n]中, i ,j ∈[0, ... ,n - 1】</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e2</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n; ll a[maxn][maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prt</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ;j &lt; <span class="number">2</span> * n; j++) <span class="built_in">printf</span>(<span class="string">&quot;%-10lld &quot;</span>,a[i][j]);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">inverse</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) a[i][j + n] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) a[i][i + n] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">prt</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> l = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = i + <span class="number">1</span>; k &lt; n; k++) <span class="keyword">if</span>(<span class="built_in">abs</span>(a[k][i] &gt; a[l][i])) l = k;</span><br><span class="line">        <span class="keyword">if</span>(l != i) <span class="built_in">swap</span>(a[l], a[i]);</span><br><span class="line">        <span class="built_in">prt</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!a[i][i]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        ll inv = <span class="built_in">qp</span>(a[i][i], M - <span class="number">2</span>, M);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">2</span> * n; k++) a[i][k] = a[i][k] * inv % M;</span><br><span class="line">        <span class="built_in">prt</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) <span class="keyword">if</span>(j != i)&#123;</span><br><span class="line">            ll t = a[j][i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">2</span> * n; k++) a[j][k] = ((a[j][k] - t * a[i][k]) % M + M) % M;</span><br><span class="line">            <span class="built_in">prt</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没有经历过较强数据的测试，使用时需谨慎！⚠️！！！</p><p>求逆元使用的是quick_pow，当模数M不是素数时应该使用exgcd求素数。</p><h4 id="行列式"><a href="#行列式" class="headerlink" title="行列式"></a>行列式</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n; ll a[maxn][maxn];</span><br><span class="line"><span class="function">ll <span class="title">det</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ll ans = <span class="number">1</span>, temp = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> l = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) <span class="keyword">if</span>(<span class="built_in">abs</span>(a[j][i]) &gt; <span class="built_in">abs</span>(a[l][i])) l = j;</span><br><span class="line">        <span class="keyword">if</span>(l != i)&#123;</span><br><span class="line">            <span class="built_in">swap</span>(a[i], a[l]);</span><br><span class="line">            ans = -ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!a[i][i]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) <span class="keyword">if</span>(j != i &amp;&amp; a[j][i])&#123;</span><br><span class="line">            ll lcm = a[i][i] * a[j][i] / <span class="built_in">gcd</span>(<span class="built_in">abs</span>(a[i][i]), <span class="built_in">abs</span>(a[j][i]));</span><br><span class="line">            ll ta = lcm / a[j][i], tb = lcm / a[i][i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; k++) a[j][k] = ta * a[j][k] - tb * a[i][k];</span><br><span class="line">            temp *= ta;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) ans *= a[i][i];</span><br><span class="line">    <span class="keyword">return</span> ans / temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没有经历过较强数据的测试，使用时需谨慎！⚠️！！！</p><h3 id="自适应辛普森求定积分"><a href="#自适应辛普森求定积分" class="headerlink" title="自适应辛普森求定积分"></a>自适应辛普森求定积分</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">f</span><span class="params">(<span class="keyword">double</span> x)</span></span>&#123;</span><br><span class="line">    <span class="comment">//填入积分函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">simpson</span><span class="params">(<span class="keyword">double</span> l, <span class="keyword">double</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (r - l) * (<span class="built_in">f</span>(l) + <span class="built_in">f</span>(r) + <span class="number">4</span> * <span class="built_in">f</span>((l + r) / <span class="number">2</span>)) / <span class="number">6</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">solve</span><span class="params">(<span class="keyword">double</span> L, <span class="keyword">double</span> R, <span class="keyword">double</span> ans)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> mid = (L + R) / <span class="number">2</span>, l = <span class="built_in">simpson</span>(L, mid), r = <span class="built_in">simpson</span>(mid, R);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fabs</span>(l + r - ans) &lt;= eps) <span class="keyword">return</span> ans; </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">solve</span>(L, mid, l) + <span class="built_in">solve</span>(mid, R, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="gcd-amp-exgcd-拓展欧几里德"><a href="#gcd-amp-exgcd-拓展欧几里德" class="headerlink" title="gcd &amp; exgcd(拓展欧几里德)"></a>gcd &amp; exgcd(拓展欧几里德)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">gcd</span><span class="params">(T x, T y)</span></span>&#123;<span class="keyword">return</span> !x? y: <span class="built_in">gcd</span>(y % x, x);&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exgcd</span><span class="params">(T a, T b, T &amp;x, T &amp;y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!b)&#123;x = <span class="number">1</span>; y = <span class="number">0</span>;<span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="built_in">exgcd</span>(b, a % b, y, x); y -= a / b * x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线性筛"><a href="#线性筛" class="headerlink" title="线性筛"></a>线性筛</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">euler</span><span class="params">(<span class="keyword">int</span> *prime, <span class="keyword">int</span> *vis, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> top = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) vis[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[i]) prime[top++] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; top &amp;&amp; i * prime[j] &lt;= n; j++)&#123;</span><br><span class="line">            vis[i * prime[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i % prime[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> top;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-数据结构"><a href="#7-数据结构" class="headerlink" title="7 数据结构"></a>7 数据结构</h2><h3 id="区间合并线段树"><a href="#区间合并线段树" class="headerlink" title="区间合并线段树"></a>区间合并线段树</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tree</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, ll, rr, all;</span><br><span class="line">&#125;tree[maxn &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化区间线段树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    tree[p].l = l; tree[p].r = r;</span><br><span class="line">    tree[p].ll = tree[p].rr = tree[p].all = r - l + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(r == l) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">build</span>(ls, l, mid);</span><br><span class="line">    <span class="built_in">build</span>(rs, mid + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line"><span class="comment">//更新连续左区间</span></span><br><span class="line">    <span class="keyword">if</span>(tree[ls].ll == tree[ls].r - tree[ls].l + <span class="number">1</span>) tree[p].ll = tree[ls].ll + tree[rs].ll;</span><br><span class="line">    <span class="keyword">else</span> tree[p].ll = tree[ls].ll;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//更新连续右区间</span></span><br><span class="line">    <span class="keyword">if</span>(tree[rs].rr == tree[rs].r - tree[rs].l + <span class="number">1</span>) tree[p].rr = tree[ls].rr + tree[rs].rr;</span><br><span class="line">    <span class="keyword">else</span> tree[p].rr = tree[rs].rr;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//更新全区间</span></span><br><span class="line">    tree[p].all = <span class="built_in">max</span>(tree[ls].all, <span class="built_in">max</span>(tree[rs].all, tree[ls].rr + tree[rs].ll));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//将x所在的元素置为k(k = 0/1)；当前节点为p</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> x, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree[p].l == tree[p].r &amp;&amp; tree[p].l == x)&#123;</span><br><span class="line">        tree[p].all = tree[p].ll = tree[p].rr = k;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= (tree[p].l + tree[p].r) &gt;&gt; <span class="number">1</span>) <span class="built_in">update</span>(ls, x, k);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">update</span>(rs, x, k);</span><br><span class="line">    <span class="built_in">up</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">que</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree[p].l == tree[p].r) <span class="keyword">return</span> tree[p].all;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//x处于中心位置的区间则更新之</span></span><br><span class="line">    <span class="keyword">if</span>(x &gt;= tree[ls].r - tree[ls].rr + <span class="number">1</span> &amp;&amp; x &lt;= tree[rs].l + tree[rs].ll - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> tree[ls].rr + tree[rs].ll;</span><br><span class="line">    <span class="comment">//x处于左边其他某个位置</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(x &lt; tree[ls].r - tree[ls].rr + <span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">que</span>(ls, x);</span><br><span class="line">    <span class="comment">//x处于右边其他某个位置</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">que</span>(rs, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="线段树哈希"><a href="#线段树哈希" class="headerlink" title="线段树哈希"></a>线段树哈希</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls (p &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs ((p &lt;&lt; 1) | 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mid ((l + r) &gt;&gt; 1)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">5e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="comment">//数值对mod取模</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">65536</span>;</span><br><span class="line"><span class="comment">//哈希的基底和模数</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> pp = <span class="number">999983</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1000237529</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意mod和M！实际运用时不要写错了！</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//st为哈希和线段树; st1为极值线段树，用于维护对mod取模的相关信息。</span></span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line">ll tag[maxn &lt;&lt; <span class="number">2</span>], st1[maxn &lt;&lt; <span class="number">2</span>], st[maxn &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="comment">//po[i] = pp ^ i; pre[i] = po[0] + po[1] + ... + po[i]，用于对区间快速更新哈希和</span></span><br><span class="line">ll po[maxn], pre[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    st[p] = st[ls] + st[rs] * po[mid - l + <span class="number">1</span>] % M; st[p] %= M;</span><br><span class="line">    st1[p] = <span class="built_in">max</span>(st1[ls], st1[rs]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r &amp;&amp; l == k)&#123;</span><br><span class="line">        st[p] = st1[p] = x;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(k &lt;= mid) <span class="built_in">build</span>(ls, l, mid, k, x);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">build</span>(rs, mid + <span class="number">1</span>, r, k, x);</span><br><span class="line">    <span class="built_in">up</span>(p, l, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tag[p])&#123;</span><br><span class="line">        tag[ls] += tag[p];</span><br><span class="line">        tag[rs] += tag[p];</span><br><span class="line">        </span><br><span class="line">        st[ls] += pre[mid - l] * tag[p] % M; st[ls] %= M;</span><br><span class="line">        st[rs] += pre[r - mid - <span class="number">1</span>] * tag[p] % M; st[rs] %= M;</span><br><span class="line">        </span><br><span class="line">        st1[ls] += tag[p];</span><br><span class="line">        st1[rs] += tag[p];</span><br><span class="line">        </span><br><span class="line">        tag[p] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R)&#123;</span><br><span class="line">        st[p] += pre[r - l] * x % M; st[p] %= M;</span><br><span class="line">        st1[p] += x; tag[p] += x;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">down</span>(p, l, r);</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= mid) <span class="built_in">udpate</span>(ls, l, mid, L, R, x);</span><br><span class="line">    <span class="keyword">if</span>(R &gt; mid) <span class="built_in">update</span>(rs, mid + <span class="number">1</span>, r, L , R, x);</span><br><span class="line">    <span class="built_in">up</span>(p, l, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">purify</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(st1[p] &lt; mod) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">        st[p] %= mod; st1[p] %= mod;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">down</span>(p, l, r);</span><br><span class="line">    <span class="keyword">if</span>(st1[ls] &gt;= mod) <span class="built_in">purify</span>(ls, l, mid);</span><br><span class="line">    <span class="keyword">if</span>(st1[rs] &gt;= mod) <span class="built_in">purify</span>(rs, mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="built_in">up</span>(p, l, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">hsh</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R) <span class="keyword">return</span> st[p];</span><br><span class="line">    <span class="built_in">down</span>(p, l, r);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(R &lt;= mid) <span class="keyword">return</span> <span class="built_in">hsh</span>(ls, l, mid, L, R);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(L &gt; mid) <span class="keyword">return</span> <span class="built_in">hsh</span>(rs, mid + <span class="number">1</span>, r, L, R);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">      需要注意！</span></span><br><span class="line"><span class="comment">      往子树递归时[L, R]要变化成[L, mid](不重要)和[mid + 1, R](重要)！</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">        ll ans = <span class="built_in">hsh</span>(ls, l, mid, L, mid);</span><br><span class="line">        ans += <span class="built_in">hsh</span>(rs, mid + <span class="number">1</span>, r, mid + <span class="number">1</span>, R) * po[mid - L + <span class="number">1</span>] % M;</span><br><span class="line">        ans %= M;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//Fastin;</span></span><br><span class="line">    po[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; maxn; i++) po[i] = po[i - <span class="number">1</span>] * <span class="number">1ll</span> * pp % M;</span><br><span class="line">    pre[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; maxn; i++) pre[i] = pre[i - <span class="number">1</span>] + po[i], pre[i] %= M;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> n, m; <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, a + i);</span><br><span class="line">        <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n, i, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="keyword">int</span> op; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;op);</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> l, r, x; <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;l, &amp;r, &amp;x);</span><br><span class="line">            <span class="built_in">update</span>(<span class="number">1</span>, <span class="number">1</span>, n, l, r, x);</span><br><span class="line">          <span class="comment">//每次更新完后都会将超出范围的叶子结点进行更新，实际应用时需要考虑复杂度是否支持！</span></span><br><span class="line">            <span class="built_in">purify</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> l, r, k; <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;l, &amp;r, &amp;k);</span><br><span class="line">            </span><br><span class="line">            ll res1 = <span class="built_in">hsh</span>(<span class="number">1</span>, <span class="number">1</span>, n, l, l + k - <span class="number">1</span>);</span><br><span class="line">            ll res2 = <span class="built_in">hsh</span>(<span class="number">1</span>, <span class="number">1</span>, n, r, r + k - <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">puts</span>(res1 == res2? <span class="string">&quot;yes&quot;</span>: <span class="string">&quot;no&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>INPUT</code></p><p>数据长度n 操作次数m</p><p>$a_1, a_2,…,a_n$</p><p>$op_1, l_1, r_1, x_1$</p><p>$op_2, l_2, r_2, x_2$</p><p>…</p><p>$op_m, l_m, r_m, x_m$</p><p><code>功能</code></p><ul><li>op为1，对区间[li, ri] += xi, 并对指定模数<code>mod</code>取模</li><li>op为2，查询以li和ri为起点的两端长度均为x的区间的哈希和，以此来判断序列是否相同。</li></ul><h3 id="线段树合并"><a href="#线段树合并" class="headerlink" title="线段树合并"></a>线段树合并</h3><h4 id="子树最多出现次数颜色和的查询"><a href="#子树最多出现次数颜色和的查询" class="headerlink" title="子树最多出现次数颜色和的查询"></a>子树最多出现次数颜色和的查询</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 动态开点线段树：</span></span><br><span class="line"><span class="comment">    - 插入一个节点</span></span><br><span class="line"><span class="comment">    - 合并两棵树</span></span><br><span class="line"><span class="comment"> 维护出现最多的次数的颜色的和，记录两个值(出现次数，颜色和)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mid ((l + r) &gt;&gt; 1)</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1e5</span> * <span class="number">20</span> * <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> haed[maxn], top = <span class="number">0</span>, root[maxn];</span><br><span class="line">star edge[maxn &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    edge[top].to = v;</span><br><span class="line">    edge[top].next = head[u];</span><br><span class="line">    head[u] = top++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NODE</span>&#123;</span><span class="keyword">int</span> mx; ll sum;&#125;;</span><br><span class="line">NODE st[M];</span><br><span class="line"><span class="keyword">int</span> ls[M], rs[M], cnt = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//cnt必须从1开始！这是由merge的实现所决定的！</span></span><br><span class="line"><span class="comment">//加入一个单点作为初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> &amp;p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!p) p = cnt++;</span><br><span class="line">    <span class="keyword">if</span>(l == r &amp;&amp; l == k)&#123;</span><br><span class="line">        st[p].mx = <span class="number">1</span>; st[p].sum = k;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(k &lt;= mid)&#123;</span><br><span class="line">        <span class="built_in">update</span>(ls[p], l, mid, k);</span><br><span class="line">        st[p] = st[ls[p]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">update</span>(rs[p], mid + <span class="number">1</span>, r, k);</span><br><span class="line">        st[p] = st[rs[p]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(st[ls[p]].mx &gt; st[rs[p]].mx) st[p] = st[ls[p]];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(st[ls[p]].mx &lt; st[rs[p]].mx) st[p] = st[rs[p]];</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        st[p].mx = st[ls[p]].mx;</span><br><span class="line">        st[p].sum = st[ls[p]].sum + st[rs[p]].sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将r1与r2对应的两棵结构相同的线段树进行合并，返回值为合并后的树的标号</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> r1, <span class="keyword">int</span> r2, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!r1) <span class="keyword">return</span> r2;</span><br><span class="line">    <span class="keyword">if</span>(!r2) <span class="keyword">return</span> r1;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">        st[r1].mx += st[r2].mx;</span><br><span class="line">        <span class="keyword">return</span> r1;</span><br><span class="line">    &#125;</span><br><span class="line">    ls[r1] = <span class="built_in">merge</span>(ls[r1], ls[r2], l, mid);</span><br><span class="line">    rs[r1] = <span class="built_in">merge</span>(rs[r1], rs[r2], mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="built_in">up</span>(r1);</span><br><span class="line">    <span class="keyword">return</span> r1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll ans[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> par)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[now]; ~i; i = edge[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> to = edge[i].to; <span class="keyword">if</span>(to == par) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(to, now);</span><br><span class="line">        root[now] = <span class="built_in">merge</span>(root[now], root[to], <span class="number">1</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">    ans[now] = st[root[now]].sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//    Fastin;</span></span><br><span class="line">    <span class="built_in">clr</span>(head, <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> c; <span class="built_in">scnaf</span>(<span class="string">&quot;%d&quot;</span>, &amp;c);</span><br><span class="line">        <span class="built_in">udpate</span>(root[i], <span class="number">1</span>, n, c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> u, v; <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">        <span class="built_in">add</span>(u, v); <span class="built_in">add</span>(v, u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">prt</span>(ans + <span class="number">1</span>, n);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>给出一棵n节点的树，每个节点具有一个颜色。</p><p>输出在以1为根时，每个节点及其子树上所有节点中最多数量的颜色的和。</p><p>$n \leq 1e5, c_i \leq n$</p><p>每插入一个节点，会产生logn个新节点，因而总共至多产生nlogn个新节点。</p><p>而在每一次merge时，会合并掉一个节点，合并的复杂度是$O(1)$，所以至多进行nlogn次合并。</p><p>因而线段树合并的总体复杂度是$O(nlogn)$</p><h3 id="segment-tree-beats"><a href="#segment-tree-beats" class="headerlink" title="segment tree beats"></a>segment tree beats</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls (p &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs ((p &lt;&lt; 1) | 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mid ((l + r) &gt;&gt; 1)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[manx];</span><br><span class="line"><span class="comment">//st中记录区间和，mx记录最值，cnt记录最值的数量，smx记录第二极值的大小。</span></span><br><span class="line">ll st[maxn &lt;&lt; <span class="number">2</span>]; <span class="keyword">int</span> mx[maxn &lt;&lt; <span class="number">2</span>], cnt[maxn &lt;&lt; <span class="number">2</span>], smx[maxn &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    st[p] = st[ls] + st[rs];</span><br><span class="line">    <span class="keyword">if</span>(mx[ls] &gt; mx[rs])&#123;</span><br><span class="line">        mx[p] = mx[ls];</span><br><span class="line">        cnt[p] = cnt[ls];</span><br><span class="line">        smx[p] = <span class="built_in">max</span>(mx[rs], smx[ls]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(mx[ls] &lt; mx[rs])&#123;</span><br><span class="line">        mx[p] = mx[rs];</span><br><span class="line">        cnt[p] = cnt[rs];</span><br><span class="line">        smx[p] = <span class="built_in">max</span>(mx[ls], smx[rs]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        mx[p] = mx[ls];</span><br><span class="line">        cnt[p] = cnt[ls] + cnt[rs];</span><br><span class="line">        smx[p] = <span class="built_in">max</span>(smx[ls], smx[rs]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    st[p] -= <span class="number">1ll</span> * cnt[p] * (mx[p] - x);</span><br><span class="line">    mx[p] = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(mx[ls] &gt; mx[p] &amp;&amp; mx[p] &gt; smx[ls]) <span class="built_in">fun</span>(ls, mx[p]);</span><br><span class="line">    <span class="keyword">if</span>(mx[rs] &gt; mx[p] &amp;&amp; mx[p] &gt; smx[rs]) <span class="built_in">fun</span>(rs, mx[p]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">        st[p] = mx[p] = a[l];</span><br><span class="line">        cnt[p] = <span class="number">1</span>;</span><br><span class="line">        smx[p] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">build</span>(ls, l, mid);</span><br><span class="line">    <span class="built_in">build</span>(rs, mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="built_in">up</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(mx[p] &lt;= x) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R)&#123;</span><br><span class="line">        <span class="keyword">if</span>(smx[p] &lt; x)&#123;</span><br><span class="line">            <span class="built_in">fun</span>(p, x); <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">down</span>(p);</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= mid) <span class="built_in">update</span>(ls, l, mid, L, R, x);</span><br><span class="line">    <span class="keyword">if</span>(R &gt; mid) <span class="built_in">update</span>(rs, mid + <span class="number">1</span>, r, L, R, x);</span><br><span class="line">    <span class="built_in">up</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getmx</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R) <span class="keyword">return</span> mx[p];</span><br><span class="line">    <span class="built_in">down</span>(p);</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= mid) ans = <span class="built_in">max</span>(ans, <span class="built_in">getmx</span>(ls, l, mid, L, R));</span><br><span class="line">    <span class="keyword">if</span>(R &gt; mid) ans = <span class="built_in">max</span>(ans, <span class="built_in">getmx</span>(rs, mid + <span class="number">1</span>, r, L, R));</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">getsum</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R) <span class="keyword">return</span> st[p];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">down</span>(p);</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= mid) ans += <span class="built_in">getsum</span>(ls, l, mid, L, R);</span><br><span class="line">    <span class="keyword">if</span>(R &gt; mid) ans += <span class="built_in">getsum</span>(rs, mid + <span class="number">1</span>, r, L, R);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// Fastin;</span></span><br><span class="line">    TTT&#123;</span><br><span class="line">        <span class="keyword">int</span> n, m; <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scnaf</span>(<span class="string">&quot;%d&quot;</span>, a + i);</span><br><span class="line">        <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">            <span class="keyword">int</span> op; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;op);</span><br><span class="line">            <span class="keyword">int</span> x, y, z;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">            <span class="keyword">if</span>(op == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">scnaf</span>(<span class="string">&quot;%d&quot;</span>, &amp;z);</span><br><span class="line">                <span class="built_in">update</span>(<span class="number">1</span>, <span class="number">1</span>, n, x, y, z);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">getmx</span>(<span class="number">1</span>, <span class="number">1</span>, n, x, y));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">getsum</span>(<span class="number">1</span>, <span class="number">1</span>, n, x, y));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=5306">hdu 5306模板</a></p><p>给出长度为$n$的序列，要求支持如下操作:</p><ul><li>给出$l ,r, x$，令$a_i = min(a_i, x), i = l, …, r$</li><li>给出$l, r$，查询区间中的最大值/区间和</li></ul><p>听说不进行区间加减的话复杂度均摊$O(nlogn)$</p><h2 id="8-DP"><a href="#8-DP" class="headerlink" title="8 DP"></a>8 DP</h2><h3 id="依赖背包（树上背包）"><a href="#依赖背包（树上背包）" class="headerlink" title="依赖背包（树上背包）"></a>依赖背包（树上背包）</h3><h4 id="向上转移"><a href="#向上转移" class="headerlink" title="向上转移"></a>向上转移</h4><p>状态转移时暴力枚举儿子的所有状况，将其更新到父亲中。</p><p>时间复杂度$O(N*M^2)$</p><h4 id="向下传递"><a href="#向下传递" class="headerlink" title="向下传递"></a>向下传递</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> manx = <span class="number">1e2</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, W, v[maxn], w[maxn];</span><br><span class="line"><span class="keyword">int</span> dp[maxn][maxn];</span><br><span class="line">star edge[maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> head[maxn], top = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    edge[top].to = v;</span><br><span class="line">    edge[top].next = head[u];</span><br><span class="line">    head[u] = top++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//dp[i][j]表示i子树中重量为j下的最大价值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> par)</span></span>&#123;</span><br><span class="line">    dp[u][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; ~i; i = edge[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> to = edge[i].to; <span class="keyword">if</span>(to == par) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= W; i++) dp[to][i] = dp[u][i];</span><br><span class="line">        <span class="built_in">dfs</span>(to, u);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = W; i &gt;= w[to]; i--) <span class="keyword">if</span>(dp[to][i - w[to]] != <span class="number">-1</span>)</span><br><span class="line">            dp[u][i] = <span class="built_in">max</span>(dp[u][i], dp[to][i - w[to]] + v[to]);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="comment">// Fastin; </span></span><br><span class="line">    <span class="built_in">clr</span>(head, <span class="number">-1</span>); <span class="built_in">clr</span>(dp, <span class="number">-1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;W);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x, y, z; <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;x, &amp;y, &amp;z); <span class="keyword">if</span>(z == <span class="number">-1</span>) z = <span class="number">0</span>;</span><br><span class="line">        w[i] = x; v[i] = y;</span><br><span class="line">        <span class="built_in">add</span>(z, i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>; <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= W; i++) ans = <span class="built_in">max</span>(ans, dp[<span class="number">0</span>][i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>状态数组$dp[i][j]$表示<strong>不允许选取i本身</strong>的最大价值，所以在对i的儿子遍历时，其实是将所有儿子的情况更新到dp[i]中。每次将dp[i]的状态传递给儿子，儿子递归的更新完后再更新回dp[i]</p><p>如果采取这样的方法，<strong>必须使用超级源点</strong>！</p><p>时间复杂度$O(N*M)$</p><h4 id="dfn序上更新背包"><a href="#dfn序上更新背包" class="headerlink" title="dfn序上更新背包"></a>dfn序上更新背包</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line">       </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;random&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line">      </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> manx maxn</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> whlie while</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> itn int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fro for</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> asn ans</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> scnaf scanf</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sacnf scanf</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pritnf printf</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> haed head</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> tmep temp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> udpate update</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> cosnt const</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Fastin freopen(<span class="meta-string">&quot;/home/rqdmap/Desktop/codes/in&quot;</span>, <span class="meta-string">&quot;r&quot;</span>, stdin)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Fastout freopen(<span class="meta-string">&quot;/home/rqdmap/Desktop/codes/main.out&quot;</span>, <span class="meta-string">&quot;w&quot;</span>, stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) ((x) &amp; (-x))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clr(a, x) memset((a), x, sizeof (a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TTT int __; scanf(<span class="meta-string">&quot;%d&quot;</span>, &amp;__); for(int _ = 1; _ &lt;= __; _++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG printf(<span class="meta-string">&quot;DEBUG LINE: %d\n&quot;</span>, __LINE__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NL puts(<span class="meta-string">&quot;&quot;</span>)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*------------------------------------------------------------------------------------*/</span></span><br><span class="line"><span class="keyword">clock_t</span> startTime;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getCurrentTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">double</span>)(<span class="built_in">clock</span>() - startTime) / CLOCKS_PER_SEC;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prt</span><span class="params">(T *a, <span class="keyword">int</span> n, <span class="keyword">bool</span> withid = <span class="number">0</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!withid) <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) cout &lt;&lt; a[i] &lt;&lt; ((i == n - <span class="number">1</span>)? <span class="string">&#x27;\n&#x27;</span>:<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) cout &lt;&lt; i &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; a[i] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">ceil</span><span class="params">(T a, T b)</span></span>&#123;<span class="keyword">return</span> (a + b - <span class="number">1</span>) / b;&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">gcd</span><span class="params">(T x, T y)</span></span>&#123;<span class="keyword">return</span> !x? y: <span class="built_in">gcd</span>(y % x, x);&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exgcd</span><span class="params">(T a, T b, T &amp;x, T &amp;y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!b)&#123;x = <span class="number">1</span>; y = <span class="number">0</span>;<span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="built_in">exgcd</span>(b, a % b, y, x); y -= a / b * x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">qp</span><span class="params">(ll a, ll p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    ll ans = <span class="number">1</span>; <span class="keyword">while</span>(p)&#123;<span class="keyword">if</span>(p &amp; <span class="number">1</span>) ans = ans * a ; a = a * a; p &gt;&gt;= <span class="number">1</span>;&#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">qp</span><span class="params">(ll a, ll p, ll M)</span></span>&#123;</span><br><span class="line">    ll ans = <span class="number">1</span>; <span class="keyword">while</span>(p)&#123; <span class="keyword">if</span>(p &amp; <span class="number">1</span>) ans = ans * a % M; a = a * a % M; p &gt;&gt;= <span class="number">1</span>;&#125;</span><br><span class="line">    <span class="keyword">return</span> (ans % M + M) % M;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">euler</span><span class="params">(<span class="keyword">int</span> *prime, <span class="keyword">int</span> *vis, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> top = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) vis[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[i]) prime[top++] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; top &amp;&amp; i * prime[j] &lt;= n; j++)&#123;</span><br><span class="line">            vis[i * prime[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i % prime[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> top;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">star</span>&#123;</span><span class="keyword">int</span> to, next, w;&#125;; </span><br><span class="line"><span class="comment">/*------------------------------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e3</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxe = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> K =  <span class="number">2e3</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, W;</span><br><span class="line"><span class="keyword">int</span> head[maxn], top = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> w[maxn];</span><br><span class="line">star edge[maxe &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    edge[top].to = v;</span><br><span class="line">    edge[top].next = head[u];</span><br><span class="line">    head[u] = top++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> mx[maxn], root, vis[maxn], S, sze[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getroot</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> par)</span></span>&#123;</span><br><span class="line">    sze[now] = <span class="number">1</span>; mx[now] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[now]; ~i; i = edge[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> to = edge[i].to; <span class="keyword">if</span>(vis[to] || to == par) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">getroot</span>(to, now);</span><br><span class="line">        sze[now] += sze[to];</span><br><span class="line">        mx[now] = <span class="built_in">max</span>(mx[now], sze[to]);</span><br><span class="line">    &#125;</span><br><span class="line">    mx[now] = <span class="built_in">max</span>(mx[now], S - mx[now]);</span><br><span class="line">    <span class="keyword">if</span>(mx[now] &lt; mx[root]) root = now;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dfn[maxn], cnt = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> par)</span></span>&#123;</span><br><span class="line">    dfn[cnt++] = now; sze[now] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = haed[now]; ~i; i = edge[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> to = edge[i].to; <span class="keyword">if</span>(vis[to] || par == to) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(to, now);</span><br><span class="line">        sze[now] += sze[to];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ll ans = <span class="number">0</span>;</span><br><span class="line">ll dp[maxn][K];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line"><span class="keyword">int</span> mp[K * K];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> now)</span></span>&#123;</span><br><span class="line">    cnt = <span class="number">0</span>; <span class="built_in">dfs</span>(now, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= cnt; i++) <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; vec.<span class="built_in">size</span>(); j++) dp[i][j] = <span class="number">0</span>;</span><br><span class="line">    dp[cnt][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = cnt - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="keyword">int</span> u = dfn[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; vec.<span class="built_in">size</span>(); j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(vec[j] / w[u])&#123;</span><br><span class="line">                <span class="keyword">int</span> pos = mp[vec[j] / w[u]];</span><br><span class="line">                <span class="comment">//从当前子树中更新背包的计数</span></span><br><span class="line">                dp[i][pos] += dp[i + <span class="number">1</span>][j];</span><br><span class="line">                dp[i][pos] %= M;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//继承右兄弟的计数方案，为随后传递给父亲不断积累</span></span><br><span class="line">            dp[i][j] += dp[i + sze[u]][j];</span><br><span class="line">            dp[i][j] %= M;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (itn)vec.<span class="built_in">size</span>(); i++) ans = (ans + dp[<span class="number">0</span>][i]) % M;</span><br><span class="line">    ans = (ans + M - <span class="number">1</span>) % M;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sove</span><span class="params">(<span class="keyword">int</span> now)</span></span>&#123;</span><br><span class="line">    vis[now] = <span class="number">1</span>; </span><br><span class="line">    <span class="built_in">fun</span>(now);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[now]; ~i; i = edge[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> to = edge[i].to; <span class="keyword">if</span>(vis[to]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        S = sze[to]; root = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">getroot</span>(to, now);</span><br><span class="line">        <span class="built_in">sove</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// Fastin; </span></span><br><span class="line">    TTT&#123;</span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">clr</span>(head, <span class="number">-1</span>); top = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;W);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scnaf</span>(<span class="string">&quot;%d&quot;</span>, w + i);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> u, v; scanfclrv, u);</span><br><span class="line">        &#125;</span><br><span class="line">        vec.<span class="built_in">clear</span>(); <span class="built_in">clr</span>(mp, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= W; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> res = W / i; </span><br><span class="line">            <span class="keyword">if</span>(vec.<span class="built_in">empty</span>() || *vec.<span class="built_in">rbegin</span>() != res) vec.<span class="built_in">push_back</span>(res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vec.<span class="built_in">size</span>(); i++) mp[vec[i]] = i;</span><br><span class="line"></span><br><span class="line">        root = <span class="number">0</span>;</span><br><span class="line">        S = mx[<span class="number">0</span>] = n;</span><br><span class="line">        <span class="built_in">clr</span>(vis, <span class="number">0</span>); <span class="built_in">clr</span>(dp, <span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">getroot</span>(<span class="number">1</span>, <span class="number">0</span>); <span class="built_in">sove</span>(root);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>给出一颗依赖树，每个节点都表示一个有若干重量的物品。</p><p>一个连通块的总重量定义为连通块内所有节点的重量积。</p><p>问总重量不超过$W$的连通块个数。</p><p>这是一道综合的例题：<strong>点分治</strong>后在每个连通块中的<strong>dfn序列</strong>上进行<strong>背包更新</strong>，更新时不遍历所有可能的重量，而是遍历<strong>乘积压缩</strong>后的状态。</p><p>为了学习dfn序更新背包的知识，着重研究<code>fun</code>数组即可。</p><p>$dp[i][j]$由<strong>两部分</strong>构成，一部分是dfn[i]节点本身子树构成的总重量w满足$\frac W w=j$的计数方案，另一部分递归地继承dfs树上i的<strong>右兄弟</strong>的若干信息。</p><p>因而除了根节点的dp数组为其真实情况以外，其余节点的dp数组均有一些继承右兄弟而来的计数方案，这些方案在最终这一串兄弟们回归到父亲后统一进行贡献。</p><h2 id="10-技术"><a href="#10-技术" class="headerlink" title="10 技术"></a>10 技术</h2><h3 id="1-快读"><a href="#1-快读" class="headerlink" title="1 快读"></a>1 快读</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> <span class="keyword">_t</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(<span class="keyword">_t</span> &amp;x)</span></span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">_t</span> fu = <span class="number">1</span>; <span class="keyword">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>) fu = - <span class="number">1</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        x = (x &lt;&lt; <span class="number">3</span>) + (x &lt;&lt; <span class="number">1</span>) + (ch &amp; <span class="number">15</span>);</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    x *= fu ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-对拍-linux"><a href="#2-对拍-linux" class="headerlink" title="2 对拍(linux)"></a>2 对拍(linux)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e3</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">string s;</span><br><span class="line"><span class="keyword">char</span> str[][<span class="number">100</span>] = &#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;main.cpp&quot;</span>, <span class="string">&quot;std.cpp&quot;</span>, <span class="string">&quot;data.cpp&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc != <span class="number">4</span> &amp;&amp; argc != <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Input $main $std $data!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argc == <span class="number">4</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++) <span class="built_in">strcpy</span>(str[i], argv[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    s = (string)&#123;<span class="string">&quot;g++ &quot;</span>&#125; + str[<span class="number">1</span>] + <span class="string">&quot; -o main&quot;</span>;</span><br><span class="line">    <span class="built_in">system</span>(s.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;原始程序编译完成.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    s = (string)&#123;<span class="string">&quot;g++ &quot;</span>&#125; + str[<span class="number">2</span>] + <span class="string">&quot; -o std&quot;</span>;</span><br><span class="line">    <span class="built_in">system</span>(s.<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">    s = (string)&#123;<span class="string">&quot;g++ &quot;</span>&#125; + str[<span class="number">3</span>] + <span class="string">&quot; -o data&quot;</span>;</span><br><span class="line">    <span class="built_in">system</span>(s.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;数据生成器编译完成&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">system</span>(<span class="string">&quot;./data &gt; in&quot;</span>);</span><br><span class="line">        <span class="built_in">system</span>(<span class="string">&quot;./main &lt; in &gt; main.out&quot;</span>);</span><br><span class="line">        <span class="built_in">system</span>(<span class="string">&quot;./std &lt; in &gt; std.out&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">system</span>(<span class="string">&quot;diff main.out std.out&quot;</span>))&#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;Differences occur!&quot;</span>);</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;--------------Input data:--------------&quot;</span>);</span><br><span class="line">            <span class="built_in">system</span>(<span class="string">&quot;cat in&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;No.%d&#x27;s OK.\n&quot;</span>, cnt++);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Template </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用可持久化01Trie解决区间异或一类问题</title>
      <link href="/2020/06/16/%E5%88%A9%E7%94%A8%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%9601Trie%E8%A7%A3%E5%86%B3%E5%8C%BA%E9%97%B4%E5%BC%82%E6%88%96%E4%B8%80%E7%B1%BB%E9%97%AE%E9%A2%98/"/>
      <url>/2020/06/16/%E5%88%A9%E7%94%A8%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%9601Trie%E8%A7%A3%E5%86%B3%E5%8C%BA%E9%97%B4%E5%BC%82%E6%88%96%E4%B8%80%E7%B1%BB%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>为了补校赛网络的I题，就去看了异或粽子，然后就看到了Trie以及可持久化01Trie，进而就有了这篇博客qaq</p><p>借助这几道题学习一番可持久化01Trie的有关知识</p><p>[toc]</p><span id="more"></span><p>参考博客：<strong><a href="https://blog.csdn.net/qq_42447015/article/details/97812659">可持久化01Trie + 异或粽子 （精心)</a></strong></p><hr><h3 id="P4735-最大异或和"><a href="#P4735-最大异或和" class="headerlink" title="P4735 最大异或和"></a><strong><a href="https://www.luogu.com.cn/problem/P4735">P4735 最大异或和</a></strong></h3><p>题目要求区间中某个位置<code>p∈[L, R]</code>使得<code>a[p] ^ a[p + 1]^ ... ^ a[n] ^ x</code>最大，其中<code>p, L, R</code>给定，允许在该序列末尾动态添加数字。首先根据异或的性质等价转化要求的表达式：<code>`a[p] ^ a[p + 1]^ ... ^ a[n] ^ x = x ^ sum ^ a[1] ^ a[2] ^ ... ^ a[p - 1]</code>，其中sum是整个序列的异或值；因而在某个给定的状态下，我们只需要找位置p-1使得其前缀异或值和x^sum异或值最大即可。为了完成动态修改、查询的工作，我们使用可持久化01Trie，其思想与主席树类似（<del>尽管我还没学但是不妨碍我学会01Trie</del>)。</p><p>可持久化01Trie的核心思想在于：在插入一个新数的时候用该数本身拥有的值新建节点，对于本身不拥有的值则继承上一颗树的情况，即L11、L12所示。</p><p>而在本题中因为要查找一段区间最优的一个异或值，所以为了方便查找额外设置size数组记录当前节点拥有字符串的个数。如果同一个节点在两个不同版本之间的size值不同，那么说明这段版本之间一定拥有一个含有这个值的串，所以应该将指针沿着这个方向前进。因为本题要求异或值最大，所以我们找方向边是否存在，存在的话毫无疑问应该从反向边往后查找，这也就是query函数所完成的工作。</p><p>此外，因为我们分析出来如果给定区间<code>[L, R]</code>，那么最终我们要找的前缀和应该在<code>[L - 1, R - 1]</code>之中，用Trie的版本号表示就意味找<code>R-1</code>和<code>L - 2</code>的差值。为了防止溢出等麻烦的问题，我们添加冗余项<code>0</code>，这样原序列整体下标后移1位，所以就变成了查找<code>R</code>与<code>L - 1</code>的差值。</p><p>最后，因为初始给定3e5的原始序列和<strong>操作</strong>，所以最终串的长度有可能成为<strong>6e5</strong>！又因为可持久化Trie存了每个版本的信息，所以每多一个版本，就会再花费N个节点，N是表达一个数最多需要的位数，故总复杂度应该设置为<strong>6e5 * N</strong>。<del>不然RE</del></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">24</span>;</span><br><span class="line"><span class="keyword">const</span> itn maxn = <span class="number">6e5</span> * N + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TRIE</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> version = <span class="number">0</span>, top = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ch[maxn][<span class="number">2</span>], root[maxn];;</span><br><span class="line">    <span class="keyword">int</span> size[maxn];</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rot = root[version];</span><br><span class="line">        root[++version] = ++top;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = N - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">int</span> id = (x &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line">            ch[top][id] = top + <span class="number">1</span>;<span class="comment">//新建</span></span><br><span class="line">            ch[top][!id] = ch[rot][!id];<span class="comment">//继承</span></span><br><span class="line">            size[top] = size[rot] + <span class="number">1</span>;</span><br><span class="line">            top++; rot = ch[rot][id];</span><br><span class="line">        &#125;</span><br><span class="line">        size[top] = size[rot] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R, itn x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = root[L], r = root[R];</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = N - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">int</span> id = (x &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(size[ch[r][!id]] - size[ch[l][!id]] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                ans |= <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">                r = ch[r][!id]; l = ch[l][!id];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                r = ch[r][id];</span><br><span class="line">                l = ch[l][id];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">TRIE tree;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//    Fastin;</span></span><br><span class="line">    <span class="keyword">int</span> n, m; <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    tree.<span class="built_in">insert</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x); sum ^= x;</span><br><span class="line">        tree.<span class="built_in">insert</span>(sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> l, r, x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        <span class="keyword">char</span> op[<span class="number">2</span>];</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, op);</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">&#x27;A&#x27;</span>)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x); sum ^= x;</span><br><span class="line">            tree.<span class="built_in">insert</span>(sum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;l, &amp;r, &amp;x);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, tree.<span class="built_in">query</span>(l - <span class="number">1</span>, r, x ^ sum));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="P5283-十二省联考2019-异或粽子"><a href="#P5283-十二省联考2019-异或粽子" class="headerlink" title="P5283 [十二省联考2019]异或粽子"></a><strong>P5283 [十二省联考2019]异或粽子</strong></h3><h4 id="前置知识点：P1631-序列合并"><a href="#前置知识点：P1631-序列合并" class="headerlink" title="前置知识点：P1631 序列合并"></a>前置知识点：P1631 序列合并</h4><p>简而言之，用堆$O(logn)$维护n个有序队列各自的最大值，将$n ^2$的比较变成了$n$的比较，值得学习的手法！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[maxn], b[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NODE</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> i, j, sum;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> NODE &amp;b)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sum &gt; b.sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;NODE&gt; pq;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//    Fastin;</span></span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, a + i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, b + i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) pq.<span class="built_in">push</span>(&#123;i, <span class="number">0</span>, a[i] + b[<span class="number">0</span>]&#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> times = n;</span><br><span class="line">    <span class="keyword">while</span>(times--)&#123;</span><br><span class="line">        NODE temp = pq.<span class="built_in">top</span>(); pq.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, temp.sum); <span class="keyword">if</span>(times) <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>); <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> i = temp.i, j = temp.j + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(j &gt;= n) <span class="keyword">continue</span>;</span><br><span class="line">        pq.<span class="built_in">push</span>(&#123;i, j, a[i] + b[j]&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="异或粽子"><a href="#异或粽子" class="headerlink" title="异或粽子"></a>异或粽子</h4><p>给出$n &lt;= 5e5$的序列，问所有区间异或值中前$k &lt;= 2e5$大之和。</p><p>首先做异或前缀，这样就可以用两点表示一段区间，接下里将这些前缀插入到可持久化01Trie中。下面考虑如何查找前k大的每一个数，主要思想与P1631序列合并类似：我们枚举右端点<code>j</code>，对每一个右端点所拥有的一串有序序列从大到小一个个插入到堆中。那么如何维护这个有序队列呢？我们设置结构<code>[i, j, l, r, sum]</code>表示右端点在<code>j</code>，在区间<code>[l, r]</code>中找到的最优左端点是<code>i</code>，其异或值是<code>sum</code>。那么当我们从堆中拿出一个节点后，下一个就应该从右端点在<code>j</code>，左端点处于区间<code>[l, i - 1]</code>和区间<code>[i + 1, r]</code>中找更大的结果并放入堆中。<del>我自己写的时候没有判断哪一边更大而是两边都放进去了 因为不想判断左极限右极限的情况 仅仅多一个log2的复杂度问题不大</del></p><p>不过这里面有一些地方很绕…我想了很久才基本理清楚。<del>qaq</del></p><p>如果初始序列从1开始编号，那么如果当前右端点确定为<code>i</code>，左端点可选区间就在<code>[1, i]</code>，在前缀的表达中就是异或上<code>[0, i - 1]</code>，所以在Trie中的查找就是版本<code>i - 1</code>减去版本<code>0 - 1</code>之间的情况。这样会出现-1这种不太妙的东西，所以我们添加冗余项0，那么就只需要在版本<code>i</code>和版本<code>0</code>之间求差值。</p><p>最后有一个关于可持久化Trie相关的数据范围的问题。。坑</p><p><strong>因为要存版本，所以会多开maxn个节点！</strong></p><p>然而这不意味着要把N开大，因为N开大插入的每一个数占用的节点也会对应变大！</p><p>所以应该在maxn中添加一些冗余的位置，不修改N的最大值！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">33</span>;</span><br><span class="line"><span class="keyword">const</span> itn maxn = <span class="number">5e5</span> * (N + <span class="number">5</span>) + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TRIE</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> version = <span class="number">0</span>, top = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ch[maxn][<span class="number">2</span>], root[maxn];;</span><br><span class="line">    <span class="keyword">int</span> size[maxn], id[maxn];</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(ll x, <span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rot = root[version];</span><br><span class="line">        root[++version] = ++top;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = N - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">int</span> id = (x &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line">            ch[top][id] = top + <span class="number">1</span>;</span><br><span class="line">            ch[top][!id] = ch[rot][!id];</span><br><span class="line">            size[top] = size[rot] + <span class="number">1</span>;</span><br><span class="line">            top++; rot = ch[rot][id];</span><br><span class="line">        &#125;</span><br><span class="line">        size[top] = size[rot] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;id[top] = id;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R, ll x, <span class="keyword">int</span> &amp;k, ll &amp;sum)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = root[L], r = root[R];</span><br><span class="line">        sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = N - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">int</span> id = (x &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(size[ch[r][!id]] - size[ch[l][!id]] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                sum |= <span class="number">1ll</span> &lt;&lt; i;</span><br><span class="line">                r = ch[r][!id]; l = ch[l][!id];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                l = ch[l][id];</span><br><span class="line">                r = ch[r][id];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        k = <span class="keyword">this</span>-&gt;id[r];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">TRIE tree;</span><br><span class="line"></span><br><span class="line"><span class="comment">//右端点j给定，每次找i；当前区间为[l, r]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NODE</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> i, j, l, r;</span><br><span class="line">    ll sum;</span><br><span class="line">    <span class="built_in">NODE</span>(<span class="keyword">int</span> _i, <span class="keyword">int</span>  _j, <span class="keyword">int</span> _l ,itn _r, ll _sum)&#123;</span><br><span class="line">        i = _i; j = _j; l = _l; r = _r; sum = _sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> NODE &amp;b)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sum &lt; b.sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ll a[<span class="number">500010</span>];</span><br><span class="line">priority_queue&lt;NODE&gt; pq;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//    Fastin;</span></span><br><span class="line">    tree.<span class="built_in">insert</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> n, m; <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, a + i);</span><br><span class="line">        a[i] ^= a[i - <span class="number">1</span>];</span><br><span class="line">        tree.<span class="built_in">insert</span>(a[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> k; ll sum;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="comment">//查询[1, i]</span></span><br><span class="line">        tree.<span class="built_in">query</span>(<span class="number">0</span>, i, a[i], k, sum);</span><br><span class="line">        <span class="comment">//[k + 1, i]</span></span><br><span class="line">        pq.<span class="built_in">push</span>(<span class="built_in">NODE</span>(k + <span class="number">1</span>, i, <span class="number">1</span>, i, sum));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        NODE temp = pq.<span class="built_in">top</span>(); pq.<span class="built_in">pop</span>();</span><br><span class="line">        ans += temp.sum;</span><br><span class="line">        <span class="keyword">int</span> i = temp.i, j = temp.j, l = temp.l, r = temp.r;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(i - <span class="number">1</span> &gt;= l)&#123;</span><br><span class="line">            <span class="comment">//划分左端点，查询[l, i - 1]中最合适的端点。</span></span><br><span class="line">            tree.<span class="built_in">query</span>(l - <span class="number">1</span>, i - <span class="number">1</span>, a[j], k, sum);</span><br><span class="line">            pq.<span class="built_in">push</span>(<span class="built_in">NODE</span>(k + <span class="number">1</span>, j, l, i - <span class="number">1</span>, sum));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i + <span class="number">1</span> &lt;= r)&#123;</span><br><span class="line">            tree.<span class="built_in">query</span>(i, r, a[j], k, sum);</span><br><span class="line">            pq.<span class="built_in">push</span>(<span class="built_in">NODE</span>(k + <span class="number">1</span>, j, i + <span class="number">1</span>, r, sum));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2020校赛网络赛I-第k大区间"><a href="#2020校赛网络赛I-第k大区间" class="headerlink" title="2020校赛网络赛I 第k大区间"></a><strong>2020校赛网络赛I 第k大区间</strong></h3><p>xdoj好像最近升级升爆了交不了题</p><p>不知道自己正确与否就又顺手用写了个对拍程序。。原来MacOS也支持system函数那就好写了！</p><p>之前尝试过用管道实现进程通信….然而失败了….qaq</p><p>在1000的范围内对拍下来没有不一样的结果，那么姑且认为是AC了，等之后OJ修好了再康康。</p><p>这道题与异或粽子不同的地方在于不需要查询前k的每一项，而只需要知道第k大确切是多少，从而k的范围也变大到了$n^2$的数量级。那么就回到了梦最开始的地方，二分答案，通过持久01Trie检查是否有足够多的大于等于该值的区间。</p><p>同样是区间查询，所以先做前缀异或和，将区间查询转换为点对查询。然后枚举右端点$j$，看其对应的左端点有哪些满足异或上$a[j]$后比二分的答案更大。因而我们在Trie中维护size表示节点拥有的子串个数，查询时按照如下法则：</p><ul><li>如果二分答案在该位为0，那么$a[j]$在该位的值与其反向边所拥有的所有串异或全部都可以取，同向边则需要进一步dfs看更低位的情况。</li><li>如果二分答案在该位为0，那么必须走反向边才能满足这一位不比1小，素以从反向边开始进一步dfs；这里要判断一下是否存在至少一个反向边，如果没有直接返回0即可。（因为终点根据wei是否小于0判断，小于0返回1，其前提是前面的每一位都相等，所以不允许之前有不存在的情况）</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">32</span>;</span><br><span class="line"><span class="keyword">const</span> itn maxn = <span class="number">1e5</span> * (N + <span class="number">5</span>) + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TRIE</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> version = <span class="number">0</span>, top = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ch[maxn][<span class="number">2</span>], root[maxn];;</span><br><span class="line">    <span class="keyword">int</span> size[maxn];</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rot = root[version];</span><br><span class="line">        root[++version] = ++top;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = N - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">int</span> id = (x &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line">            ch[top][id] = top + <span class="number">1</span>;</span><br><span class="line">            ch[top][!id] = ch[rot][!id];</span><br><span class="line">            size[top] = size[rot] + <span class="number">1</span>;</span><br><span class="line">            top++; rot = ch[rot][id];</span><br><span class="line">        &#125;</span><br><span class="line">        size[top] = size[rot] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//查询[L + 1, R]区间中异或上x后大于等于key的数量</span></span><br><span class="line">    <span class="function">ll <span class="title">query</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, ll x, ll key, <span class="keyword">int</span> wei)</span></span>&#123;</span><br><span class="line">        <span class="comment">//什么时候会进行递归？前面的所有位都相等的情况！</span></span><br><span class="line">        <span class="keyword">if</span>(wei &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        ll res = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> op = (key &gt;&gt; wei) &amp; <span class="number">1</span>, id = (x &gt;&gt; wei) &amp; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//key的这一位是0，结果可以是0/1</span></span><br><span class="line">            res += size[ch[r][!id]] - size[ch[l][!id]];</span><br><span class="line">            <span class="keyword">if</span>(size[ch[r][id]] - size[ch[l][id]] &gt; <span class="number">0</span>)</span><br><span class="line">                res += <span class="built_in">query</span>(ch[l][id], ch[r][id], x, key, wei - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(size[ch[r][!id]] - size[ch[l][!id]] &gt; <span class="number">0</span>)</span><br><span class="line">            res += <span class="built_in">query</span>(ch[l][!id], ch[r][!id], x, key, wei - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">TRIE tree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line">ll a[<span class="number">100010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*对于每个右端点j，查询左端点[1, j]看多少个区间的值大于等于x</span></span><br><span class="line"><span class="comment">     前缀左端点区间[0, j - 1] 查询[-1, j - 1] 添加冗余项0 故查询[0, j]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> l = tree.root[<span class="number">0</span>], r = tree.root[i];</span><br><span class="line">        ans += tree.<span class="built_in">query</span>(l, r, a[i], x, N - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ans &gt;= m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//    Fastin;</span></span><br><span class="line">    tree.<span class="built_in">insert</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, a + i);</span><br><span class="line">        a[i] ^= a[i - <span class="number">1</span>];</span><br><span class="line">        tree.<span class="built_in">insert</span>(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    ll left = <span class="number">0</span>, right = (<span class="number">1ll</span> &lt;&lt; <span class="number">32</span>) - <span class="number">1</span>, middle;</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">        middle = (left + right + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(middle)) left = middle;</span><br><span class="line">        <span class="keyword">else</span> right = middle - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, left);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Trie </tag>
            
            <tag> 可持久化 </tag>
            
            <tag> 可持久化01Trie </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2017_CCPC_HARBIN</title>
      <link href="/2020/06/16/2017-CCPC-HARBIN/"/>
      <url>/2020/06/16/2017-CCPC-HARBIN/</url>
      
        <content type="html"><![CDATA[<p>新博客的第一篇文章，打算吸取一下之前CSDN写完博客找不到题的教训：对于套题的补题应该设置一些比较明显的目录以待今后查阅，每个题目的题目以及知识点都予以简单的描述。</p><p>[toc]</p><span id="more"></span><p><strong><a href="https://vjudge.net/contest/378359">2017中国大学生程序设计竞赛-哈尔滨站</a></strong> </p><p>这好像是一场比较难(<del>但是队友很顶</del>)的训练赛，然而我又一次死在了计算几何上，并且成为爆交狂魔…qaq</p><p>不过总而言之打套题还是感觉不仅对于算法力还是对于码力都有很大的提升，自此我找到了真正的快乐 /xyx</p><!-- more --><p><img src="2017-CCPC-HARBIN/1.png" alt="1" style="zoom:50%;" /></p><hr><h3 id="A-回文串-amp-线段树"><a href="#A-回文串-amp-线段树" class="headerlink" title="A  回文串 &amp; 线段树"></a><strong>A</strong>  回文串 &amp; 线段树</h3><p>场上队友过了这道题(<del>orz</del>)，赛后自己补一下</p><p>研读题目规定的回文串的具体形式，发现这是两个回文串的嵌套，因而题目便转化为了找有序对<code>(i, j)</code>满足</p><ul><li><p>$i &lt;j$</p></li><li><p>$i + r[i] &gt;= j$</p></li><li><p>$j - r[j] &lt;= i$</p></li></ul><p>其中$r[i]$是以i为中心的回文串的半径；$r$数组可以用Manacher算法$O(n)$的处理出来，接下来就是统计互相覆盖的点对。</p><p>想了很久并没有想到好办法…学习了一番线段树的解法..</p><p>我们先预处理出数组<code>vec[i]</code>表示以<code>i</code>为起点的回文串的中心位置，然后顺序遍历字符串，每次将数组<code>vec[i]</code>的中心位置加入线段树，接着查询<code>[i + 1, i + r[i]</code>点的个数。因为查询的是<code>[i + 1, i + r[i]]</code>，所以可以保证上述三个条件中的12条件；另一方面，因为该中心点已经出现在线段树中了，所以其起点的位置一定小于等于当前位置<code>i</code>，这也就保证条件3的成立。综上所述就可以$O(nlogn)$扫一遍得到所有的结果。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">5e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> Manacher算法</span></span><br><span class="line"><span class="comment"> 读入一个字符串temp及其长度n;</span></span><br><span class="line"><span class="comment"> 该算法构造出s并赋予截断标志, 自动初始化、获得数组p[i];</span></span><br><span class="line"><span class="comment"> 对于某个位置i∈[0, 2 * n], 以i为中心的回文串的参数如下:</span></span><br><span class="line"><span class="comment">    int start = (i / 2) - (p[i] / 2) + (i &amp; 1);    //回文串在原串中的起点</span></span><br><span class="line"><span class="comment">    int d = p[i] - 1;   //回文串在原串中的总长度</span></span><br><span class="line"><span class="comment">    int middle = (i - 1) / 2;   //回文串在原串的中点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">char</span> temp[maxn], s[maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> p[maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">manacher</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        s[i &lt;&lt; <span class="number">1</span>] = <span class="string">&#x27;#&#x27;</span>; s[i &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] = temp[i];</span><br><span class="line">    &#125;</span><br><span class="line">    s[n &lt;&lt; <span class="number">1</span>] = <span class="string">&#x27;#&#x27;</span>; s[n &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> id = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n &lt;&lt; <span class="number">1</span>; i++) p[i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n &lt;&lt; <span class="number">1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt;= right) p[i] = <span class="built_in">min</span>(right - i + <span class="number">1</span>, p[<span class="number">2</span> * id - i]);</span><br><span class="line">        <span class="keyword">while</span>(i + p[i] &lt;= <span class="number">2</span> * n &amp;&amp; i - p[i] &gt;= <span class="number">0</span> &amp;&amp; s[i + p[i]] == s[i - p[i]])</span><br><span class="line">            p[i]++;</span><br><span class="line">        <span class="keyword">if</span>(right &lt; i + p[i] - <span class="number">1</span>)&#123;</span><br><span class="line">            id = i; right = i + p[i] - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls (p &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs ((p &lt;&lt; 1) | 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mid ((l + r) &gt;&gt; 1)</span></span><br><span class="line"></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; vec[maxn];</span><br><span class="line"></span><br><span class="line">ll st[maxn &lt;&lt; <span class="number">2</span>], tag[maxn &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="comment">//区间查询，单点置值。</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;st[p] = st[ls] + st[rs];&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r &amp;&amp; l == k)&#123;</span><br><span class="line">        st[p] += <span class="number">1</span>;</span><br><span class="line">        tag[p] += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(k &lt;= mid) <span class="built_in">update</span>(ls, l, mid, k);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">update</span>(rs, mid + <span class="number">1</span>, r, k);</span><br><span class="line">    <span class="built_in">up</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L &gt; R) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R) <span class="keyword">return</span> st[p];</span><br><span class="line">    ll ans =<span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= mid) ans += <span class="built_in">query</span>(ls, l, mid, L, R);</span><br><span class="line">    <span class="keyword">if</span>(R &gt; mid) ans += <span class="built_in">query</span>(rs, mid + <span class="number">1</span>, r, L, R);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//    Fastin;</span></span><br><span class="line">    <span class="keyword">int</span> t; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t); <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">clr</span>(st, <span class="number">0</span>); <span class="built_in">clr</span>(tag, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, temp); n = (<span class="keyword">int</span>)<span class="built_in">strlen</span>(temp);</span><br><span class="line">        <span class="built_in">manacher</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) vec[i].<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">2</span> * n; i += <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> start = (i / <span class="number">2</span>) - (p[i] / <span class="number">2</span>) + (i &amp; <span class="number">1</span>), middle = (i - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            vec[start].<span class="built_in">push_back</span>(middle);</span><br><span class="line">        &#125;</span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="comment">//2 * i + 1 是在s串中的下标。</span></span><br><span class="line">            <span class="keyword">int</span> r = (p[<span class="number">2</span> * i + <span class="number">1</span>] - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> x: vec[i]) <span class="built_in">update</span>(<span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>, x);</span><br><span class="line">            ans += <span class="built_in">query</span>(<span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>, i + <span class="number">1</span>, i + r);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="B-区间第k大-gt-二分"><a href="#B-区间第k大-gt-二分" class="headerlink" title="B  区间第k大 -&gt; 二分"></a><strong>B</strong>  区间第k大 -&gt; 二分</h3><p>上一次见到区间第k大相关问题时是在2018CCPC网络赛，当时好像是个真实的在线查询与修改的主席树，而这一次是一个披着第k大外衣的二分算法。</p><p>对于某个待检验的值x，我们统计该序列中所有<strong>满足其第k大的数大于等于x的区间</strong>的个数。如果有个数$cnt&gt;=m$，那么这个值$x$就有可能成为最终的第m大数，更新二分下界；不然，这个数肯定不会成为第m大数，更新二分上界。</p><p>有的答案用了离散化&amp;二分答案，我学习了这种思想后觉得没有必要进行离散化的二分答案，可以直接对排过序、去过重的序列的下标进行二分，检查当前下标所对应的值以及序列中其他值的大小关系即可。</p><p><del>因为学习的算法中从1开始编号，所以我在L13计算的时候也用了(n - vec[i] + 1)计算….因而DEBUG了半天才过….</del></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, l;</span><br><span class="line">ll m;</span><br><span class="line"><span class="keyword">int</span> a[maxn], b[maxn];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line"><span class="comment">//检查多少个区间的第k大数 &gt;= x</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    vec.<span class="built_in">clear</span>(); vec.<span class="built_in">push_back</span>(<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="keyword">if</span>(a[i] &gt;= x) vec.<span class="built_in">push_back</span>(i);</span><br><span class="line">    ll res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>, top = (<span class="keyword">int</span>)vec.<span class="built_in">size</span>(); i &lt; top; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= l) res += (vec[i - l + <span class="number">1</span>] - vec[i - l]) * <span class="number">1ll</span> * (n - vec[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res &gt;= m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//    Fastin;</span></span><br><span class="line">    <span class="keyword">int</span> t; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t); <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %lld&quot;</span>, &amp;n, &amp;l, &amp;m); <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, a + i);</span><br><span class="line">            b[i] = a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(b, b + n);</span><br><span class="line">        <span class="keyword">int</span> top = (<span class="keyword">int</span>)(<span class="built_in">unique</span>(b, b + n) - b);</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = top - <span class="number">1</span>, middle;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            middle = (left + right + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">check</span>(b[middle])) left = middle;</span><br><span class="line">            <span class="keyword">else</span> right = middle - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, b[left]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><del>因为与2020校赛网络赛I题类似，而当时那道题看题解好像好难的样子就没有补，所以借此机会也补完了I题学习了第一个可持久化结构</del></p><h3 id="J-组合数学-amp-数学期望"><a href="#J-组合数学-amp-数学期望" class="headerlink" title="J   组合数学 &amp; 数学期望"></a>J   组合数学 &amp; 数学期望</h3><p>学习于博客 : <a href="https://blog.csdn.net/axuhongbo/article/details/78684561">hdu6239 Interview 期望+拉格朗日插值法|生成函数 推公式</a></p><p>算是一个比较纯粹的数学题，但是发现这道题目的时候已经有点晚，没有来得及推完所有结果。</p><p>最初我自己想的时候没有考虑清楚，认为当前观测到的事实所带来一些约束条件出现的几率都是等可能的，但是这不符合题目的要求；题目只保证了在最开始经理选择K值时每个位置几率相等，所以当观测发生后，尽管K可能出现的范围确定，但是他们的几率不是等可能的，不能简单的进行等概率计算。</p><p>一种可行的办法是转化为古典概型，通过情况的总数、每一种情况下的观测值进行计算随机变量的数学期望。</p><p>当<strong>已知Bob在第一天面试</strong>时，应该有不等式$1 &lt;= b &lt;= k &lt; a &lt;= n$，总数就是这个不等式所有可能的三元组$(b, k, a)$的个数。我们可以将不等式转化为另一种形式:</p><p>令: <script type="math/tex">x= b- 1, y = k - b, z = a - k - 1, w = n - a</script></p><p>则有: <script type="math/tex">x + y + z + w = n - 2, x, y, z, w>=0</script></p><p>求不定方程的整数解个数。</p><p>那么结果显然，总数有$(^{n+1}_{\space\space3})$</p><p>接下来考虑第二天面试次序的值。考虑这样的枚举方法：枚举Bob和Alice的间距$d$，两人一共有$n-d$种可能的布置位置，而对于每一种位置，K可以取的范围为<code>[Bob, Alice)</code>，Alice第二天的面试次序对应分别为<code>1,2,...,d</code>。因而对于每一个$d$，都会有贡献$\frac{d *(d + 1)}{2}$。故在所有情况中，Alice的位置可以用以下和式表达：</p><p>$\sum_{d = 1}^{n-1}$ $(n-d)<em>$ $ \frac {d </em>(d + 1)}{2}$       $(*)$</p><p>化简一番得到$(^{n+2}_{\space\space4})$</p><p>由于这个和式可以很容易地构造阶梯项做差消去中间量，所以没有花功夫再去学习<del>拉格朗日插值 生成函数</del>等算法。不过最主要的原因还是要学的东西太多了…而组合数学和具体数学已经无数次被提起日程并被拖延至今了。</p><p>下面<strong>考虑Bob在第二天面试</strong>时。</p><p>总数可以类似地考虑两个不等式的值:</p><p>$0 &lt;= k &lt;a &lt;b &lt;= n$</p><p>$0&lt;=k&lt;b&lt;a&lt;=n$</p><p>这两个不等式形式对称，结合Bob第一天的讨论方法易知结果为$2*(^{n+1}_{\space\space3})$.</p><p>而面试的次序分为两类情况讨论:</p><ul><li>$0 &lt;= k &lt; a &lt; b &lt;= n$. 在这种情况中，我们可以类似地枚举距离$d = b - k$，对于每一个距离Alice的次序会取到<code>[1,..,d-1]</code>，$d$从2取到n，将$(*)$式稍作变换就与这种情况相同。</li><li>$0 &lt;= k &lt; b &lt; a &lt;= n$. 此时，我们枚举Alice在第二天的次序，即$d = a - k$。对于每一个次序，Bob可以取的范围在<code>[k + 1, a- 1]</code>，即有$d-1$种可行位置，那么结果就是$\sum_{d=2}^{n}$ $d(d-1)$，这恰是上一种情况、也就是$(*)$式的两倍。</li></ul><p>因而综上所示，Bob在第二天时位次的总和是$(<em>)$ 式的三倍，即$3</em>(^{n+2}_{\space\space4})$.</p><p>至此，我们有了总数和每种情况下的次序之和，做除法就可以得到期望。结果分别为$\frac{n+2}{4}$与$\frac{3n+6}{8}$。</p><h3 id="M-计算几何"><a href="#M-计算几何" class="headerlink" title="M 计算几何"></a>M 计算几何</h3><p><del>论如何爆交40发</del></p><p>给出n个点，试找出一个圆过$ceil\frac n2$个点，保证这样的圆一定存在。</p><p>很明显的一个随机化，容易推出任意找三个点不在该圆上的概率接近$\frac78$，因而我们只需要随机100次就可以几乎确定下来这个圆。那为什么WA了40发呢..以为是精度，结果是情况少考虑了。qaq在我的算法中，如果随机得到的3个点共线，就continue进行下一次。然而我没有特判4点共线的情况，导致了这种情况下找不到一个合适的圆。</p><p>贴一个已知平面三点求圆心及其半径的板子。</p><p>证明方法为做差解二元一次方程的行列式结果。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cal</span><span class="params">(<span class="keyword">double</span> x1, <span class="keyword">double</span> y1, <span class="keyword">double</span> x2, <span class="keyword">double</span> y2, <span class="keyword">double</span> x3, <span class="keyword">double</span> y3)</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> a, b, c, d, e, f;</span><br><span class="line">    a = <span class="number">2</span> * (x2 - x1);</span><br><span class="line">    b = <span class="number">2</span> * (y2 - y1);</span><br><span class="line">    c = x2 * x2 + y2 * y2 - x1 * x1 - y1 * y1;</span><br><span class="line">    d = <span class="number">2</span> * (x3 - x2);</span><br><span class="line">    e = <span class="number">2</span> * (y3 - y2);</span><br><span class="line">    f = x3 * x3 + y3 * y3 - x2 * x2 - y2 * y2;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">double</span> x, y, r;</span><br><span class="line">    x = (b * f - e * c)/(b * d - e * a);</span><br><span class="line">    y = (d * c - a * f)/(b * d - e * a);</span><br><span class="line">    r = <span class="built_in">sqrt</span>((x - x1) * (x - x1) + (y - y1) * (y - y1));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算几何 </tag>
            
            <tag> 回文树 </tag>
            
            <tag> 线段树 </tag>
            
            <tag> 二分 </tag>
            
            <tag> 区间第k大 </tag>
            
            <tag> 组合数学 </tag>
            
            <tag> 数学期望 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
